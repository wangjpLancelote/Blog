{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/assets/name.png","path":"assets/name.png","modified":0,"renderable":0},{"_id":"source/assets/secret.png","path":"assets/secret.png","modified":0,"renderable":0},{"_id":"themes/keep/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/images/avatar.svg","path":"images/avatar.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/bg.svg","path":"images/bg.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/bg2.svg","path":"images/bg2.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/keep/source/images/robotDog.jpg","path":"images/robotDog.jpg","modified":0,"renderable":1},{"_id":"themes/keep/source/js/back2top.js","path":"js/back2top.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/code-block.js","path":"js/code-block.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/header-shrink.js","path":"js/header-shrink.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/toggle-theme.js","path":"js/toggle-theme.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/animated.styl","path":"css/common/animated.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/basic.styl","path":"css/common/basic.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/css-variables.styl","path":"css/common/css-variables.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/keep-style.styl","path":"css/common/keep-style.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/stylus-variables.styl","path":"css/common/stylus-variables.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/404.styl","path":"css/layout/404.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/page.styl","path":"css/layout/page.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/post-content.styl","path":"css/layout/post-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/aliyun.png","path":"images/deploy-provider/aliyun.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/gitee.png","path":"images/deploy-provider/gitee.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/github.png","path":"images/deploy-provider/github.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/netlify.png","path":"images/deploy-provider/netlify.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/tencent_cloud.png","path":"images/deploy-provider/tencent_cloud.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/upyun.png","path":"images/deploy-provider/upyun.png","modified":0,"renderable":1},{"_id":"themes/keep/source/images/deploy-provider/vercel.png","path":"images/deploy-provider/vercel.png","modified":0,"renderable":1},{"_id":"themes/keep/source/font/css/brands.min.css","path":"font/css/brands.min.css","modified":0,"renderable":1},{"_id":"themes/keep/source/font/css/fontawesome.min.css","path":"font/css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"themes/keep/source/font/css/regular.min.css","path":"font/css/regular.min.css","modified":0,"renderable":1},{"_id":"themes/keep/source/font/css/solid.min.css","path":"font/css/solid.min.css","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-brands-400.ttf","path":"font/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-brands-400.woff2","path":"font/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-regular-400.ttf","path":"font/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-regular-400.woff2","path":"font/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-solid-900.ttf","path":"font/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-solid-900.woff2","path":"font/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-v4compatibility.woff2","path":"font/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"themes/keep/source/font/webfonts/fa-v4compatibility.ttf","path":"font/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"themes/keep/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/page/category-page.js","path":"js/page/category-page.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/page/photos-page.js","path":"js/page/photos-page.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/page/links-page.js","path":"js/page/links-page.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/page/tools-page.js","path":"js/page/tools-page.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/post/copyright-info.js","path":"js/post/copyright-info.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/post/post-helper.js","path":"js/post/post-helper.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/post/share.js","path":"js/post/share.js","modified":0,"renderable":1},{"_id":"themes/keep/source/js/post/toc.js","path":"js/post/toc.js","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/code-block/code-block.styl","path":"css/common/code-block/code-block.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/code-block/highlight.styl","path":"css/common/code-block/highlight.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/tags/keep-button.styl","path":"css/common/tags/keep-button.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/tags/keep-note.styl","path":"css/common/tags/keep-note.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/tags/keep-tabs.styl","path":"css/common/tags/keep-tabs.styl","modified":0,"renderable":1},{"_id":"themes/keep/source/css/common/code-block/code-theme.styl","path":"css/common/code-block/code-theme.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Element-UI组件解析.md","hash":"dc92225ce4d8201198906ecd9e0986ecc6a8029a","modified":1716125720626},{"_id":"source/_data/links.yml","hash":"c54a3fc61dd3e190eebf92e256a3d395507c8d47","modified":1711437215915},{"_id":"source/about/index.md","hash":"8a6e479c9f234dd719ea7063ce58234ff43cc557","modified":1711437215915},{"_id":"source/_posts/Contract.md","hash":"067aa47fc773f6e3341fdce2b46c65cb0d7463c0","modified":1716346341956},{"_id":"source/_posts/DeFi.md","hash":"e1d9821e1324f276cc23d0d37228bf11c93012fd","modified":1711592400909},{"_id":"source/_posts/Redux-middleware.md","hash":"87bac8ecc5d0b35ee4d39dbb98b4e6b1aacb4832","modified":1711439641390},{"_id":"source/_posts/GameFi.md","hash":"cdc1f9a9a323f80fd30b336df4a28c20d0974311","modified":1711437215915},{"_id":"source/_posts/farm.md","hash":"da9703ff30222b3d4e3e9661dc879871866364cd","modified":1711437215915},{"_id":"source/_posts/runners.md","hash":"1c0db020af59d49c7fcd9d90448ee00e14f64f5d","modified":1711439514666},{"_id":"source/_posts/smartContract.md","hash":"4fd5f09beed5ec54a47ed0dbcd1b2db12d5a6f4e","modified":1711439299211},{"_id":"source/_posts/token.md","hash":"be521849db6c4527595d51f33b88f69eccb92a79","modified":1711439184572},{"_id":"source/_posts/wallet.md","hash":"579365b9f2d528fa9b8e5b9ba4e1661abc75c3ff","modified":1711437215915},{"_id":"source/_posts/前端部署.md","hash":"feaafb3af5fa91d85ae2df1ff89a5bb43f075cc6","modified":1711439777343},{"_id":"source/_posts/Recoli.md","hash":"deb6cf88b17d315d238621622467e3952bf98dd8","modified":1711520116721},{"_id":"source/_posts/ReactServerComponent.md","hash":"cc3cad754bea61c8a14d446ea48d45bb14e96361","modified":1716346198027},{"_id":"source/_posts/oracle.md","hash":"913271195c6de9a41bbb1c19dec2cd594cd38bad","modified":1711439102681},{"_id":"source/_posts/重新出发.md","hash":"bfc97f5977ff99193280798fbfb8af4a8151cefd","modified":1715595080959},{"_id":"source/_posts/聚合器Yearn.md","hash":"e170ad2d014ca27dfdbbe44770d06cfe0dd8402d","modified":1711684366622},{"_id":"source/links/index.md","hash":"0edbae7e5e083a59d021fccbc75273ed7d069f6d","modified":1711437215917},{"_id":"source/assets/secret.png","hash":"272cbc81b60a084f6314116c6ea3ab630f0a6ae8","modified":1711437215917},{"_id":"source/assets/name.png","hash":"3cb8ee9cabbc499f35b5351b20966c0e65c1a38d","modified":1711437215916},{"_id":"themes/keep/.gitignore","hash":"c4cd17a16e43203c7ae1ad41079a671e98ea52d5","modified":1711438828116},{"_id":"themes/keep/.editorconfig","hash":"a1c91f0a086bf92fddb02ccf23578ec2b51c099c","modified":1711438828115},{"_id":"themes/keep/.npmignore","hash":"5f1a11e233e883dace7de8daac9e0f4d2ace6b1d","modified":1711438828116},{"_id":"themes/keep/.commitlintrc.js","hash":"3925f491e830dcb684933589cec3d4be8db0ff26","modified":1711438828115},{"_id":"themes/keep/.prettierrc","hash":"459178a4dff70a0885b6f5a49eb6a6265eea3083","modified":1711438828116},{"_id":"themes/keep/package.json","hash":"f127a60ca33c0c11298fd658167c7f206507c405","modified":1711438828122},{"_id":"themes/keep/README.md","hash":"1ee61586bb39b2a14e9461b944a6f9c04f7ec4a2","modified":1711438828117},{"_id":"themes/keep/.github/FUNDING.yml","hash":"19b9fddc1871ee1e16738677cfe145877b761dd2","modified":1711438828115},{"_id":"themes/keep/.husky/commit-msg","hash":"acb6c4e5a6a3c713df9264e4d36798d6326580bb","modified":1711438828116},{"_id":"themes/keep/.husky/pre-commit","hash":"12a9c8125c55c9cc29620696a0fa050ee61f9a2b","modified":1711438828116},{"_id":"themes/keep/docs/README_zh-CN.md","hash":"8b9bf2013ced29092362f4b32fa8d2694a0c910f","modified":1711438828118},{"_id":"themes/keep/docs/README_zh-TW.md","hash":"b01ba3e9017b82a1d24f1893a8c34766f37488a0","modified":1711438828118},{"_id":"themes/keep/LICENSE","hash":"a2f9ffbf32eeb6284afa81bc4fb4c27b80d044e9","modified":1711438828117},{"_id":"themes/keep/_config.yml","hash":"15bc0b049d833970b5c8b7e18b135ec56f325c98","modified":1711684666097},{"_id":"themes/keep/languages/zh-CN.yml","hash":"d786da20ace874d69d356d1fc62cc14333f4329f","modified":1711438828118},{"_id":"themes/keep/languages/en.yml","hash":"69010ce402b8258a1c931fd0dc093bea8780fd1f","modified":1711438828118},{"_id":"themes/keep/.stylelintrc.js","hash":"63ce9d43e8675a8cb771332c81c89ba7a60b5516","modified":1711438828116},{"_id":"themes/keep/CHANGELOG.md","hash":"e2607542648c6f93a2c9e2ae999d7834eee39931","modified":1711438828117},{"_id":"themes/keep/languages/zh-TW.yml","hash":"b24977d0fa60b4cb04548866123e74f9f04202c5","modified":1711438828118},{"_id":"themes/keep/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1711438828121},{"_id":"themes/keep/layout/category-content.ejs","hash":"3e5bd0cd6adbfca93c2f08893b1f00c93e819559","modified":1711438828121},{"_id":"themes/keep/layout/category-list.ejs","hash":"31066addd434c7db2f6b5dce45302bb1ae8daa5f","modified":1711438828122},{"_id":"themes/keep/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1711438828122},{"_id":"themes/keep/layout/home-content.ejs","hash":"eda0f23f72a3ed07e16eb35cab27b168b00d3de9","modified":1711438828122},{"_id":"themes/keep/layout/404.ejs","hash":"374939be71b9b29ef4a955e1fdf1d2b70f0b4f0b","modified":1711438828118},{"_id":"themes/keep/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1711438828122},{"_id":"themes/keep/layout/layout.ejs","hash":"e03731246bc99439eca82547081539618832a216","modified":1711438828122},{"_id":"themes/keep/layout/archive-content.ejs","hash":"e753c99c041f34f27d673e8c8da2f362ebeb2358","modified":1711438828121},{"_id":"themes/keep/layout/tag-content.ejs","hash":"433996e7b50262283f6a84d4918814220cd52036","modified":1711438828122},{"_id":"themes/keep/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1711438828122},{"_id":"themes/keep/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1711438828122},{"_id":"themes/keep/.github/ISSUE_TEMPLATE/bug-report.yml","hash":"523aee0638f2f6cda2da99c45c1820337d238c27","modified":1711438828115},{"_id":"themes/keep/.github/ISSUE_TEMPLATE/config.yml","hash":"c9aedf2c4d2b2addf1fa87260584938ed04ad442","modified":1711438828116},{"_id":"themes/keep/layout/page.ejs","hash":"b89e9226f4934ee7f5adff6c80280473df92a1da","modified":1711438828122},{"_id":"themes/keep/.github/ISSUE_TEMPLATE/other.yml","hash":"08f774428c9e9e0255a2fbb67f550ccdc89fe5b1","modified":1711438828116},{"_id":"themes/keep/.github/workflows/auto-merge.yml","hash":"1597492ba41e12feaab01e4a6cd0a2d6a49df826","modified":1711438828116},{"_id":"themes/keep/layout/_partial/archive-list.ejs","hash":"18f56857079abc6c381099c02cfe4971cf8d1976","modified":1711438828118},{"_id":"themes/keep/.github/ISSUE_TEMPLATE/feature-request.yml","hash":"bc3ff5c3007a67c8cb46859fa4500aaa3380e933","modified":1711438828116},{"_id":"themes/keep/layout/post-content.ejs","hash":"d6670383abdc3cdeaa2f4a8e90145698e2a0b691","modified":1711438828122},{"_id":"themes/keep/.github/workflows/release.yml","hash":"9eec7ec60c3a4efdb8b2703896728318fc8c439b","modified":1711438828116},{"_id":"themes/keep/layout/_partial/first-screen.ejs","hash":"e8bc63ed8dd3600efa29c5a3f3b3c31df55b8ded","modified":1711438828119},{"_id":"themes/keep/layout/_partial/head.ejs","hash":"2c70c748c6bd5d16869c4b70cc0122cb6ee3af78","modified":1711438828120},{"_id":"themes/keep/layout/_partial/footer.ejs","hash":"a91692bab3e9862e9b4ccf9d3f8ed43f928c1f38","modified":1711438828120},{"_id":"themes/keep/layout/_partial/local-search.ejs","hash":"18207b298e413fc6b89efc07aa63e8c95a06e56c","modified":1711438828120},{"_id":"themes/keep/layout/_partial/paginator.ejs","hash":"c7de89669e7269db469bfd4a56b7c4d8665f56af","modified":1711438828120},{"_id":"themes/keep/layout/_partial/progress-bar.ejs","hash":"0cda69a94f292073d13c36f409680b40527b9db0","modified":1711438828121},{"_id":"themes/keep/layout/_partial/header.ejs","hash":"ad8cf219fd52bbd70cee4a13911617b728a9a029","modified":1711438828120},{"_id":"themes/keep/layout/_partial/image-mask.ejs","hash":"e785b4ca258ce378354216038ef544ca6ef4af51","modified":1711438828120},{"_id":"themes/keep/layout/_partial/side-tools.ejs","hash":"651ccbe18ffda177dc8b0185edaf45492de984a3","modified":1711438828121},{"_id":"themes/keep/layout/_partial/scripts.ejs","hash":"d9d9dd8710e3d727989fbe0af5c50c7d514888e9","modified":1711438828121},{"_id":"themes/keep/layout/_template/page-template.ejs","hash":"036fc099bf727b2bd67f03da668475e80c7d7c06","modified":1711438828121},{"_id":"themes/keep/layout/_partial/toc.ejs","hash":"d7a15f2967400afb4447a0c93fea6b8008bfa4f6","modified":1711438828121},{"_id":"themes/keep/layout/_template/photo-album.ejs","hash":"96b31a81c52f1132a77578ca49a1ea2fbae3f30a","modified":1711438828121},{"_id":"themes/keep/layout/_template/tools-nav.ejs","hash":"a008bf7aff8e125f3b771be20ce732aca9f91d28","modified":1711438828121},{"_id":"themes/keep/layout/_template/friends-link.ejs","hash":"6c3eefaf9d23daeeb79c8a7458550e446015dd03","modified":1711438828121},{"_id":"themes/keep/scripts/events/404-page.js","hash":"ce2800bf5bb51cb0e1b97a3197bbea22086ce95f","modified":1711438828122},{"_id":"themes/keep/scripts/events/config-handle.js","hash":"1e700776ee8f90757e0659985d36204452c39537","modified":1711438828123},{"_id":"themes/keep/scripts/filters/link-handle.js","hash":"e6fa7d7d20876710d7e6f035d5c4cd69e6d55f6f","modified":1711438828123},{"_id":"themes/keep/layout/_partial/tagcloud.ejs","hash":"88653147fc2e1a589ad26d71b2a613c21762458a","modified":1711438828121},{"_id":"themes/keep/scripts/helpers/export-config.js","hash":"68aeda9fbd77dfe6ba4844c9a1c14f6ed6179304","modified":1711438828123},{"_id":"themes/keep/scripts/filters/image-handle.js","hash":"a701a8c3efde5daea801ff464e86ceda6e2e79bd","modified":1711438828123},{"_id":"themes/keep/scripts/tags/button.js","hash":"469d602b7e6f628f39accdc01995f7d53183c6b2","modified":1711438828123},{"_id":"themes/keep/scripts/events/keep-info.js","hash":"3661991ef2e3f94d01eec041d84de615a01c2ede","modified":1711438828123},{"_id":"themes/keep/scripts/helpers/helper.js","hash":"37f00e01e35f3bdedc95b0169d251fbf6f5f1c43","modified":1711438828123},{"_id":"themes/keep/scripts/tags/tabs.js","hash":"febba0de7b1ee2ce8d08bcdb591cf1c8f8ee1256","modified":1711438828123},{"_id":"themes/keep/source/css/style.styl","hash":"2061f303a5cdc671f7d3ee605b226cc5220dc4e3","modified":1711438828128},{"_id":"themes/keep/scripts/tags/index.js","hash":"253cd55481e683bdb8befdfe286cd65fb438d383","modified":1711438828123},{"_id":"themes/keep/scripts/tags/note.js","hash":"8fff007ae56c5e719f984cbaf94eb643caf1c900","modified":1711438828123},{"_id":"themes/keep/source/js/back2top.js","hash":"a20b7f4664eb0c5efaf027edb7b922e9e2ee5d79","modified":1711438828135},{"_id":"themes/keep/source/js/code-block.js","hash":"75cd51b3584e95b5767d6a699593941e6c567c7e","modified":1711438828135},{"_id":"themes/keep/source/js/header-shrink.js","hash":"558cd139a503b18dcccf9a72eab157d1b0e1e1f1","modified":1711438828135},{"_id":"themes/keep/source/images/logo.svg","hash":"b618728f9964a5698b1dc2548db35b3d06dd115f","modified":1711438828135},{"_id":"themes/keep/source/images/avatar.svg","hash":"aba8367cd7550e75279f707671d7146813c2a776","modified":1711438828134},{"_id":"themes/keep/source/images/bg.svg","hash":"7dfc551927ce3a789d8f4a62c59d600f2446aed5","modified":1711438828134},{"_id":"themes/keep/source/js/toggle-theme.js","hash":"adc7429ee7d5689174fcd03ac8ec00cd81f2262d","modified":1711438828136},{"_id":"themes/keep/source/js/utils.js","hash":"131e962b16e2b5165beb7dbf4dea1ba6105b940c","modified":1711438828137},{"_id":"themes/keep/source/images/bg2.svg","hash":"f12bbb821857d4e41ec253f4d8025ca7e4afce3b","modified":1711438828134},{"_id":"themes/keep/source/js/lazyload.js","hash":"4852b9075ea8350eed2332cea1fe3fafea6963eb","modified":1711438828135},{"_id":"themes/keep/layout/_partial/comment/config-error.ejs","hash":"5c791249d3d92310b11df74c890943914ad69c1d","modified":1711438828118},{"_id":"themes/keep/source/js/main.js","hash":"35b00505658f85c28d65d4825c1b5a8a3cb1caf9","modified":1711438828136},{"_id":"themes/keep/layout/_partial/common/empty-content.ejs","hash":"78402dfaf5f2ab9462b31039551ca0b5a991485f","modified":1711438828119},{"_id":"themes/keep/layout/_partial/comment/load-handler.ejs","hash":"f2603354acc2f8e2db1342a2b5394ffebb04e962","modified":1711438828118},{"_id":"themes/keep/layout/_partial/comment/comment.ejs","hash":"91cce42038c5c88c3cdcf53df275d56ed0928b84","modified":1711438828118},{"_id":"themes/keep/layout/_partial/pjax/pjax.ejs","hash":"8d72e959001413d3c7d3721cf44111757982a3de","modified":1711438828120},{"_id":"themes/keep/layout/_partial/common/mermaid.ejs","hash":"05b0dbdc2e28d9c8b342829debf112bea3ee2b68","modified":1711438828119},{"_id":"themes/keep/layout/_partial/post/post-copyright-info.ejs","hash":"1fd9588d7e3970c7f5157faa077e1641a9adcab3","modified":1711438828120},{"_id":"themes/keep/source/js/local-search.js","hash":"4962807fa7f450f37c16b633fab34653b3238384","modified":1711438828136},{"_id":"themes/keep/layout/_partial/post/post-tools.ejs","hash":"f650e6c668da8a93a8e87b3dd74da9cd5345253f","modified":1711438828121},{"_id":"themes/keep/layout/_partial/post/post-share.ejs","hash":"2602390e3f35117b1c2dd73edfc5764dbe94dde4","modified":1711438828120},{"_id":"themes/keep/source/css/common/animated.styl","hash":"d9577cd145aeb11da400f694c18052f59f0f085e","modified":1711438828124},{"_id":"themes/keep/source/css/common/basic.styl","hash":"db3443d71472fea5adaf18e079d953555e33d7f7","modified":1711438828124},{"_id":"themes/keep/source/css/common/keep-style.styl","hash":"e83f4cb3c4d578b9e139f6bc10a7c9af829a02dd","modified":1711438828124},{"_id":"themes/keep/source/css/common/markdown.styl","hash":"91435b01a87bd322447737e1deb8aa0d3d1030b5","modified":1711438828125},{"_id":"themes/keep/source/css/common/css-variables.styl","hash":"108084b2f91536a34f45254b15a9f6df957292c7","modified":1711438828124},{"_id":"themes/keep/source/css/common/stylus-variables.styl","hash":"a5c02d09bccf5decd02299a5ce0e2210e1d9f3f9","modified":1711438828125},{"_id":"themes/keep/source/css/layout/archive-content.styl","hash":"52cdeff06fdbd298050e048589d51831648126bb","modified":1711438828127},{"_id":"themes/keep/source/css/layout/category-list.styl","hash":"d87a312eb9dfe452ce3fb5caa8882c20c5b2587d","modified":1711438828127},{"_id":"themes/keep/source/css/layout/home-content.styl","hash":"5c1b7d65520c7f67ee58c644f5ca2994d3ef8cd4","modified":1711438828128},{"_id":"themes/keep/source/css/layout/page.styl","hash":"0e35ba200cd1fdf968672e710decc557f5893392","modified":1711438828128},{"_id":"themes/keep/source/css/layout/post-content.styl","hash":"0ff7c42e1ff8cf5db689c20be8dbb6d7aaabd06a","modified":1711438828128},{"_id":"themes/keep/source/css/layout/category-content.styl","hash":"70c967782c1458bf90fd58382b69f3500bb7b91a","modified":1711438828127},{"_id":"themes/keep/source/css/layout/404.styl","hash":"a912c3cafd8f4ec892094b47aa110f08e8ebb1c0","modified":1711438828125},{"_id":"themes/keep/source/css/layout/tag-content.styl","hash":"e8d466e64b89b87b109e76549632f0bb5200179f","modified":1711438828128},{"_id":"themes/keep/layout/_partial/post/reward-author.ejs","hash":"d9d2fcb0f7ac658ec5e9327a6082e234e4574e87","modified":1711438828121},{"_id":"themes/keep/source/images/deploy-provider/aliyun.png","hash":"4a4464a8a66adb9ecddf2084087dd652690942d5","modified":1711438828134},{"_id":"themes/keep/source/images/deploy-provider/tencent_cloud.png","hash":"be5357326af6c68b7c109fe5d4f92ada5daec900","modified":1711438828135},{"_id":"themes/keep/source/images/deploy-provider/netlify.png","hash":"894e9d227c3ebe1ca05d431c74b61c716eaf4e4d","modified":1711438828135},{"_id":"themes/keep/source/images/deploy-provider/github.png","hash":"fa9ed69cd0a004f3cd334d098b8fea5ae2ac3835","modified":1711438828134},{"_id":"themes/keep/source/images/deploy-provider/upyun.png","hash":"923dafcc484388f2a1c20356e37eaf62b85479f4","modified":1711438828135},{"_id":"themes/keep/source/font/css/regular.min.css","hash":"7d1c0737e27ee4c129fe5b74204c0b588dc4091c","modified":1711438828129},{"_id":"themes/keep/layout/_partial/post/post-meta-info.ejs","hash":"fac9c68bcf5ea3029c65a199392717fa6cfb8bcf","modified":1711438828120},{"_id":"themes/keep/source/images/deploy-provider/gitee.png","hash":"d4c79d132c914bf28386df102e7c3f0607c95369","modified":1711438828134},{"_id":"themes/keep/source/font/css/brands.min.css","hash":"75e0c506eff6c93d4d3311b300d251c48236b714","modified":1711438828128},{"_id":"themes/keep/source/font/css/solid.min.css","hash":"65f70e8978fb1db423c007310387573b635498aa","modified":1711438828129},{"_id":"themes/keep/source/images/deploy-provider/vercel.png","hash":"2b0538b5cd09f71f06f5968a6cd0ae910a96f4ca","modified":1711438828135},{"_id":"themes/keep/source/font/webfonts/fa-regular-400.ttf","hash":"2d7890e12afb77490112ec57fe47ca0688aebda2","modified":1711438828130},{"_id":"themes/keep/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1711438828135},{"_id":"themes/keep/source/font/webfonts/fa-regular-400.woff2","hash":"07fc0ae14bb3187839082aed3bca11dfb1e04524","modified":1711438828130},{"_id":"themes/keep/source/js/page/photos-page.js","hash":"a1a52f415f3abca4d5a34b01df4f540f84d95009","modified":1711438828136},{"_id":"themes/keep/source/js/page/category-page.js","hash":"95c642a02e3409984609cc93219ab05dbc16765f","modified":1711438828136},{"_id":"themes/keep/source/font/webfonts/fa-v4compatibility.ttf","hash":"321d89c65f1746f111341556bc62c7e217ad2544","modified":1711438828134},{"_id":"themes/keep/source/js/page/links-page.js","hash":"41c09beee46a5dd58387154841e5766e581b27ec","modified":1711438828136},{"_id":"themes/keep/source/js/post/copyright-info.js","hash":"fe9dee9201455c1c2a98b171046bf59ba4d7af5e","modified":1711438828136},{"_id":"themes/keep/source/font/webfonts/fa-v4compatibility.woff2","hash":"35794892fa2b4aede41ec686df49a1283ab2b2b3","modified":1711438828134},{"_id":"themes/keep/source/js/page/tools-page.js","hash":"63e42083320dbee93053c31a4277d0b043d633fe","modified":1711438828136},{"_id":"themes/keep/layout/_partial/comment/plugins/disqus.ejs","hash":"e3ea930a445a331ed327a3e4dc41ee5ce9edeb37","modified":1711438828119},{"_id":"themes/keep/source/js/libs/pjax.min.js","hash":"57ec40cb4898d7ba74a03603d608af378e5431f8","modified":1711438828135},{"_id":"themes/keep/source/js/post/post-helper.js","hash":"f03dd865eb100528278123f46a352d8a1489c43a","modified":1711438828136},{"_id":"themes/keep/source/js/post/toc.js","hash":"e539d6aa92b146a323597b3fa428565972e10be8","modified":1711438828136},{"_id":"themes/keep/source/js/post/share.js","hash":"7ea60518e86c3b15f164592b4600c61033b8bc4a","modified":1711438828136},{"_id":"themes/keep/layout/_partial/comment/plugins/twikoo.ejs","hash":"06087f1ce865dac2a52663ac2a52ef6302206fc3","modified":1711438828119},{"_id":"themes/keep/layout/_partial/comment/plugins/artalk.ejs","hash":"1788724a817d8362958c381feee0418277b3f8da","modified":1711438828119},{"_id":"themes/keep/layout/_partial/comment/plugins/valine.ejs","hash":"3cf7eb50d3dd60200cca0d21493b1b78e681f28c","modified":1711438828119},{"_id":"themes/keep/layout/_partial/comment/plugins/giscus.ejs","hash":"76d193eea7c0ee2e9cdf11fd8018f2033baaf708","modified":1711438828119},{"_id":"themes/keep/layout/_partial/comment/plugins/gitalk.ejs","hash":"36602f1864d21963a7896c4e04ade0a5ccf3b303","modified":1711438828119},{"_id":"themes/keep/source/css/common/code-block/highlight.styl","hash":"88b888972ea4dba1b85256ab910c7356fc23be5c","modified":1711438828124},{"_id":"themes/keep/source/css/common/tags/keep-note.styl","hash":"2283cd5399ef56023c31ac5555a9f4305b9fcf52","modified":1711438828125},{"_id":"themes/keep/layout/_partial/comment/plugins/waline.ejs","hash":"1e03da5ea980f64c60fcd8327e44b7e77b6df351","modified":1711438828119},{"_id":"themes/keep/source/css/common/tags/keep-button.styl","hash":"69254a234d544f4a92670885e611fcc0081f7194","modified":1711438828125},{"_id":"themes/keep/source/css/common/tags/keep-tabs.styl","hash":"57bf54ad854b4fdc775a5dd7cb03bcdfd98f0f5c","modified":1711438828125},{"_id":"themes/keep/source/css/layout/_partial/archive-list.styl","hash":"f0b4eb8466b8a32616f3c88c70c33ed37dd22aa6","modified":1711438828125},{"_id":"themes/keep/source/css/layout/_partial/first-screen.styl","hash":"d51eb829ce96c78b4cb154c218a207b685c78806","modified":1711438828126},{"_id":"themes/keep/source/css/common/code-block/code-block.styl","hash":"e05ea3623133fa09ad351f88ae5e98f69ddd118f","modified":1711438828124},{"_id":"themes/keep/source/css/common/code-block/code-theme.styl","hash":"16012cb7e7c5f6ac79d326b5f10bea8e896d5d54","modified":1711438828124},{"_id":"themes/keep/source/css/layout/_partial/header.styl","hash":"b83b0245db40405d6c363e5073f1a3abc2ce509a","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/footer.styl","hash":"a03f740e21010fc90f6a76105a6226ccd896979e","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/image-mask.styl","hash":"d3fb3d4beb0e8f3558d3010b7d28298600c2ae8f","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/paginator.styl","hash":"39157df0bd402d36438b2ced1ba2eb158e1f841e","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/local-search.styl","hash":"ba965eb5230054feab9aad37c7668daf10281e3f","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/post-meta-info.styl","hash":"7ab3d8452b223250b360317387088c6bc7c3e23d","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/tagcloud.styl","hash":"1a2285e38541f9adb4fdf32b449bd0c1607aa4d0","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/toc.styl","hash":"ad59e157e3e0abc6ac916e411b2ad94777fccb18","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_template/friends-link.styl","hash":"13e1db4b8a8962133fb9c2184f2f9b38633a108e","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/progress-bar.styl","hash":"5a0ae1b59de2c95b11cfa8fca57601f6da9bc16c","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_template/page-template.styl","hash":"e2497053252b18c9efc188472af4361953db116a","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_template/photo-album.styl","hash":"de3f8beba4c28db9dd008a660fcaab98c5164ce8","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/side-tools.styl","hash":"0b3f0e7f6ecf8c9f215886cb46ea0cc0f3c62470","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/comment/comment.styl","hash":"ce846f38381005dd603a4baf139b337a25e4ea57","modified":1711438828125},{"_id":"themes/keep/source/css/layout/_template/tools-nav.styl","hash":"6315917a2df03e3df48dff311a09ac672945c80a","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/comment/waline.styl","hash":"fbf5ad7dd60f044cb12265dd33222da40777d43b","modified":1711438828125},{"_id":"themes/keep/source/css/layout/_partial/post/post-share.styl","hash":"e67474486d9c8e9fd65ec51f1b97abf0e0e619c6","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/common/empty-content.styl","hash":"c9dbd9242f3a4251018e42de0026c410808f3f49","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/post/post-tools.styl","hash":"201e9cef3bd60b4d26203fa478032a9b15cd7dee","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/post/reward-author.styl","hash":"eed4fd19c4f73634335db0b9620a1524e98652bf","modified":1711438828127},{"_id":"themes/keep/source/css/layout/_partial/post/post-copyright-info.styl","hash":"72d8d8daa0542f3fd8e23a4e8df22e9f9c895f9a","modified":1711438828126},{"_id":"themes/keep/source/css/layout/_partial/comment/gitalk.styl","hash":"6344eabedc352463b3ae25e2ee28024c70bd31a2","modified":1711438828125},{"_id":"themes/keep/source/font/css/fontawesome.min.css","hash":"c562501b761480adb1b4db14b6b09981b3510ac8","modified":1711438828129},{"_id":"themes/keep/source/css/layout/_partial/comment/twikoo.styl","hash":"df0b0cf4a778d1e1fbcade3d226ced1a74fdb38f","modified":1711438828125},{"_id":"themes/keep/source/css/layout/_partial/comment/valine.styl","hash":"71ef4b5b22a63d567e48f76ccfaacc79ee40e7bc","modified":1711438828125},{"_id":"themes/keep/source/font/webfonts/fa-brands-400.woff2","hash":"373361ed756b1fe68ce2f5968d467826b6973bb5","modified":1711438828130},{"_id":"themes/keep/source/font/webfonts/fa-solid-900.woff2","hash":"97f0942c6627ddd89fb62170e5cac9a2cbd6c98c","modified":1711438828134},{"_id":"themes/keep/source/font/webfonts/fa-brands-400.ttf","hash":"d8b3568e9d8a1d3c01c85520eb9ca0b49b72815d","modified":1711438828129},{"_id":"themes/keep/source/images/robotDog.jpg","hash":"31f4069b126ec7f8e0aea1016b6772e255b7724f","modified":1711443626415},{"_id":"themes/keep/source/font/webfonts/fa-solid-900.ttf","hash":"e9ace557c3aa403307f1e7a2cef1c035d522b94b","modified":1711438828131},{"_id":"public/atom.xml","hash":"1b63ca4cea873b3520bed073be49131f555f735d","modified":1716346521343},{"_id":"public/search.json","hash":"9d75fc1481e9b301c6d256f7412bc0aac7aef100","modified":1716346521343},{"_id":"public/about/index.html","hash":"b2d1b044f429f5050e219bee4fd1db0372243590","modified":1716346521343},{"_id":"public/links/index.html","hash":"0586b430ec642badcd6c244ce62f36eb42938aeb","modified":1716346521343},{"_id":"public/2024/05/13/重新出发/index.html","hash":"aa913f6b3effbe0c521323822e2b291f82533ef1","modified":1716346521343},{"_id":"public/2024/03/27/Recoli/index.html","hash":"0828dc74d0623041ae5ef4203ceaab39dd328187","modified":1716346521343},{"_id":"public/2024/03/26/GameFi/index.html","hash":"cd560bf23c7b842e3ebcb6da8cf4c578aba54c41","modified":1716346521343},{"_id":"public/2024/03/26/farm/index.html","hash":"7bc4a911b9154a67cae0a86e05218a504da1225a","modified":1716346521343},{"_id":"public/archives/index.html","hash":"d906ee32838a27a0650c6a9bd57e51e995d8d465","modified":1716346521343},{"_id":"public/archives/page/2/index.html","hash":"0dd3bb8059b7a3784019087ad51874c8a0d733b1","modified":1716346521343},{"_id":"public/archives/2024/index.html","hash":"382eca9b578ee32cdca242e24d0c4faa601a64f5","modified":1716346521343},{"_id":"public/archives/2024/page/2/index.html","hash":"907dbaf408569175b6a9a07e5c351a9658851baf","modified":1716346521343},{"_id":"public/archives/2024/03/index.html","hash":"8f323519c40af54175c0936feb536aa3137e88a4","modified":1716346521343},{"_id":"public/archives/2024/03/page/2/index.html","hash":"f8e6847924785db6a290d0146028a80b2c70af4b","modified":1716346521343},{"_id":"public/archives/2024/05/index.html","hash":"0b4e3356cefa9347bdc0c64c45e9e97169dded77","modified":1716346521343},{"_id":"public/404.html","hash":"7ad82c4d1fde39e461b41433705a75011295dab8","modified":1716346521343},{"_id":"public/2024/05/22/Contract/index.html","hash":"6457465abad44e1f356bd410e8e4fd69f99988e7","modified":1716346521343},{"_id":"public/2024/05/22/ReactServerComponent/index.html","hash":"2d145d7f3b3cc288c9bdaf61db7d6eba0f371f6e","modified":1716346521343},{"_id":"public/2024/05/19/Element-UI组件解析/index.html","hash":"2e32502aa3a57e82d2c5dfb73dcc8e3b3ac4d22b","modified":1716346521343},{"_id":"public/2024/03/29/聚合器Yearn/index.html","hash":"67a1141aa380d1402f0f08ca37f311dc906c6b7b","modified":1716346521343},{"_id":"public/2024/03/26/前端部署/index.html","hash":"7b693e048ca8ae347a7516855fe9c237e4387ab2","modified":1716346521343},{"_id":"public/2024/03/26/Redux-middleware/index.html","hash":"9828ea9c37e5906292fddd39bdf02ddd99babca2","modified":1716346521343},{"_id":"public/2024/03/26/runners/index.html","hash":"51415d91f4799cdae21b2ed5ecfedd451d5e6c65","modified":1716346521343},{"_id":"public/2024/03/26/smartContract/index.html","hash":"798ba5d82dc37dfd1cf3199feb30b89a14f6e380","modified":1716346521343},{"_id":"public/2024/03/26/token/index.html","hash":"6632eb9e671482d9a9dc87730338f046f8cb1875","modified":1716346521343},{"_id":"public/2024/03/26/DeFi/index.html","hash":"859a23e2e46334a6f7aa8388bd2037bb04772148","modified":1716346521343},{"_id":"public/2024/03/26/oracle/index.html","hash":"6f0d05ebe6d4bededdfad5ef12e5be5e9f7f8350","modified":1716346521343},{"_id":"public/2024/03/26/wallet/index.html","hash":"ae652be3167b513801170a55a35e6f879b2dd3bc","modified":1716346521343},{"_id":"public/index.html","hash":"9f0d3ba14e450a0e63cb4e8ee7b112dd30d9fc4c","modified":1716346521343},{"_id":"public/page/2/index.html","hash":"86386b5081af5c6be60b9fb3fd504e3b22ae3069","modified":1716346521343},{"_id":"public/images/avatar.svg","hash":"aba8367cd7550e75279f707671d7146813c2a776","modified":1716346521343},{"_id":"public/images/bg2.svg","hash":"f12bbb821857d4e41ec253f4d8025ca7e4afce3b","modified":1716346521343},{"_id":"public/images/logo.svg","hash":"b618728f9964a5698b1dc2548db35b3d06dd115f","modified":1716346521343},{"_id":"public/images/deploy-provider/aliyun.png","hash":"4a4464a8a66adb9ecddf2084087dd652690942d5","modified":1716346521343},{"_id":"public/images/deploy-provider/gitee.png","hash":"d4c79d132c914bf28386df102e7c3f0607c95369","modified":1716346521343},{"_id":"public/images/deploy-provider/github.png","hash":"fa9ed69cd0a004f3cd334d098b8fea5ae2ac3835","modified":1716346521343},{"_id":"public/images/deploy-provider/netlify.png","hash":"894e9d227c3ebe1ca05d431c74b61c716eaf4e4d","modified":1716346521343},{"_id":"public/images/deploy-provider/tencent_cloud.png","hash":"be5357326af6c68b7c109fe5d4f92ada5daec900","modified":1716346521343},{"_id":"public/images/deploy-provider/upyun.png","hash":"923dafcc484388f2a1c20356e37eaf62b85479f4","modified":1716346521343},{"_id":"public/images/deploy-provider/vercel.png","hash":"2b0538b5cd09f71f06f5968a6cd0ae910a96f4ca","modified":1716346521343},{"_id":"public/font/webfonts/fa-regular-400.ttf","hash":"2d7890e12afb77490112ec57fe47ca0688aebda2","modified":1716346521343},{"_id":"public/font/webfonts/fa-regular-400.woff2","hash":"07fc0ae14bb3187839082aed3bca11dfb1e04524","modified":1716346521343},{"_id":"public/font/webfonts/fa-v4compatibility.woff2","hash":"35794892fa2b4aede41ec686df49a1283ab2b2b3","modified":1716346521343},{"_id":"public/font/webfonts/fa-v4compatibility.ttf","hash":"321d89c65f1746f111341556bc62c7e217ad2544","modified":1716346521343},{"_id":"public/images/bg.svg","hash":"7dfc551927ce3a789d8f4a62c59d600f2446aed5","modified":1716346521343},{"_id":"public/font/webfonts/fa-brands-400.woff2","hash":"373361ed756b1fe68ce2f5968d467826b6973bb5","modified":1716346521343},{"_id":"public/js/back2top.js","hash":"a20b7f4664eb0c5efaf027edb7b922e9e2ee5d79","modified":1716346521343},{"_id":"public/js/header-shrink.js","hash":"558cd139a503b18dcccf9a72eab157d1b0e1e1f1","modified":1716346521343},{"_id":"public/js/code-block.js","hash":"75cd51b3584e95b5767d6a699593941e6c567c7e","modified":1716346521343},{"_id":"public/js/lazyload.js","hash":"4852b9075ea8350eed2332cea1fe3fafea6963eb","modified":1716346521343},{"_id":"public/js/local-search.js","hash":"4962807fa7f450f37c16b633fab34653b3238384","modified":1716346521343},{"_id":"public/js/toggle-theme.js","hash":"adc7429ee7d5689174fcd03ac8ec00cd81f2262d","modified":1716346521343},{"_id":"public/js/main.js","hash":"35b00505658f85c28d65d4825c1b5a8a3cb1caf9","modified":1716346521343},{"_id":"public/css/common/animated.css","hash":"d3966d2c19b5d004e361bae598298311956352ab","modified":1716346521343},{"_id":"public/css/common/css-variables.css","hash":"c18a7ef81cd60b9f7863f57cddec2833c0f1cee4","modified":1716346521343},{"_id":"public/css/common/keep-style.css","hash":"2ecbdec66e7efed5ebcea1a2ce087cffe121d93a","modified":1716346521343},{"_id":"public/css/common/markdown.css","hash":"f9ed0115a291e90ef4b0cf248ce675c7d99436c9","modified":1716346521343},{"_id":"public/css/common/stylus-variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716346521343},{"_id":"public/css/layout/404.css","hash":"fc65d6a0c801be462bde63b6091d659ed7c213e6","modified":1716346521343},{"_id":"public/css/layout/archive-content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1716346521343},{"_id":"public/css/layout/category-content.css","hash":"87d3049e0b5cf22b204a6e1522ab3f686acbebe2","modified":1716346521343},{"_id":"public/css/layout/category-list.css","hash":"800b3e4fe0a256fd7f47ec07aeebaab65a5641b5","modified":1716346521343},{"_id":"public/css/layout/home-content.css","hash":"0f55c11ca16457b253635b86f4565f65f7e25ab1","modified":1716346521343},{"_id":"public/css/layout/post-content.css","hash":"41191f144f0976c94e20ba3481c76319b18b033a","modified":1716346521343},{"_id":"public/css/layout/page.css","hash":"09daaa9c341a31332f7b747dd238e359aaa8c824","modified":1716346521343},{"_id":"public/css/layout/tag-content.css","hash":"2f3743f184cdb4c1b423121bd23201e1726a97d0","modified":1716346521343},{"_id":"public/font/css/solid.min.css","hash":"65f70e8978fb1db423c007310387573b635498aa","modified":1716346521343},{"_id":"public/font/css/regular.min.css","hash":"7d1c0737e27ee4c129fe5b74204c0b588dc4091c","modified":1716346521343},{"_id":"public/js/page/category-page.js","hash":"95c642a02e3409984609cc93219ab05dbc16765f","modified":1716346521343},{"_id":"public/js/page/photos-page.js","hash":"a1a52f415f3abca4d5a34b01df4f540f84d95009","modified":1716346521343},{"_id":"public/js/page/links-page.js","hash":"41c09beee46a5dd58387154841e5766e581b27ec","modified":1716346521343},{"_id":"public/js/page/tools-page.js","hash":"63e42083320dbee93053c31a4277d0b043d633fe","modified":1716346521343},{"_id":"public/js/post/copyright-info.js","hash":"fe9dee9201455c1c2a98b171046bf59ba4d7af5e","modified":1716346521343},{"_id":"public/js/post/post-helper.js","hash":"f03dd865eb100528278123f46a352d8a1489c43a","modified":1716346521343},{"_id":"public/js/post/share.js","hash":"7ea60518e86c3b15f164592b4600c61033b8bc4a","modified":1716346521343},{"_id":"public/js/post/toc.js","hash":"e539d6aa92b146a323597b3fa428565972e10be8","modified":1716346521343},{"_id":"public/css/common/code-block/code-block.css","hash":"6f56de30ae6fcdb0c7998d815f8f443cf1752199","modified":1716346521343},{"_id":"public/css/common/code-block/highlight.css","hash":"72743af4aab05c0e7fad1965bfa573ca659d0590","modified":1716346521343},{"_id":"public/css/common/tags/keep-button.css","hash":"17bd98d7daad3ddaf5e0ea44e16007548b49305b","modified":1716346521343},{"_id":"public/css/common/tags/keep-note.css","hash":"483632c7c234da5fd88ecb943be54455b3f1644b","modified":1716346521343},{"_id":"public/css/common/tags/keep-tabs.css","hash":"795cb5e2bf4e25f079303aaf9044fc50a8f8b8d5","modified":1716346521343},{"_id":"public/css/common/code-block/code-theme.css","hash":"929728e96f4224fbb2561dcdae818eaa352aea9f","modified":1716346521343},{"_id":"public/css/style.css","hash":"d847ad19c93efc909a9a37cd926ef076ba913310","modified":1716346521343},{"_id":"public/js/utils.js","hash":"131e962b16e2b5165beb7dbf4dea1ba6105b940c","modified":1716346521343},{"_id":"public/css/common/basic.css","hash":"40fbb61753617631d255258169d799029903efe7","modified":1716346521343},{"_id":"public/font/css/brands.min.css","hash":"75e0c506eff6c93d4d3311b300d251c48236b714","modified":1716346521343},{"_id":"public/font/css/fontawesome.min.css","hash":"c562501b761480adb1b4db14b6b09981b3510ac8","modified":1716346521343},{"_id":"public/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1716346521343},{"_id":"public/js/libs/pjax.min.js","hash":"57ec40cb4898d7ba74a03603d608af378e5431f8","modified":1716346521343},{"_id":"public/font/webfonts/fa-brands-400.ttf","hash":"d8b3568e9d8a1d3c01c85520eb9ca0b49b72815d","modified":1716346521343},{"_id":"public/font/webfonts/fa-solid-900.woff2","hash":"97f0942c6627ddd89fb62170e5cac9a2cbd6c98c","modified":1716346521343},{"_id":"public/assets/secret.png","hash":"272cbc81b60a084f6314116c6ea3ab630f0a6ae8","modified":1716346521343},{"_id":"public/assets/name.png","hash":"3cb8ee9cabbc499f35b5351b20966c0e65c1a38d","modified":1716346521343},{"_id":"public/images/robotDog.jpg","hash":"31f4069b126ec7f8e0aea1016b6772e255b7724f","modified":1716346521343},{"_id":"public/font/webfonts/fa-solid-900.ttf","hash":"e9ace557c3aa403307f1e7a2cef1c035d522b94b","modified":1716346521343},{"_id":"source/_posts/LiquidityFarm.md","hash":"b8579603c73f95245648f75c8ef3fd891655de6d","modified":1716346704718}],"Category":[],"Data":[{"_id":"links","data":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}],"Page":[{"title":"about","date":"2022-02-21T06:46:06.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-02-21 14:46:06\n---\n","updated":"2024-03-26T07:13:35.915Z","path":"about/index.html","comments":1,"layout":"page","_id":"clwh8ejrn00003jf0ahg45fc1","content":"","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":""},{"title":"links","date":"2022-02-21T06:46:16.000Z","_content":"","source":"links/index.md","raw":"---\ntitle: links\ndate: 2022-02-21 14:46:16\n---\n","updated":"2024-03-26T07:13:35.917Z","path":"links/index.html","comments":1,"layout":"page","_id":"clwh8ejrp00023jf008f2ci4u","content":"","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":""}],"Post":[{"title":"永续合约","_content":"\n永续合约已经成为了加密货币交易量最大的交易方式，但永续合约是一个币圈独创的产品，与平时接触的普通金融衍生品不同，币圈永续合约的设计理解起来有点困难，甚至很多人虽然经常用永续合约，但依然不知道各种指标是什么意思。\n\n很多人爆仓，是因为不能理解币圈永续合约的本质。\n\n### 永续合约的全称，叫做「期货永续合约」\n\n三个关键词：期货，永续，合约\n\n期货：相较于现货而言，在现货交易中，双方直接一手交钱一手交货，而在期货交易中，约定了在将来某个时间以某个价格交易商品，举个例子，A 和 B 约定，在两个月后，A 以 200 元/斤的价格卖 100 斤大米给 B，双方签订了合同，则 A 是合约的卖方，B 是合约的买方，这个交易的过程，就是以期货的交易形式的合约，期，即未来的时间的意思，和现货对应\n\n在这个过程中，如果 A 和 B 的双方的某一方不想要按照原来的约定买大米了，那么，他们签订的这份合同可以卖给别人，如果是 B 卖的，那么 B 就变成了合同的卖方，期货合约都是有到期期限的，在最后时间是一定要交割的，到了`交割日`，买卖双方会强制按照当初的约定进行交割，这个中合约也叫做`期货交割合约`\n\n为了让合约购买的双方，在合约的到期日都能遵循约定进行交割，双方都需要缴纳一定的资金，这个就叫`保证金`。\n\n在交易所中，假设当前 BTC 的价格为 2W 美金，而 A 觉得，到了下个星期，BTC 能涨到 2.5w 美金，那么 A 就会买入看涨合约，同时要缴纳一定的保证金，（这个保证金的缴纳需要看当时买入的合约本位是什么），这份看涨合约代表：下个星期，A 有权利以 2w 美金的价格买入 BTC，而合约市场（期市）是需要对手盘的，也就是交易对手才能成交，假设对手是 B，B 觉得下个星期 BTC 会跌，所以 B 想在下个星期以 2w 美金的价格卖出 BTC，对于 A 来说是先低买高卖，对于 B 来说是先高借后低还。\n\n到了下个星期，如果 BTC 的价格跌到了 1.8w 美金，那么 A 亏损，B 盈利\n\n以上的例子讲的期货合约，最后都要交割，称之为`交割合约`，还有一种没有交割时间的合约，就是`期货永续合约`，永续合约分为两种，`正向合约`和`反向合约`\n\n正向合约很好理解，跟踪的交易标的是 BTC，以 USDT 计价，保证金也是 USDT\n\n反向合约的跟踪标的和计价都和正向合约一样，但是以 BTC 为保证金，这个就是`X本位合约`的意思，\n\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 举例：`U本位`就是正向合约，`币本位`就是反向合约\n\n</aside>\n\n从交易体验来说，正向合约使用 USDT 一种币种作为保证金，可以开多币种的合约，确实是更灵活，更适合新手使用，合约的单位是张，但一张正向合约和一张反向合约所代表的面值分别是多少呢？一张 BTC 合约的面试通常是需要提前约定，不一样的地方在于，正向合约一张合约面值按 BTC 数量算（价值多少个 BTC），而反向合约是按 USDT 数量（价值多少 USDT），比方说可以假设\n\n| 合约类型              | 合约面值 |\n| --------------------- | -------- |\n| 一张正向 BTC 合约面值 | 0.1BTC   |\n| 一张反向 BTC 合约面值 | 100USDT  |\n\n以上说明什么呢，正向合约需要拥有币种标的如：BTC，反向合约是按 USDT 计价的，只需要拥有 USDT 即可，这也是反向合约入场门槛低的原因，其次也和看涨看跌合约有关，一般，如果是看涨合约，那么就买正向合约，如果盈利的话则是币值涨 + 合约收益\n\n## 保证金\n\n保证金是开仓是需要缴纳的资金，正向何雨两者保证金计算如下：\n\n正向合约的仓位价值 = 合约面值 _ 合约张数 _ 标记价格\n\n正向合约的仓位价值 = 杠杆倍数 \\* 保证金数量\n\n$$\n合约价值*合约张数*标记价格 = 杠杆倍数 * 保证金数量\n$$\n\n以上的公式可以看出，杠杆倍数越高，保证金数量不变的情况下，能开的张数越多，如果盈利，收益越高，如果亏损，保证金数量需要追加的数量越大。\n\n举个例子：在 BTC 价格是 2w 美金的时候，买 5 张 BTC 正向合约，以 2 倍杠杆买入，则保证金：\n\n$$\n保证金=0.1*20000*5/2=5000 USDT\n$$\n\n0.1 是合约面值，20000 标记价格，5 为合约张数，2 位杠杆倍数\n\n反向合约的情况是\n\n反向合约的仓位价值=合约价值\\*合约张数\n\n反向合约的仓位价值=杠杆倍数*保证金数量*标记价格\n\n所以反向合约中：**合约价值*合约张数=杠杆倍数*保证金数量\\*标记价格**\n\n上面的例子中正向合约的仓位价值是 1w 美金，所以在反向合约中我们也买入同样的仓位价值（这在真实的交易市场中是同样的情况）需要买入 100 张合约（假设一张 BTC 反向合约 100USDT，买入 100 张就是 1w 美金），那么保证金是：100*100/（2*20000）= 0.4BTC，而 0.4BTC 的价值就等于 5000USDT\n\n## 盈亏计算\n\n在正向合约中，\n\n做多时：盈亏 = (平仓价-开仓价)*合约面值*合约张数\n\n做空时：盈亏 = (开仓价-平仓价)*合约面值*合约张数\n\n在上面的例子中：在 2w 美金买入 5 张 BTC 合约，并在币价 2.5w 美金时卖出，则盈亏是：\n\n$$\n(2.5w-2w)*0.1*5 = 2500USDT\n$$\n\n在反向合约中\n\n做多时：盈亏 = (1/开仓价 - 1/平仓价)*合约面值*合约张数\n\n做空时：盈亏 = (1/平仓价 - 1/开仓价)*合约面值*合约张数\n\n在上面的例子中：在 2w 美金买入 100 张 BTC 合约，则开仓时仓位价值=100\\*100=1w 美金，并在币价 2.5w 美金时卖出，则这个操作的盈亏是：\n\n$$\n(1/20000-1/25000)*100*100=0.1BTC\n$$\n\n盈亏是 0.1BTC\\*25000 = 2500USDT\n\n也就是反向合约中挣到的 BTC 如果以平仓时价格卖出，则与正向合约挣到的 USDT 相等\n\n正向合约与开仓平仓价差的关系是线性的，但是反向合约不是，反向合约的关系是凸函数的关系\n\n强平的基本原理：`亏损 = 保证金`，就会触发爆仓\n\n在正向合约做多的场景中，开仓时仓位价值=合约面值*张数*开仓价，强平时仓位价值=合约面值*张数*强平价，当仓位损失=（开仓价-强平价）*合约面值*张数=保证金，仓位被强平\n\n已知：合约面值*合约张数*标记价格=杠杆倍数\\*保证金数量\n\n下面的`N`是杠杆倍数，`O`是开仓价格，强平价是`L`，保证金是`M`\n\n即可推导出：强平价=1/杠杆倍数，表明开仓价跌了 1/N 就会触发爆仓\n\n在上面的例子中，开仓价为 2w 美金，2 倍杠杆的情况下，则价格到 1w 美金就爆仓，如果是 50 倍杠杆，则价格到 19600 美金就爆仓\n\n做空的情况也是一样，价格涨了 1/N 就爆仓\n\n再看看反向合约\n\n做多时：开仓时仓位价值=O*N*M，平仓时仓位价值=L*N*M，则亏损=（O-L）*N*M，保证金价值=L*M，所以当（O-L）*N*M=L*M，就会触发强平\n\n上面的公式推导一下，得出：L=O（1-1/N+1），也就是说做多时开仓价跌 1/N+1 就爆仓，\n\n做空时：开仓仓位价值=O*N*M，平仓时仓位价值=L*N*M，亏损=（L-O）*N*M，保证金价值=L*M，所以当（L-O）*N*M=L*M，就触发强平\n\n推导为：L=O（1+1/N-1），就是说做空时开仓涨 1/N-1 就爆仓，2 倍杠杆，即价格涨 50%就会爆仓，如果时 1 倍杠杆，则永不爆仓，得出结论：\n\n**反向合约，一倍做空，永不爆仓**\n\n## 资金费率\n\n资金费率每 8 小时结算一次，分别是 0 点、8 点、16 点\n\n只哟再结算时间持有仓位，才会进行结算\n\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 为什么要有资金费率\n\n</aside>\n\n用于维持合约价格与资产现货价格的平衡的机制，永续合约是没有到期日的金融衍生品，价格理论上会与现货价格保持一致，然而，由于市场波动，市场供需关系变化等因素，永续合约的价格可能会偏离现货价格，因此资金费率就是用来调整永续合约的价格，使其与现货价格保持一致的手段，通过经济刺激的方式影响市场参与者：\n\n正资金费率：当永续合约的价格高于现货价格时，资金费率为正，这意味着多头看涨持仓者需要向空头支付费用，这种机制鼓励更多的市场参与者做空，以期降低永续合约的价格，使其向现货价格靠拢\n\n负资金费率：当永续合约价格低于现货价格的时候，资金费率为负，此时，空头持仓需要向多头持仓者支付费用，这激励更多的市场参与者做多，以提升永续合约的价格。\n\n那么，为什么一定要有这个资金费率呢，不能没有这个机制吗\n\n首先，交易所的目的是鼓励市场参与者参与交易，提高市场效率，没有这个机制，市场的自我调节能力会减弱，而且没有这个机制的话也会导致更多的投机行为，因为交易者可以不受持有成本的影响长期持有头寸，最后，最重要的是，资金费率可以提高市场流动性\n\n## 全仓/逐仓\n\n两种交易模式：\n\n开全仓的情况下，如果 A 账户内有 1w，花了 5k 开 BTC 多单，花了 3K 开了 ETH 多单，账户内留了 2k，如果此时暴跌，那么除了开的多单，账户内的余额（前提是同一币种，不同币种没有讨论价值）也会被自动用来补仓，直到价格回升或者跌倒谷底直接爆仓。因为此时保证金是共享的\n\n开逐仓的情况下：每个保证金是独立的，互相不受影响，只需要手动单独添加保证金\n\n## 做多还是做空\n\n做多不仅仅是合约对赌收益，还有相应的币价上涨带来的收益，理论上收益无上限\n\n做空的收益最高是 100%\\*杠杆倍数，还得要承受币价下跌带来的无常损失\n\n因此做多的收益会高于做空，而且做多也是提振市场信心，做空除了加剧 FOMO，毫无意义\n\n## 期现套利\n\n这是一种吃交易所资金费率的方式，交易者在资金费率为正的时候，同时买入永续合约和相应数量的现货，这样期望从多头支付给空头的资金费率中获利\n\n常见的现货做多，合约做空，获取其中的空头资金费率\n\n跨交易所套利：不同交易所的资金费率不同，因此可以吃掉这个价差\n\n三角套利：多种资产品种进行 swap，最后会出现一个缺口，这个缺口可以作为套利空间\n","source":"_posts/Contract.md","raw":"---\ntitle: 永续合约\n---\n\n永续合约已经成为了加密货币交易量最大的交易方式，但永续合约是一个币圈独创的产品，与平时接触的普通金融衍生品不同，币圈永续合约的设计理解起来有点困难，甚至很多人虽然经常用永续合约，但依然不知道各种指标是什么意思。\n\n很多人爆仓，是因为不能理解币圈永续合约的本质。\n\n### 永续合约的全称，叫做「期货永续合约」\n\n三个关键词：期货，永续，合约\n\n期货：相较于现货而言，在现货交易中，双方直接一手交钱一手交货，而在期货交易中，约定了在将来某个时间以某个价格交易商品，举个例子，A 和 B 约定，在两个月后，A 以 200 元/斤的价格卖 100 斤大米给 B，双方签订了合同，则 A 是合约的卖方，B 是合约的买方，这个交易的过程，就是以期货的交易形式的合约，期，即未来的时间的意思，和现货对应\n\n在这个过程中，如果 A 和 B 的双方的某一方不想要按照原来的约定买大米了，那么，他们签订的这份合同可以卖给别人，如果是 B 卖的，那么 B 就变成了合同的卖方，期货合约都是有到期期限的，在最后时间是一定要交割的，到了`交割日`，买卖双方会强制按照当初的约定进行交割，这个中合约也叫做`期货交割合约`\n\n为了让合约购买的双方，在合约的到期日都能遵循约定进行交割，双方都需要缴纳一定的资金，这个就叫`保证金`。\n\n在交易所中，假设当前 BTC 的价格为 2W 美金，而 A 觉得，到了下个星期，BTC 能涨到 2.5w 美金，那么 A 就会买入看涨合约，同时要缴纳一定的保证金，（这个保证金的缴纳需要看当时买入的合约本位是什么），这份看涨合约代表：下个星期，A 有权利以 2w 美金的价格买入 BTC，而合约市场（期市）是需要对手盘的，也就是交易对手才能成交，假设对手是 B，B 觉得下个星期 BTC 会跌，所以 B 想在下个星期以 2w 美金的价格卖出 BTC，对于 A 来说是先低买高卖，对于 B 来说是先高借后低还。\n\n到了下个星期，如果 BTC 的价格跌到了 1.8w 美金，那么 A 亏损，B 盈利\n\n以上的例子讲的期货合约，最后都要交割，称之为`交割合约`，还有一种没有交割时间的合约，就是`期货永续合约`，永续合约分为两种，`正向合约`和`反向合约`\n\n正向合约很好理解，跟踪的交易标的是 BTC，以 USDT 计价，保证金也是 USDT\n\n反向合约的跟踪标的和计价都和正向合约一样，但是以 BTC 为保证金，这个就是`X本位合约`的意思，\n\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 举例：`U本位`就是正向合约，`币本位`就是反向合约\n\n</aside>\n\n从交易体验来说，正向合约使用 USDT 一种币种作为保证金，可以开多币种的合约，确实是更灵活，更适合新手使用，合约的单位是张，但一张正向合约和一张反向合约所代表的面值分别是多少呢？一张 BTC 合约的面试通常是需要提前约定，不一样的地方在于，正向合约一张合约面值按 BTC 数量算（价值多少个 BTC），而反向合约是按 USDT 数量（价值多少 USDT），比方说可以假设\n\n| 合约类型              | 合约面值 |\n| --------------------- | -------- |\n| 一张正向 BTC 合约面值 | 0.1BTC   |\n| 一张反向 BTC 合约面值 | 100USDT  |\n\n以上说明什么呢，正向合约需要拥有币种标的如：BTC，反向合约是按 USDT 计价的，只需要拥有 USDT 即可，这也是反向合约入场门槛低的原因，其次也和看涨看跌合约有关，一般，如果是看涨合约，那么就买正向合约，如果盈利的话则是币值涨 + 合约收益\n\n## 保证金\n\n保证金是开仓是需要缴纳的资金，正向何雨两者保证金计算如下：\n\n正向合约的仓位价值 = 合约面值 _ 合约张数 _ 标记价格\n\n正向合约的仓位价值 = 杠杆倍数 \\* 保证金数量\n\n$$\n合约价值*合约张数*标记价格 = 杠杆倍数 * 保证金数量\n$$\n\n以上的公式可以看出，杠杆倍数越高，保证金数量不变的情况下，能开的张数越多，如果盈利，收益越高，如果亏损，保证金数量需要追加的数量越大。\n\n举个例子：在 BTC 价格是 2w 美金的时候，买 5 张 BTC 正向合约，以 2 倍杠杆买入，则保证金：\n\n$$\n保证金=0.1*20000*5/2=5000 USDT\n$$\n\n0.1 是合约面值，20000 标记价格，5 为合约张数，2 位杠杆倍数\n\n反向合约的情况是\n\n反向合约的仓位价值=合约价值\\*合约张数\n\n反向合约的仓位价值=杠杆倍数*保证金数量*标记价格\n\n所以反向合约中：**合约价值*合约张数=杠杆倍数*保证金数量\\*标记价格**\n\n上面的例子中正向合约的仓位价值是 1w 美金，所以在反向合约中我们也买入同样的仓位价值（这在真实的交易市场中是同样的情况）需要买入 100 张合约（假设一张 BTC 反向合约 100USDT，买入 100 张就是 1w 美金），那么保证金是：100*100/（2*20000）= 0.4BTC，而 0.4BTC 的价值就等于 5000USDT\n\n## 盈亏计算\n\n在正向合约中，\n\n做多时：盈亏 = (平仓价-开仓价)*合约面值*合约张数\n\n做空时：盈亏 = (开仓价-平仓价)*合约面值*合约张数\n\n在上面的例子中：在 2w 美金买入 5 张 BTC 合约，并在币价 2.5w 美金时卖出，则盈亏是：\n\n$$\n(2.5w-2w)*0.1*5 = 2500USDT\n$$\n\n在反向合约中\n\n做多时：盈亏 = (1/开仓价 - 1/平仓价)*合约面值*合约张数\n\n做空时：盈亏 = (1/平仓价 - 1/开仓价)*合约面值*合约张数\n\n在上面的例子中：在 2w 美金买入 100 张 BTC 合约，则开仓时仓位价值=100\\*100=1w 美金，并在币价 2.5w 美金时卖出，则这个操作的盈亏是：\n\n$$\n(1/20000-1/25000)*100*100=0.1BTC\n$$\n\n盈亏是 0.1BTC\\*25000 = 2500USDT\n\n也就是反向合约中挣到的 BTC 如果以平仓时价格卖出，则与正向合约挣到的 USDT 相等\n\n正向合约与开仓平仓价差的关系是线性的，但是反向合约不是，反向合约的关系是凸函数的关系\n\n强平的基本原理：`亏损 = 保证金`，就会触发爆仓\n\n在正向合约做多的场景中，开仓时仓位价值=合约面值*张数*开仓价，强平时仓位价值=合约面值*张数*强平价，当仓位损失=（开仓价-强平价）*合约面值*张数=保证金，仓位被强平\n\n已知：合约面值*合约张数*标记价格=杠杆倍数\\*保证金数量\n\n下面的`N`是杠杆倍数，`O`是开仓价格，强平价是`L`，保证金是`M`\n\n即可推导出：强平价=1/杠杆倍数，表明开仓价跌了 1/N 就会触发爆仓\n\n在上面的例子中，开仓价为 2w 美金，2 倍杠杆的情况下，则价格到 1w 美金就爆仓，如果是 50 倍杠杆，则价格到 19600 美金就爆仓\n\n做空的情况也是一样，价格涨了 1/N 就爆仓\n\n再看看反向合约\n\n做多时：开仓时仓位价值=O*N*M，平仓时仓位价值=L*N*M，则亏损=（O-L）*N*M，保证金价值=L*M，所以当（O-L）*N*M=L*M，就会触发强平\n\n上面的公式推导一下，得出：L=O（1-1/N+1），也就是说做多时开仓价跌 1/N+1 就爆仓，\n\n做空时：开仓仓位价值=O*N*M，平仓时仓位价值=L*N*M，亏损=（L-O）*N*M，保证金价值=L*M，所以当（L-O）*N*M=L*M，就触发强平\n\n推导为：L=O（1+1/N-1），就是说做空时开仓涨 1/N-1 就爆仓，2 倍杠杆，即价格涨 50%就会爆仓，如果时 1 倍杠杆，则永不爆仓，得出结论：\n\n**反向合约，一倍做空，永不爆仓**\n\n## 资金费率\n\n资金费率每 8 小时结算一次，分别是 0 点、8 点、16 点\n\n只哟再结算时间持有仓位，才会进行结算\n\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 为什么要有资金费率\n\n</aside>\n\n用于维持合约价格与资产现货价格的平衡的机制，永续合约是没有到期日的金融衍生品，价格理论上会与现货价格保持一致，然而，由于市场波动，市场供需关系变化等因素，永续合约的价格可能会偏离现货价格，因此资金费率就是用来调整永续合约的价格，使其与现货价格保持一致的手段，通过经济刺激的方式影响市场参与者：\n\n正资金费率：当永续合约的价格高于现货价格时，资金费率为正，这意味着多头看涨持仓者需要向空头支付费用，这种机制鼓励更多的市场参与者做空，以期降低永续合约的价格，使其向现货价格靠拢\n\n负资金费率：当永续合约价格低于现货价格的时候，资金费率为负，此时，空头持仓需要向多头持仓者支付费用，这激励更多的市场参与者做多，以提升永续合约的价格。\n\n那么，为什么一定要有这个资金费率呢，不能没有这个机制吗\n\n首先，交易所的目的是鼓励市场参与者参与交易，提高市场效率，没有这个机制，市场的自我调节能力会减弱，而且没有这个机制的话也会导致更多的投机行为，因为交易者可以不受持有成本的影响长期持有头寸，最后，最重要的是，资金费率可以提高市场流动性\n\n## 全仓/逐仓\n\n两种交易模式：\n\n开全仓的情况下，如果 A 账户内有 1w，花了 5k 开 BTC 多单，花了 3K 开了 ETH 多单，账户内留了 2k，如果此时暴跌，那么除了开的多单，账户内的余额（前提是同一币种，不同币种没有讨论价值）也会被自动用来补仓，直到价格回升或者跌倒谷底直接爆仓。因为此时保证金是共享的\n\n开逐仓的情况下：每个保证金是独立的，互相不受影响，只需要手动单独添加保证金\n\n## 做多还是做空\n\n做多不仅仅是合约对赌收益，还有相应的币价上涨带来的收益，理论上收益无上限\n\n做空的收益最高是 100%\\*杠杆倍数，还得要承受币价下跌带来的无常损失\n\n因此做多的收益会高于做空，而且做多也是提振市场信心，做空除了加剧 FOMO，毫无意义\n\n## 期现套利\n\n这是一种吃交易所资金费率的方式，交易者在资金费率为正的时候，同时买入永续合约和相应数量的现货，这样期望从多头支付给空头的资金费率中获利\n\n常见的现货做多，合约做空，获取其中的空头资金费率\n\n跨交易所套利：不同交易所的资金费率不同，因此可以吃掉这个价差\n\n三角套利：多种资产品种进行 swap，最后会出现一个缺口，这个缺口可以作为套利空间\n","slug":"Contract","published":1,"date":"2024-05-22T02:51:12.614Z","updated":"2024-05-22T02:52:21.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejro00013jf0aulpf6jk","content":"<p>永续合约已经成为了加密货币交易量最大的交易方式，但永续合约是一个币圈独创的产品，与平时接触的普通金融衍生品不同，币圈永续合约的设计理解起来有点困难，甚至很多人虽然经常用永续合约，但依然不知道各种指标是什么意思。</p>\n<p>很多人爆仓，是因为不能理解币圈永续合约的本质。</p>\n<h3 id=\"永续合约的全称，叫做「期货永续合约」\"><a href=\"#永续合约的全称，叫做「期货永续合约」\" class=\"headerlink\" title=\"永续合约的全称，叫做「期货永续合约」\"></a>永续合约的全称，叫做「期货永续合约」</h3><p>三个关键词：期货，永续，合约</p>\n<p>期货：相较于现货而言，在现货交易中，双方直接一手交钱一手交货，而在期货交易中，约定了在将来某个时间以某个价格交易商品，举个例子，A 和 B 约定，在两个月后，A 以 200 元&#x2F;斤的价格卖 100 斤大米给 B，双方签订了合同，则 A 是合约的卖方，B 是合约的买方，这个交易的过程，就是以期货的交易形式的合约，期，即未来的时间的意思，和现货对应</p>\n<p>在这个过程中，如果 A 和 B 的双方的某一方不想要按照原来的约定买大米了，那么，他们签订的这份合同可以卖给别人，如果是 B 卖的，那么 B 就变成了合同的卖方，期货合约都是有到期期限的，在最后时间是一定要交割的，到了<code>交割日</code>，买卖双方会强制按照当初的约定进行交割，这个中合约也叫做<code>期货交割合约</code></p>\n<p>为了让合约购买的双方，在合约的到期日都能遵循约定进行交割，双方都需要缴纳一定的资金，这个就叫<code>保证金</code>。</p>\n<p>在交易所中，假设当前 BTC 的价格为 2W 美金，而 A 觉得，到了下个星期，BTC 能涨到 2.5w 美金，那么 A 就会买入看涨合约，同时要缴纳一定的保证金，（这个保证金的缴纳需要看当时买入的合约本位是什么），这份看涨合约代表：下个星期，A 有权利以 2w 美金的价格买入 BTC，而合约市场（期市）是需要对手盘的，也就是交易对手才能成交，假设对手是 B，B 觉得下个星期 BTC 会跌，所以 B 想在下个星期以 2w 美金的价格卖出 BTC，对于 A 来说是先低买高卖，对于 B 来说是先高借后低还。</p>\n<p>到了下个星期，如果 BTC 的价格跌到了 1.8w 美金，那么 A 亏损，B 盈利</p>\n<p>以上的例子讲的期货合约，最后都要交割，称之为<code>交割合约</code>，还有一种没有交割时间的合约，就是<code>期货永续合约</code>，永续合约分为两种，<code>正向合约</code>和<code>反向合约</code></p>\n<p>正向合约很好理解，跟踪的交易标的是 BTC，以 USDT 计价，保证金也是 USDT</p>\n<p>反向合约的跟踪标的和计价都和正向合约一样，但是以 BTC 为保证金，这个就是<code>X本位合约</code>的意思，</p>\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 举例：`U本位`就是正向合约，`币本位`就是反向合约\n\n</aside>\n\n<p>从交易体验来说，正向合约使用 USDT 一种币种作为保证金，可以开多币种的合约，确实是更灵活，更适合新手使用，合约的单位是张，但一张正向合约和一张反向合约所代表的面值分别是多少呢？一张 BTC 合约的面试通常是需要提前约定，不一样的地方在于，正向合约一张合约面值按 BTC 数量算（价值多少个 BTC），而反向合约是按 USDT 数量（价值多少 USDT），比方说可以假设</p>\n<table>\n<thead>\n<tr>\n<th>合约类型</th>\n<th>合约面值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一张正向 BTC 合约面值</td>\n<td>0.1BTC</td>\n</tr>\n<tr>\n<td>一张反向 BTC 合约面值</td>\n<td>100USDT</td>\n</tr>\n</tbody></table>\n<p>以上说明什么呢，正向合约需要拥有币种标的如：BTC，反向合约是按 USDT 计价的，只需要拥有 USDT 即可，这也是反向合约入场门槛低的原因，其次也和看涨看跌合约有关，一般，如果是看涨合约，那么就买正向合约，如果盈利的话则是币值涨 + 合约收益</p>\n<h2 id=\"保证金\"><a href=\"#保证金\" class=\"headerlink\" title=\"保证金\"></a>保证金</h2><p>保证金是开仓是需要缴纳的资金，正向何雨两者保证金计算如下：</p>\n<p>正向合约的仓位价值 &#x3D; 合约面值 _ 合约张数 _ 标记价格</p>\n<p>正向合约的仓位价值 &#x3D; 杠杆倍数 * 保证金数量</p>\n<p>$$<br>合约价值<em>合约张数</em>标记价格 &#x3D; 杠杆倍数 * 保证金数量<br>$$</p>\n<p>以上的公式可以看出，杠杆倍数越高，保证金数量不变的情况下，能开的张数越多，如果盈利，收益越高，如果亏损，保证金数量需要追加的数量越大。</p>\n<p>举个例子：在 BTC 价格是 2w 美金的时候，买 5 张 BTC 正向合约，以 2 倍杠杆买入，则保证金：</p>\n<p>$$<br>保证金&#x3D;0.1<em>20000</em>5&#x2F;2&#x3D;5000 USDT<br>$$</p>\n<p>0.1 是合约面值，20000 标记价格，5 为合约张数，2 位杠杆倍数</p>\n<p>反向合约的情况是</p>\n<p>反向合约的仓位价值&#x3D;合约价值*合约张数</p>\n<p>反向合约的仓位价值&#x3D;杠杆倍数<em>保证金数量</em>标记价格</p>\n<p>所以反向合约中：<strong>合约价值<em>合约张数&#x3D;杠杆倍数</em>保证金数量*标记价格</strong></p>\n<p>上面的例子中正向合约的仓位价值是 1w 美金，所以在反向合约中我们也买入同样的仓位价值（这在真实的交易市场中是同样的情况）需要买入 100 张合约（假设一张 BTC 反向合约 100USDT，买入 100 张就是 1w 美金），那么保证金是：100<em>100&#x2F;（2</em>20000）&#x3D; 0.4BTC，而 0.4BTC 的价值就等于 5000USDT</p>\n<h2 id=\"盈亏计算\"><a href=\"#盈亏计算\" class=\"headerlink\" title=\"盈亏计算\"></a>盈亏计算</h2><p>在正向合约中，</p>\n<p>做多时：盈亏 &#x3D; (平仓价-开仓价)<em>合约面值</em>合约张数</p>\n<p>做空时：盈亏 &#x3D; (开仓价-平仓价)<em>合约面值</em>合约张数</p>\n<p>在上面的例子中：在 2w 美金买入 5 张 BTC 合约，并在币价 2.5w 美金时卖出，则盈亏是：</p>\n<p>$$<br>(2.5w-2w)<em>0.1</em>5 &#x3D; 2500USDT<br>$$</p>\n<p>在反向合约中</p>\n<p>做多时：盈亏 &#x3D; (1&#x2F;开仓价 - 1&#x2F;平仓价)<em>合约面值</em>合约张数</p>\n<p>做空时：盈亏 &#x3D; (1&#x2F;平仓价 - 1&#x2F;开仓价)<em>合约面值</em>合约张数</p>\n<p>在上面的例子中：在 2w 美金买入 100 张 BTC 合约，则开仓时仓位价值&#x3D;100*100&#x3D;1w 美金，并在币价 2.5w 美金时卖出，则这个操作的盈亏是：</p>\n<p>$$<br>(1&#x2F;20000-1&#x2F;25000)<em>100</em>100&#x3D;0.1BTC<br>$$</p>\n<p>盈亏是 0.1BTC*25000 &#x3D; 2500USDT</p>\n<p>也就是反向合约中挣到的 BTC 如果以平仓时价格卖出，则与正向合约挣到的 USDT 相等</p>\n<p>正向合约与开仓平仓价差的关系是线性的，但是反向合约不是，反向合约的关系是凸函数的关系</p>\n<p>强平的基本原理：<code>亏损 = 保证金</code>，就会触发爆仓</p>\n<p>在正向合约做多的场景中，开仓时仓位价值&#x3D;合约面值<em>张数</em>开仓价，强平时仓位价值&#x3D;合约面值<em>张数</em>强平价，当仓位损失&#x3D;（开仓价-强平价）<em>合约面值</em>张数&#x3D;保证金，仓位被强平</p>\n<p>已知：合约面值<em>合约张数</em>标记价格&#x3D;杠杆倍数*保证金数量</p>\n<p>下面的<code>N</code>是杠杆倍数，<code>O</code>是开仓价格，强平价是<code>L</code>，保证金是<code>M</code></p>\n<p>即可推导出：强平价&#x3D;1&#x2F;杠杆倍数，表明开仓价跌了 1&#x2F;N 就会触发爆仓</p>\n<p>在上面的例子中，开仓价为 2w 美金，2 倍杠杆的情况下，则价格到 1w 美金就爆仓，如果是 50 倍杠杆，则价格到 19600 美金就爆仓</p>\n<p>做空的情况也是一样，价格涨了 1&#x2F;N 就爆仓</p>\n<p>再看看反向合约</p>\n<p>做多时：开仓时仓位价值&#x3D;O<em>N</em>M，平仓时仓位价值&#x3D;L<em>N</em>M，则亏损&#x3D;（O-L）<em>N</em>M，保证金价值&#x3D;L<em>M，所以当（O-L）</em>N<em>M&#x3D;L</em>M，就会触发强平</p>\n<p>上面的公式推导一下，得出：L&#x3D;O（1-1&#x2F;N+1），也就是说做多时开仓价跌 1&#x2F;N+1 就爆仓，</p>\n<p>做空时：开仓仓位价值&#x3D;O<em>N</em>M，平仓时仓位价值&#x3D;L<em>N</em>M，亏损&#x3D;（L-O）<em>N</em>M，保证金价值&#x3D;L<em>M，所以当（L-O）</em>N<em>M&#x3D;L</em>M，就触发强平</p>\n<p>推导为：L&#x3D;O（1+1&#x2F;N-1），就是说做空时开仓涨 1&#x2F;N-1 就爆仓，2 倍杠杆，即价格涨 50%就会爆仓，如果时 1 倍杠杆，则永不爆仓，得出结论：</p>\n<p><strong>反向合约，一倍做空，永不爆仓</strong></p>\n<h2 id=\"资金费率\"><a href=\"#资金费率\" class=\"headerlink\" title=\"资金费率\"></a>资金费率</h2><p>资金费率每 8 小时结算一次，分别是 0 点、8 点、16 点</p>\n<p>只哟再结算时间持有仓位，才会进行结算</p>\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 为什么要有资金费率\n\n</aside>\n\n<p>用于维持合约价格与资产现货价格的平衡的机制，永续合约是没有到期日的金融衍生品，价格理论上会与现货价格保持一致，然而，由于市场波动，市场供需关系变化等因素，永续合约的价格可能会偏离现货价格，因此资金费率就是用来调整永续合约的价格，使其与现货价格保持一致的手段，通过经济刺激的方式影响市场参与者：</p>\n<p>正资金费率：当永续合约的价格高于现货价格时，资金费率为正，这意味着多头看涨持仓者需要向空头支付费用，这种机制鼓励更多的市场参与者做空，以期降低永续合约的价格，使其向现货价格靠拢</p>\n<p>负资金费率：当永续合约价格低于现货价格的时候，资金费率为负，此时，空头持仓需要向多头持仓者支付费用，这激励更多的市场参与者做多，以提升永续合约的价格。</p>\n<p>那么，为什么一定要有这个资金费率呢，不能没有这个机制吗</p>\n<p>首先，交易所的目的是鼓励市场参与者参与交易，提高市场效率，没有这个机制，市场的自我调节能力会减弱，而且没有这个机制的话也会导致更多的投机行为，因为交易者可以不受持有成本的影响长期持有头寸，最后，最重要的是，资金费率可以提高市场流动性</p>\n<h2 id=\"全仓-逐仓\"><a href=\"#全仓-逐仓\" class=\"headerlink\" title=\"全仓&#x2F;逐仓\"></a>全仓&#x2F;逐仓</h2><p>两种交易模式：</p>\n<p>开全仓的情况下，如果 A 账户内有 1w，花了 5k 开 BTC 多单，花了 3K 开了 ETH 多单，账户内留了 2k，如果此时暴跌，那么除了开的多单，账户内的余额（前提是同一币种，不同币种没有讨论价值）也会被自动用来补仓，直到价格回升或者跌倒谷底直接爆仓。因为此时保证金是共享的</p>\n<p>开逐仓的情况下：每个保证金是独立的，互相不受影响，只需要手动单独添加保证金</p>\n<h2 id=\"做多还是做空\"><a href=\"#做多还是做空\" class=\"headerlink\" title=\"做多还是做空\"></a>做多还是做空</h2><p>做多不仅仅是合约对赌收益，还有相应的币价上涨带来的收益，理论上收益无上限</p>\n<p>做空的收益最高是 100%*杠杆倍数，还得要承受币价下跌带来的无常损失</p>\n<p>因此做多的收益会高于做空，而且做多也是提振市场信心，做空除了加剧 FOMO，毫无意义</p>\n<h2 id=\"期现套利\"><a href=\"#期现套利\" class=\"headerlink\" title=\"期现套利\"></a>期现套利</h2><p>这是一种吃交易所资金费率的方式，交易者在资金费率为正的时候，同时买入永续合约和相应数量的现货，这样期望从多头支付给空头的资金费率中获利</p>\n<p>常见的现货做多，合约做空，获取其中的空头资金费率</p>\n<p>跨交易所套利：不同交易所的资金费率不同，因此可以吃掉这个价差</p>\n<p>三角套利：多种资产品种进行 swap，最后会出现一个缺口，这个缺口可以作为套利空间</p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<p>永续合约已经成为了加密货币交易量最大的交易方式，但永续合约是一个币圈独创的产品，与平时接触的普通金融衍生品不同，币圈永续合约的设计理解起来有点困难，甚至很多人虽然经常用永续合约，但依然不知道各种指标是什么意思。</p>\n<p>很多人爆仓，是因为不能理解币圈永续合约的本质。</p>\n<h3 id=\"永续合约的全称，叫做「期货永续合约」\"><a href=\"#永续合约的全称，叫做「期货永续合约」\" class=\"headerlink\" title=\"永续合约的全称，叫做「期货永续合约」\"></a>永续合约的全称，叫做「期货永续合约」</h3><p>三个关键词：期货，永续，合约</p>\n<p>期货：相较于现货而言，在现货交易中，双方直接一手交钱一手交货，而在期货交易中，约定了在将来某个时间以某个价格交易商品，举个例子，A 和 B 约定，在两个月后，A 以 200 元&#x2F;斤的价格卖 100 斤大米给 B，双方签订了合同，则 A 是合约的卖方，B 是合约的买方，这个交易的过程，就是以期货的交易形式的合约，期，即未来的时间的意思，和现货对应</p>\n<p>在这个过程中，如果 A 和 B 的双方的某一方不想要按照原来的约定买大米了，那么，他们签订的这份合同可以卖给别人，如果是 B 卖的，那么 B 就变成了合同的卖方，期货合约都是有到期期限的，在最后时间是一定要交割的，到了<code>交割日</code>，买卖双方会强制按照当初的约定进行交割，这个中合约也叫做<code>期货交割合约</code></p>\n<p>为了让合约购买的双方，在合约的到期日都能遵循约定进行交割，双方都需要缴纳一定的资金，这个就叫<code>保证金</code>。</p>\n<p>在交易所中，假设当前 BTC 的价格为 2W 美金，而 A 觉得，到了下个星期，BTC 能涨到 2.5w 美金，那么 A 就会买入看涨合约，同时要缴纳一定的保证金，（这个保证金的缴纳需要看当时买入的合约本位是什么），这份看涨合约代表：下个星期，A 有权利以 2w 美金的价格买入 BTC，而合约市场（期市）是需要对手盘的，也就是交易对手才能成交，假设对手是 B，B 觉得下个星期 BTC 会跌，所以 B 想在下个星期以 2w 美金的价格卖出 BTC，对于 A 来说是先低买高卖，对于 B 来说是先高借后低还。</p>\n<p>到了下个星期，如果 BTC 的价格跌到了 1.8w 美金，那么 A 亏损，B 盈利</p>\n<p>以上的例子讲的期货合约，最后都要交割，称之为<code>交割合约</code>，还有一种没有交割时间的合约，就是<code>期货永续合约</code>，永续合约分为两种，<code>正向合约</code>和<code>反向合约</code></p>\n<p>正向合约很好理解，跟踪的交易标的是 BTC，以 USDT 计价，保证金也是 USDT</p>\n<p>反向合约的跟踪标的和计价都和正向合约一样，但是以 BTC 为保证金，这个就是<code>X本位合约</code>的意思，</p>\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 举例：`U本位`就是正向合约，`币本位`就是反向合约\n\n</aside>\n\n<p>从交易体验来说，正向合约使用 USDT 一种币种作为保证金，可以开多币种的合约，确实是更灵活，更适合新手使用，合约的单位是张，但一张正向合约和一张反向合约所代表的面值分别是多少呢？一张 BTC 合约的面试通常是需要提前约定，不一样的地方在于，正向合约一张合约面值按 BTC 数量算（价值多少个 BTC），而反向合约是按 USDT 数量（价值多少 USDT），比方说可以假设</p>\n<table>\n<thead>\n<tr>\n<th>合约类型</th>\n<th>合约面值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一张正向 BTC 合约面值</td>\n<td>0.1BTC</td>\n</tr>\n<tr>\n<td>一张反向 BTC 合约面值</td>\n<td>100USDT</td>\n</tr>\n</tbody></table>\n<p>以上说明什么呢，正向合约需要拥有币种标的如：BTC，反向合约是按 USDT 计价的，只需要拥有 USDT 即可，这也是反向合约入场门槛低的原因，其次也和看涨看跌合约有关，一般，如果是看涨合约，那么就买正向合约，如果盈利的话则是币值涨 + 合约收益</p>\n<h2 id=\"保证金\"><a href=\"#保证金\" class=\"headerlink\" title=\"保证金\"></a>保证金</h2><p>保证金是开仓是需要缴纳的资金，正向何雨两者保证金计算如下：</p>\n<p>正向合约的仓位价值 &#x3D; 合约面值 _ 合约张数 _ 标记价格</p>\n<p>正向合约的仓位价值 &#x3D; 杠杆倍数 * 保证金数量</p>\n<p>$$<br>合约价值<em>合约张数</em>标记价格 &#x3D; 杠杆倍数 * 保证金数量<br>$$</p>\n<p>以上的公式可以看出，杠杆倍数越高，保证金数量不变的情况下，能开的张数越多，如果盈利，收益越高，如果亏损，保证金数量需要追加的数量越大。</p>\n<p>举个例子：在 BTC 价格是 2w 美金的时候，买 5 张 BTC 正向合约，以 2 倍杠杆买入，则保证金：</p>\n<p>$$<br>保证金&#x3D;0.1<em>20000</em>5&#x2F;2&#x3D;5000 USDT<br>$$</p>\n<p>0.1 是合约面值，20000 标记价格，5 为合约张数，2 位杠杆倍数</p>\n<p>反向合约的情况是</p>\n<p>反向合约的仓位价值&#x3D;合约价值*合约张数</p>\n<p>反向合约的仓位价值&#x3D;杠杆倍数<em>保证金数量</em>标记价格</p>\n<p>所以反向合约中：<strong>合约价值<em>合约张数&#x3D;杠杆倍数</em>保证金数量*标记价格</strong></p>\n<p>上面的例子中正向合约的仓位价值是 1w 美金，所以在反向合约中我们也买入同样的仓位价值（这在真实的交易市场中是同样的情况）需要买入 100 张合约（假设一张 BTC 反向合约 100USDT，买入 100 张就是 1w 美金），那么保证金是：100<em>100&#x2F;（2</em>20000）&#x3D; 0.4BTC，而 0.4BTC 的价值就等于 5000USDT</p>\n<h2 id=\"盈亏计算\"><a href=\"#盈亏计算\" class=\"headerlink\" title=\"盈亏计算\"></a>盈亏计算</h2><p>在正向合约中，</p>\n<p>做多时：盈亏 &#x3D; (平仓价-开仓价)<em>合约面值</em>合约张数</p>\n<p>做空时：盈亏 &#x3D; (开仓价-平仓价)<em>合约面值</em>合约张数</p>\n<p>在上面的例子中：在 2w 美金买入 5 张 BTC 合约，并在币价 2.5w 美金时卖出，则盈亏是：</p>\n<p>$$<br>(2.5w-2w)<em>0.1</em>5 &#x3D; 2500USDT<br>$$</p>\n<p>在反向合约中</p>\n<p>做多时：盈亏 &#x3D; (1&#x2F;开仓价 - 1&#x2F;平仓价)<em>合约面值</em>合约张数</p>\n<p>做空时：盈亏 &#x3D; (1&#x2F;平仓价 - 1&#x2F;开仓价)<em>合约面值</em>合约张数</p>\n<p>在上面的例子中：在 2w 美金买入 100 张 BTC 合约，则开仓时仓位价值&#x3D;100*100&#x3D;1w 美金，并在币价 2.5w 美金时卖出，则这个操作的盈亏是：</p>\n<p>$$<br>(1&#x2F;20000-1&#x2F;25000)<em>100</em>100&#x3D;0.1BTC<br>$$</p>\n<p>盈亏是 0.1BTC*25000 &#x3D; 2500USDT</p>\n<p>也就是反向合约中挣到的 BTC 如果以平仓时价格卖出，则与正向合约挣到的 USDT 相等</p>\n<p>正向合约与开仓平仓价差的关系是线性的，但是反向合约不是，反向合约的关系是凸函数的关系</p>\n<p>强平的基本原理：<code>亏损 = 保证金</code>，就会触发爆仓</p>\n<p>在正向合约做多的场景中，开仓时仓位价值&#x3D;合约面值<em>张数</em>开仓价，强平时仓位价值&#x3D;合约面值<em>张数</em>强平价，当仓位损失&#x3D;（开仓价-强平价）<em>合约面值</em>张数&#x3D;保证金，仓位被强平</p>\n<p>已知：合约面值<em>合约张数</em>标记价格&#x3D;杠杆倍数*保证金数量</p>\n<p>下面的<code>N</code>是杠杆倍数，<code>O</code>是开仓价格，强平价是<code>L</code>，保证金是<code>M</code></p>\n<p>即可推导出：强平价&#x3D;1&#x2F;杠杆倍数，表明开仓价跌了 1&#x2F;N 就会触发爆仓</p>\n<p>在上面的例子中，开仓价为 2w 美金，2 倍杠杆的情况下，则价格到 1w 美金就爆仓，如果是 50 倍杠杆，则价格到 19600 美金就爆仓</p>\n<p>做空的情况也是一样，价格涨了 1&#x2F;N 就爆仓</p>\n<p>再看看反向合约</p>\n<p>做多时：开仓时仓位价值&#x3D;O<em>N</em>M，平仓时仓位价值&#x3D;L<em>N</em>M，则亏损&#x3D;（O-L）<em>N</em>M，保证金价值&#x3D;L<em>M，所以当（O-L）</em>N<em>M&#x3D;L</em>M，就会触发强平</p>\n<p>上面的公式推导一下，得出：L&#x3D;O（1-1&#x2F;N+1），也就是说做多时开仓价跌 1&#x2F;N+1 就爆仓，</p>\n<p>做空时：开仓仓位价值&#x3D;O<em>N</em>M，平仓时仓位价值&#x3D;L<em>N</em>M，亏损&#x3D;（L-O）<em>N</em>M，保证金价值&#x3D;L<em>M，所以当（L-O）</em>N<em>M&#x3D;L</em>M，就触发强平</p>\n<p>推导为：L&#x3D;O（1+1&#x2F;N-1），就是说做空时开仓涨 1&#x2F;N-1 就爆仓，2 倍杠杆，即价格涨 50%就会爆仓，如果时 1 倍杠杆，则永不爆仓，得出结论：</p>\n<p><strong>反向合约，一倍做空，永不爆仓</strong></p>\n<h2 id=\"资金费率\"><a href=\"#资金费率\" class=\"headerlink\" title=\"资金费率\"></a>资金费率</h2><p>资金费率每 8 小时结算一次，分别是 0 点、8 点、16 点</p>\n<p>只哟再结算时间持有仓位，才会进行结算</p>\n<aside>\n<img src=\"/icons/cow_yellow.svg\" alt=\"/icons/cow_yellow.svg\" width=\"40px\" /> 为什么要有资金费率\n\n</aside>\n\n<p>用于维持合约价格与资产现货价格的平衡的机制，永续合约是没有到期日的金融衍生品，价格理论上会与现货价格保持一致，然而，由于市场波动，市场供需关系变化等因素，永续合约的价格可能会偏离现货价格，因此资金费率就是用来调整永续合约的价格，使其与现货价格保持一致的手段，通过经济刺激的方式影响市场参与者：</p>\n<p>正资金费率：当永续合约的价格高于现货价格时，资金费率为正，这意味着多头看涨持仓者需要向空头支付费用，这种机制鼓励更多的市场参与者做空，以期降低永续合约的价格，使其向现货价格靠拢</p>\n<p>负资金费率：当永续合约价格低于现货价格的时候，资金费率为负，此时，空头持仓需要向多头持仓者支付费用，这激励更多的市场参与者做多，以提升永续合约的价格。</p>\n<p>那么，为什么一定要有这个资金费率呢，不能没有这个机制吗</p>\n<p>首先，交易所的目的是鼓励市场参与者参与交易，提高市场效率，没有这个机制，市场的自我调节能力会减弱，而且没有这个机制的话也会导致更多的投机行为，因为交易者可以不受持有成本的影响长期持有头寸，最后，最重要的是，资金费率可以提高市场流动性</p>\n<h2 id=\"全仓-逐仓\"><a href=\"#全仓-逐仓\" class=\"headerlink\" title=\"全仓&#x2F;逐仓\"></a>全仓&#x2F;逐仓</h2><p>两种交易模式：</p>\n<p>开全仓的情况下，如果 A 账户内有 1w，花了 5k 开 BTC 多单，花了 3K 开了 ETH 多单，账户内留了 2k，如果此时暴跌，那么除了开的多单，账户内的余额（前提是同一币种，不同币种没有讨论价值）也会被自动用来补仓，直到价格回升或者跌倒谷底直接爆仓。因为此时保证金是共享的</p>\n<p>开逐仓的情况下：每个保证金是独立的，互相不受影响，只需要手动单独添加保证金</p>\n<h2 id=\"做多还是做空\"><a href=\"#做多还是做空\" class=\"headerlink\" title=\"做多还是做空\"></a>做多还是做空</h2><p>做多不仅仅是合约对赌收益，还有相应的币价上涨带来的收益，理论上收益无上限</p>\n<p>做空的收益最高是 100%*杠杆倍数，还得要承受币价下跌带来的无常损失</p>\n<p>因此做多的收益会高于做空，而且做多也是提振市场信心，做空除了加剧 FOMO，毫无意义</p>\n<h2 id=\"期现套利\"><a href=\"#期现套利\" class=\"headerlink\" title=\"期现套利\"></a>期现套利</h2><p>这是一种吃交易所资金费率的方式，交易者在资金费率为正的时候，同时买入永续合约和相应数量的现货，这样期望从多头支付给空头的资金费率中获利</p>\n<p>常见的现货做多，合约做空，获取其中的空头资金费率</p>\n<p>跨交易所套利：不同交易所的资金费率不同，因此可以吃掉这个价差</p>\n<p>三角套利：多种资产品种进行 swap，最后会出现一个缺口，这个缺口可以作为套利空间</p>\n"},{"title":"DeFi(去中心化金融)","_content":"\n# 流动性挖矿\n\n什么是挖矿？\n\n最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。\n\n**区块链挖矿**主要包括以下几个方面：\n\n- 交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。\n- 工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”\n- 区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。\n- 区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接\n- 奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。\n\n以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制\n\n除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押\n\n# 流动性挖矿\n\n这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。\n\n- 流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。\n- 提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易\n- 交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。\n- 额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。\n- 风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）\n\n流动性挖矿有两种模式：Yield Farming 和 Yield Mining\n\n- **Farming**：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益\n- **Mining**：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。\n\n# Stake：质押\n\n质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B\n\n和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，\n\n- 质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。\n- 收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。\n- 质押会有资产的锁定期限制，锁定期内无法赎回\n- 质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。\n\n# DEX 的收益获取\n\nDEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢\n\n在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：\n\n- LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）\n- 平台收益：用于一部分的平台治理、运营、开发团队的成本\n- 流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。\n- 社区基金：DEX 的社区运营治理也需要一些费用\n- 捐赠：公益项目\n\n# 问题：\n\nDEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢\n\nDEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。\n\nDEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。\n","source":"_posts/DeFi.md","raw":"---\ntitle: DeFi(去中心化金融)\n---\n\n# 流动性挖矿\n\n什么是挖矿？\n\n最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。\n\n**区块链挖矿**主要包括以下几个方面：\n\n- 交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。\n- 工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”\n- 区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。\n- 区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接\n- 奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。\n\n以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制\n\n除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押\n\n# 流动性挖矿\n\n这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。\n\n- 流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。\n- 提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易\n- 交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。\n- 额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。\n- 风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）\n\n流动性挖矿有两种模式：Yield Farming 和 Yield Mining\n\n- **Farming**：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益\n- **Mining**：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。\n\n# Stake：质押\n\n质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B\n\n和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，\n\n- 质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。\n- 收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。\n- 质押会有资产的锁定期限制，锁定期内无法赎回\n- 质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。\n\n# DEX 的收益获取\n\nDEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢\n\n在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：\n\n- LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）\n- 平台收益：用于一部分的平台治理、运营、开发团队的成本\n- 流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。\n- 社区基金：DEX 的社区运营治理也需要一些费用\n- 捐赠：公益项目\n\n# 问题：\n\nDEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢\n\nDEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。\n\nDEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。\n","slug":"DeFi","published":1,"date":"2024-03-26T07:13:35.915Z","updated":"2024-03-28T02:20:00.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrq00033jf0bk37fo44","content":"<h1 id=\"流动性挖矿\"><a href=\"#流动性挖矿\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>什么是挖矿？</p>\n<p>最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。</p>\n<p><strong>区块链挖矿</strong>主要包括以下几个方面：</p>\n<ul>\n<li>交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。</li>\n<li>工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”</li>\n<li>区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。</li>\n<li>区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接</li>\n<li>奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。</li>\n</ul>\n<p>以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制</p>\n<p>除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押</p>\n<h1 id=\"流动性挖矿-1\"><a href=\"#流动性挖矿-1\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。</p>\n<ul>\n<li>流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。</li>\n<li>提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易</li>\n<li>交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。</li>\n<li>额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。</li>\n<li>风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）</li>\n</ul>\n<p>流动性挖矿有两种模式：Yield Farming 和 Yield Mining</p>\n<ul>\n<li><strong>Farming</strong>：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益</li>\n<li><strong>Mining</strong>：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。</li>\n</ul>\n<h1 id=\"Stake：质押\"><a href=\"#Stake：质押\" class=\"headerlink\" title=\"Stake：质押\"></a>Stake：质押</h1><p>质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B</p>\n<p>和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，</p>\n<ul>\n<li>质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。</li>\n<li>收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。</li>\n<li>质押会有资产的锁定期限制，锁定期内无法赎回</li>\n<li>质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。</li>\n</ul>\n<h1 id=\"DEX-的收益获取\"><a href=\"#DEX-的收益获取\" class=\"headerlink\" title=\"DEX 的收益获取\"></a>DEX 的收益获取</h1><p>DEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢</p>\n<p>在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：</p>\n<ul>\n<li>LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）</li>\n<li>平台收益：用于一部分的平台治理、运营、开发团队的成本</li>\n<li>流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。</li>\n<li>社区基金：DEX 的社区运营治理也需要一些费用</li>\n<li>捐赠：公益项目</li>\n</ul>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>DEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢</p>\n<p>DEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。</p>\n<p>DEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。</p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"流动性挖矿\"><a href=\"#流动性挖矿\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>什么是挖矿？</p>\n<p>最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。</p>\n<p><strong>区块链挖矿</strong>主要包括以下几个方面：</p>\n<ul>\n<li>交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。</li>\n<li>工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”</li>\n<li>区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。</li>\n<li>区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接</li>\n<li>奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。</li>\n</ul>\n<p>以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制</p>\n<p>除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押</p>\n<h1 id=\"流动性挖矿-1\"><a href=\"#流动性挖矿-1\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。</p>\n<ul>\n<li>流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。</li>\n<li>提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易</li>\n<li>交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。</li>\n<li>额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。</li>\n<li>风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）</li>\n</ul>\n<p>流动性挖矿有两种模式：Yield Farming 和 Yield Mining</p>\n<ul>\n<li><strong>Farming</strong>：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益</li>\n<li><strong>Mining</strong>：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。</li>\n</ul>\n<h1 id=\"Stake：质押\"><a href=\"#Stake：质押\" class=\"headerlink\" title=\"Stake：质押\"></a>Stake：质押</h1><p>质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B</p>\n<p>和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，</p>\n<ul>\n<li>质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。</li>\n<li>收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。</li>\n<li>质押会有资产的锁定期限制，锁定期内无法赎回</li>\n<li>质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。</li>\n</ul>\n<h1 id=\"DEX-的收益获取\"><a href=\"#DEX-的收益获取\" class=\"headerlink\" title=\"DEX 的收益获取\"></a>DEX 的收益获取</h1><p>DEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢</p>\n<p>在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：</p>\n<ul>\n<li>LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）</li>\n<li>平台收益：用于一部分的平台治理、运营、开发团队的成本</li>\n<li>流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。</li>\n<li>社区基金：DEX 的社区运营治理也需要一些费用</li>\n<li>捐赠：公益项目</li>\n</ul>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>DEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢</p>\n<p>DEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。</p>\n<p>DEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。</p>\n"},{"title":"Element-UI组件解析","_content":"\n<aside>\n💡 组件上层封装基本上都是基于已有的UI组件库或者是结合一些前端框架开进行的，如利用ElementUI或者antd进行二次开发，利用Vue/React等前端框架，结合一下UI库如TailwindCSS进行UI修饰，完成封装\n\n</aside>\n\nElementUI：Form 组件拆解\n\n<aside>\n💡 Form组件一直是各大UI框架的重头戏，以ElementUI为例，看看Form组件是如何设计的。\n\n</aside>\n\n先来看看 ElementUI 的 Form 组件是如何使用的\n\n```html\n<el-form :model=\"form\" label-width=\"auto\" style=\"max-width: 600px\">\n  <el-form-item label=\"Activity name\" props=\"name\">\n    <el-input v-model=\"form.name\" />\n  </el-form-item>\n</el-form>\n```\n\nel-form 组件作为最外层包裹的标签，model 属性是整个 form 组件传入的对象，内部的 form-item 包裹了具体组件内容，作为每个 form 组件的具体表现形式，在 form-item 标签上的属性 props 则是接收 form 传入的 model 对象的属性值，不需要在 input 上指定 v-model，即可更新 form.name 的值，那么这里面是怎么做的呢。\n\n```html\n<--! Form组件 -->\n<template>\n  <form :class=\"formClasses\">\n    <slot />\n  </form>\n</template>\n```\n\n上面的 Form 组件能看到，ElementUI 的 Form 组件是用的 html 原声的 form 标签实现的，传入一个 formClasses 覆盖原声的 class 样式\n\nForm 组件用了 provide/inject 依赖注入的方式传递深层次属性，首先进行 provide 依赖收集\n\n```tsx\nprovide(\n  formContextKey,\n  reactive({\n    ...toRefs(props),\n    emit,\n\n    resetFields,\n    clearValidate,\n    validateField,\n    getField,\n    addField,\n    removeField,\n\n    ...useFormLabelWidth(),\n  })\n)\n这里的formContextKey是一个常量，用symbol修饰的变量\nexport const formContextKey: InjectionKey<FormContext> =\n  Symbol('formContextKey')\nexport const formItemContextKey: InjectionKey<FormItemContext> =\n  Symbol('formItemContextKey')\n```\n\n上面的 emit 是 form 组件导出的方法：validate，以及 resetField 之类的都是 form 全局方法，通过 form 全局依赖注入到 formContextKey 上，具体使用场景举个例子：\n\n```tsx\nconst formRef = ref(); // 赋值给Form组件的ref属性变量\n\nformRef.validate();\nformRef.resetFields();\n\n// 这里的formRef是赋值给elForm组件的ref变量，使用的就是Form组件导出的全局变量\n```\n\nForm 组件完成了一些全局方法的注册，外层 props 的定义，以及顶层 form 标签的构建，那么 formItem 是如何接收这些属性的呢：inject\n\n```tsx\nconst formContext = inject(formContextKey, undefined);\nconst parentFormItemContext = inject(formItemContextKey, undefined);\n// formContext就是从Form组件传入的属性内容\n// 将Form组件的属性model的数据获取之后，返回对应的value，用于在formItem中进行表单校验等处理\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\n// 这里获取的propString就是在formItem标签上的属性prop的内容，表示获取每个formItem的字段\nconst propString = computed(() => {\n  if (!props.prop) return \"\";\n  return isString(props.prop) ? props.prop : props.prop.join(\".\");\n});\n\n// 对每个formItem上的prop属性进行表单检验处理\nconst doValidate = async (rules: RuleItem[]): Promise<true> => {\n  const modelName = propString.value;\n  const validator = new AsyncValidator({\n    [modelName]: rules,\n  });\n  return validator\n    .validate({ [modelName]: fieldValue.value }, { firstFields: true })\n    .then(() => {\n      onValidationSucceeded();\n      return true as const;\n    })\n    .catch((err: FormValidateFailure) => {\n      onValidationFailed(err as FormValidateFailure);\n      return Promise.reject(err);\n    });\n};\n```\n\n这里有个问题，如何将 formItem 下的组件的值赋值给 model.prop 的属性上\n\n```tsx\n// 这里model.prop会将值作为fieldValue的默认值\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\ninitialValue = clone(fieldValue.value);\n\n// 那么在input等组件的值发生改变的时候，formItem又是如何监听到值的变化并且完成model.prop的更新的呢\n// 这里用computed计算属性，返回model.prop的值，而在input等组件上使用v-model对model.prop实现数据的双向绑定\n// 因此formItem下的input等组件必须要显示的将model.prop双向绑定上\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\n// 此外，input组件会传入form属性，这个form属性的值就是从Form组件全局导出的，用于确定form表单下的id对应值\n// 同一个id对应的表单项会互相关联\n```\n\n```html\n<input :id=\"inputId\" :form=\"form\" />\n\nconst { form: elForm, formItem: elFormItem } = useFormItem() <--!\n这里的inputId和Form导出的是同一个实例 -->\n```\n\n<aside>\n💡 总结：Form和FormItem之间的数据传递是用的provide和inject，FormItem组件下的input等组件的数据双向绑定则是借助了form属性和id属性，封装了formItemHooks用于组件内部调用以使用Form和FormItem这两个全局变量，所有的全局方法以defineExpose的形式导出\n\n</aside>\n\nElementUI：Table 组件\n\n<aside>\n💡 Table组件的难点主要在表格宽高自适应，固定行和列，多级表格的样式，是比Form组件的设计难度更加大的存在\n\n</aside>\n\nTable 组件导出了两个组件模块：Table 和 TableColumn，先来看看 Table 组件的设计\n\n整个 Table 组件的 template 部分分为两个区域，整个组件由外层的 tableWrapper 包裹，tableWrapper 外层布局融合了传入的 style 和 class 属性，规定了 table 整体的布局，这些 style 和 class 以命名空间的形式动态的加载到 class 中\n\ntable 的核心分为：原生 table 包裹，table-header 组件，table-body，table-footer\n\n其中，bodyWrapper 下使用了 scrollbar 组件包裹，目的是解决表格超出当前页面高度时，出现滚动条\n\n```html\n<div ref=\"bodyWrapper\" :class=\"ns.e('body-wrapper')\">\n  <el-scrollbar\n    ref=\"scrollBarRef\"\n    :view-style=\"scrollbarViewStyle\"\n    :wrap-style=\"scrollbarStyle\"\n    :always=\"scrollbarAlwaysOn\"\n  >\n    <table\n      ref=\"tableBody\"\n      :class=\"ns.e('body')\"\n      cellspacing=\"0\"\n      cellpadding=\"0\"\n      border=\"0\"\n      :style=\"{\n              width: bodyWidth,\n              tableLayout,\n            }\"\n    >\n      <hColgroup\n        :columns=\"store.states.columns.value\"\n        :table-layout=\"tableLayout\"\n      />\n      <table-header\n        v-if=\"showHeader && tableLayout === 'auto'\"\n        ref=\"tableHeaderRef\"\n        :class=\"ns.e('body-header')\"\n        :border=\"border\"\n        :default-sort=\"defaultSort\"\n        :store=\"store\"\n        @set-drag-visible=\"setDragVisible\"\n      />\n      <table-body\n        :context=\"context\"\n        :highlight=\"highlightCurrentRow\"\n        :row-class-name=\"rowClassName\"\n        :tooltip-effect=\"tooltipEffect\"\n        :tooltip-options=\"tooltipOptions\"\n        :row-style=\"rowStyle\"\n        :store=\"store\"\n        :stripe=\"stripe\"\n      />\n      <table-footer\n        v-if=\"showSummary && tableLayout === 'auto'\"\n        :class=\"ns.e('body-footer')\"\n        :border=\"border\"\n        :default-sort=\"defaultSort\"\n        :store=\"store\"\n        :sum-text=\"computedSumText\"\n        :summary-method=\"summaryMethod\"\n      />\n    </table>\n    <div\n      v-if=\"isEmpty\"\n      ref=\"emptyBlock\"\n      :style=\"emptyBlockStyle\"\n      :class=\"ns.e('empty-block')\"\n    >\n      <span :class=\"ns.e('empty-text')\">\n        <slot name=\"empty\">{{ computedEmptyText }}</slot>\n      </span>\n    </div>\n    <div\n      v-if=\"$slots.append\"\n      ref=\"appendWrapper\"\n      :class=\"ns.e('append-wrapper')\"\n    >\n      <slot name=\"append\" />\n    </div>\n  </el-scrollbar>\n</div>\n```\n\ntable-footer 是为了显示什么内容呢，上图能看到 showSummary，当需要显示表格总计的情况时，就在 table-footer 上显示\n\n一个一个分析 Table 组件，从 table-header 开始\n\ntable-header 是用的 h()方法渲染的 UI，导出的是一个含有 setup 方法并且返回用 h 函数渲染的 dom 结构，具体设计如下\n\n```jsx\nreturn h(\n  \"thead\",\n  {\n    class: { [ns.is(\"group\")]: isGroup },\n  },\n  columnRows.map((subColumns, rowIndex) =>\n    h(\n      \"tr\",\n      {\n        class: getHeaderRowClass(rowIndex),\n        key: rowIndex,\n        style: getHeaderRowStyle(rowIndex),\n      },\n      subColumns.map((column, cellIndex) => {\n        if (column.rowSpan > rowSpan) {\n          rowSpan = column.rowSpan;\n        }\n        return h(\n          \"th\",\n          {\n            class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),\n            colspan: column.colSpan,\n            key: `${column.id}-thead`,\n            rowspan: column.rowSpan,\n            style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),\n            onClick: ($event) => handleHeaderClick($event, column),\n            onContextmenu: ($event) => handleHeaderContextMenu($event, column),\n            onMousedown: ($event) => handleMouseDown($event, column),\n            onMousemove: ($event) => handleMouseMove($event, column),\n            onMouseout: handleMouseOut,\n          },\n          [\n            h(\n              \"div\",\n              {\n                class: [\n                  \"cell\",\n                  column.filteredValue && column.filteredValue.length > 0\n                    ? \"highlight\"\n                    : \"\",\n                ],\n              },\n              [\n                column.renderHeader\n                  ? column.renderHeader({\n                      column,\n                      $index: cellIndex,\n                      store,\n                      _self: $parent,\n                    })\n                  : column.label,\n                column.sortable &&\n                  h(\n                    \"span\",\n                    {\n                      onClick: ($event) => handleSortClick($event, column),\n                      class: \"caret-wrapper\",\n                    },\n                    [\n                      h(\"i\", {\n                        onClick: ($event) =>\n                          handleSortClick($event, column, \"ascending\"),\n                        class: \"sort-caret ascending\",\n                      }),\n                      h(\"i\", {\n                        onClick: ($event) =>\n                          handleSortClick($event, column, \"descending\"),\n                        class: \"sort-caret descending\",\n                      }),\n                    ]\n                  ),\n                column.filterable &&\n                  h(FilterPanel, {\n                    store,\n                    placement: column.filterPlacement || \"bottom-start\",\n                    column,\n                    upDataColumn: (key, value) => {\n                      column[key] = value;\n                    },\n                  }),\n              ]\n            ),\n          ]\n        );\n      })\n    )\n  )\n);\n```\n\ntable-body 和 table-header 的思路相似，也是利用 tr、td、tbody 这些原生标签实现 dom 的构建\n\n```jsx\n// tbody的render实现\nreturn h(\"tbody\", { tabIndex: -1 }, [\n  data.reduce((acc: VNode[], row) => {\n    return acc.concat(wrappedRowRender(row, acc.length));\n  }, []),\n]);\n```\n\n```jsx\n// tfoot标签的render实现\nreturn h(\n      h('tfoot', [\n        h('tr', {}, [\n          ...columns.map((column, cellIndex) =>\n            h(\n              'td',\n              {\n                key: cellIndex,\n                colspan: column.colSpan,\n                rowspan: column.rowSpan,\n                class: getCellClasses(columns, cellIndex),\n                style: getCellStyles(column, cellIndex),\n              },\n              [\n                h(\n                  'div',\n                  {\n                    class: ['cell', column.labelClassName],\n                  },\n                  [sums[cellIndex]]\n                ),\n              ]\n            )\n          ),\n        ]),\n      ])\n```\n\n# 可以借鉴的一些做法\n\n- Style：和样式相关的内容，放在同一个文件内，如 styles-helper.ts，避免样式失效，要注意 style 行内样式顺序，classnames 的合并注意同名 class\n- Events：emit 事件放在 events-hepler.ts\n- 将不同的渲染内容区分开：如 table 的 footer、header、column 等等，都是作为单独 render 的组件聚合到一起\n- Provider 和 Inject 的 key 用 symbol 修饰，并且使用常量命名，注意，使用 ts 类型断言的 as const\n- 是否需要使用 store，看组件的复杂程度，element-UI 中的 Table 和 Form 均使用了 store，store 会增加组件的复杂度，谨慎使用\n- Vue3 版本中推荐使用 hooks 抽象逻辑\n- 单元测试：开发组件一定要加入单元测试，目的是为了发现组件设计的盲点和不合理的地方，甚至是内存管理问题。\n\n# 最后，附上 Element-UI 的仓库地址和文档地址\n\n[Element-UI 文档](https://element-plus.org/zh-CN/component/form.html)\n\n[Element-Git 仓库](https://github.com/element-plus/element-plus/tree/dev/packages)\n","source":"_posts/Element-UI组件解析.md","raw":"---\ntitle: Element-UI组件解析\n---\n\n<aside>\n💡 组件上层封装基本上都是基于已有的UI组件库或者是结合一些前端框架开进行的，如利用ElementUI或者antd进行二次开发，利用Vue/React等前端框架，结合一下UI库如TailwindCSS进行UI修饰，完成封装\n\n</aside>\n\nElementUI：Form 组件拆解\n\n<aside>\n💡 Form组件一直是各大UI框架的重头戏，以ElementUI为例，看看Form组件是如何设计的。\n\n</aside>\n\n先来看看 ElementUI 的 Form 组件是如何使用的\n\n```html\n<el-form :model=\"form\" label-width=\"auto\" style=\"max-width: 600px\">\n  <el-form-item label=\"Activity name\" props=\"name\">\n    <el-input v-model=\"form.name\" />\n  </el-form-item>\n</el-form>\n```\n\nel-form 组件作为最外层包裹的标签，model 属性是整个 form 组件传入的对象，内部的 form-item 包裹了具体组件内容，作为每个 form 组件的具体表现形式，在 form-item 标签上的属性 props 则是接收 form 传入的 model 对象的属性值，不需要在 input 上指定 v-model，即可更新 form.name 的值，那么这里面是怎么做的呢。\n\n```html\n<--! Form组件 -->\n<template>\n  <form :class=\"formClasses\">\n    <slot />\n  </form>\n</template>\n```\n\n上面的 Form 组件能看到，ElementUI 的 Form 组件是用的 html 原声的 form 标签实现的，传入一个 formClasses 覆盖原声的 class 样式\n\nForm 组件用了 provide/inject 依赖注入的方式传递深层次属性，首先进行 provide 依赖收集\n\n```tsx\nprovide(\n  formContextKey,\n  reactive({\n    ...toRefs(props),\n    emit,\n\n    resetFields,\n    clearValidate,\n    validateField,\n    getField,\n    addField,\n    removeField,\n\n    ...useFormLabelWidth(),\n  })\n)\n这里的formContextKey是一个常量，用symbol修饰的变量\nexport const formContextKey: InjectionKey<FormContext> =\n  Symbol('formContextKey')\nexport const formItemContextKey: InjectionKey<FormItemContext> =\n  Symbol('formItemContextKey')\n```\n\n上面的 emit 是 form 组件导出的方法：validate，以及 resetField 之类的都是 form 全局方法，通过 form 全局依赖注入到 formContextKey 上，具体使用场景举个例子：\n\n```tsx\nconst formRef = ref(); // 赋值给Form组件的ref属性变量\n\nformRef.validate();\nformRef.resetFields();\n\n// 这里的formRef是赋值给elForm组件的ref变量，使用的就是Form组件导出的全局变量\n```\n\nForm 组件完成了一些全局方法的注册，外层 props 的定义，以及顶层 form 标签的构建，那么 formItem 是如何接收这些属性的呢：inject\n\n```tsx\nconst formContext = inject(formContextKey, undefined);\nconst parentFormItemContext = inject(formItemContextKey, undefined);\n// formContext就是从Form组件传入的属性内容\n// 将Form组件的属性model的数据获取之后，返回对应的value，用于在formItem中进行表单校验等处理\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\n// 这里获取的propString就是在formItem标签上的属性prop的内容，表示获取每个formItem的字段\nconst propString = computed(() => {\n  if (!props.prop) return \"\";\n  return isString(props.prop) ? props.prop : props.prop.join(\".\");\n});\n\n// 对每个formItem上的prop属性进行表单检验处理\nconst doValidate = async (rules: RuleItem[]): Promise<true> => {\n  const modelName = propString.value;\n  const validator = new AsyncValidator({\n    [modelName]: rules,\n  });\n  return validator\n    .validate({ [modelName]: fieldValue.value }, { firstFields: true })\n    .then(() => {\n      onValidationSucceeded();\n      return true as const;\n    })\n    .catch((err: FormValidateFailure) => {\n      onValidationFailed(err as FormValidateFailure);\n      return Promise.reject(err);\n    });\n};\n```\n\n这里有个问题，如何将 formItem 下的组件的值赋值给 model.prop 的属性上\n\n```tsx\n// 这里model.prop会将值作为fieldValue的默认值\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\ninitialValue = clone(fieldValue.value);\n\n// 那么在input等组件的值发生改变的时候，formItem又是如何监听到值的变化并且完成model.prop的更新的呢\n// 这里用computed计算属性，返回model.prop的值，而在input等组件上使用v-model对model.prop实现数据的双向绑定\n// 因此formItem下的input等组件必须要显示的将model.prop双向绑定上\nconst fieldValue = computed(() => {\n  const model = formContext?.model;\n  if (!model || !props.prop) {\n    return;\n  }\n  return getProp(model, props.prop).value;\n});\n\n// 此外，input组件会传入form属性，这个form属性的值就是从Form组件全局导出的，用于确定form表单下的id对应值\n// 同一个id对应的表单项会互相关联\n```\n\n```html\n<input :id=\"inputId\" :form=\"form\" />\n\nconst { form: elForm, formItem: elFormItem } = useFormItem() <--!\n这里的inputId和Form导出的是同一个实例 -->\n```\n\n<aside>\n💡 总结：Form和FormItem之间的数据传递是用的provide和inject，FormItem组件下的input等组件的数据双向绑定则是借助了form属性和id属性，封装了formItemHooks用于组件内部调用以使用Form和FormItem这两个全局变量，所有的全局方法以defineExpose的形式导出\n\n</aside>\n\nElementUI：Table 组件\n\n<aside>\n💡 Table组件的难点主要在表格宽高自适应，固定行和列，多级表格的样式，是比Form组件的设计难度更加大的存在\n\n</aside>\n\nTable 组件导出了两个组件模块：Table 和 TableColumn，先来看看 Table 组件的设计\n\n整个 Table 组件的 template 部分分为两个区域，整个组件由外层的 tableWrapper 包裹，tableWrapper 外层布局融合了传入的 style 和 class 属性，规定了 table 整体的布局，这些 style 和 class 以命名空间的形式动态的加载到 class 中\n\ntable 的核心分为：原生 table 包裹，table-header 组件，table-body，table-footer\n\n其中，bodyWrapper 下使用了 scrollbar 组件包裹，目的是解决表格超出当前页面高度时，出现滚动条\n\n```html\n<div ref=\"bodyWrapper\" :class=\"ns.e('body-wrapper')\">\n  <el-scrollbar\n    ref=\"scrollBarRef\"\n    :view-style=\"scrollbarViewStyle\"\n    :wrap-style=\"scrollbarStyle\"\n    :always=\"scrollbarAlwaysOn\"\n  >\n    <table\n      ref=\"tableBody\"\n      :class=\"ns.e('body')\"\n      cellspacing=\"0\"\n      cellpadding=\"0\"\n      border=\"0\"\n      :style=\"{\n              width: bodyWidth,\n              tableLayout,\n            }\"\n    >\n      <hColgroup\n        :columns=\"store.states.columns.value\"\n        :table-layout=\"tableLayout\"\n      />\n      <table-header\n        v-if=\"showHeader && tableLayout === 'auto'\"\n        ref=\"tableHeaderRef\"\n        :class=\"ns.e('body-header')\"\n        :border=\"border\"\n        :default-sort=\"defaultSort\"\n        :store=\"store\"\n        @set-drag-visible=\"setDragVisible\"\n      />\n      <table-body\n        :context=\"context\"\n        :highlight=\"highlightCurrentRow\"\n        :row-class-name=\"rowClassName\"\n        :tooltip-effect=\"tooltipEffect\"\n        :tooltip-options=\"tooltipOptions\"\n        :row-style=\"rowStyle\"\n        :store=\"store\"\n        :stripe=\"stripe\"\n      />\n      <table-footer\n        v-if=\"showSummary && tableLayout === 'auto'\"\n        :class=\"ns.e('body-footer')\"\n        :border=\"border\"\n        :default-sort=\"defaultSort\"\n        :store=\"store\"\n        :sum-text=\"computedSumText\"\n        :summary-method=\"summaryMethod\"\n      />\n    </table>\n    <div\n      v-if=\"isEmpty\"\n      ref=\"emptyBlock\"\n      :style=\"emptyBlockStyle\"\n      :class=\"ns.e('empty-block')\"\n    >\n      <span :class=\"ns.e('empty-text')\">\n        <slot name=\"empty\">{{ computedEmptyText }}</slot>\n      </span>\n    </div>\n    <div\n      v-if=\"$slots.append\"\n      ref=\"appendWrapper\"\n      :class=\"ns.e('append-wrapper')\"\n    >\n      <slot name=\"append\" />\n    </div>\n  </el-scrollbar>\n</div>\n```\n\ntable-footer 是为了显示什么内容呢，上图能看到 showSummary，当需要显示表格总计的情况时，就在 table-footer 上显示\n\n一个一个分析 Table 组件，从 table-header 开始\n\ntable-header 是用的 h()方法渲染的 UI，导出的是一个含有 setup 方法并且返回用 h 函数渲染的 dom 结构，具体设计如下\n\n```jsx\nreturn h(\n  \"thead\",\n  {\n    class: { [ns.is(\"group\")]: isGroup },\n  },\n  columnRows.map((subColumns, rowIndex) =>\n    h(\n      \"tr\",\n      {\n        class: getHeaderRowClass(rowIndex),\n        key: rowIndex,\n        style: getHeaderRowStyle(rowIndex),\n      },\n      subColumns.map((column, cellIndex) => {\n        if (column.rowSpan > rowSpan) {\n          rowSpan = column.rowSpan;\n        }\n        return h(\n          \"th\",\n          {\n            class: getHeaderCellClass(rowIndex, cellIndex, subColumns, column),\n            colspan: column.colSpan,\n            key: `${column.id}-thead`,\n            rowspan: column.rowSpan,\n            style: getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),\n            onClick: ($event) => handleHeaderClick($event, column),\n            onContextmenu: ($event) => handleHeaderContextMenu($event, column),\n            onMousedown: ($event) => handleMouseDown($event, column),\n            onMousemove: ($event) => handleMouseMove($event, column),\n            onMouseout: handleMouseOut,\n          },\n          [\n            h(\n              \"div\",\n              {\n                class: [\n                  \"cell\",\n                  column.filteredValue && column.filteredValue.length > 0\n                    ? \"highlight\"\n                    : \"\",\n                ],\n              },\n              [\n                column.renderHeader\n                  ? column.renderHeader({\n                      column,\n                      $index: cellIndex,\n                      store,\n                      _self: $parent,\n                    })\n                  : column.label,\n                column.sortable &&\n                  h(\n                    \"span\",\n                    {\n                      onClick: ($event) => handleSortClick($event, column),\n                      class: \"caret-wrapper\",\n                    },\n                    [\n                      h(\"i\", {\n                        onClick: ($event) =>\n                          handleSortClick($event, column, \"ascending\"),\n                        class: \"sort-caret ascending\",\n                      }),\n                      h(\"i\", {\n                        onClick: ($event) =>\n                          handleSortClick($event, column, \"descending\"),\n                        class: \"sort-caret descending\",\n                      }),\n                    ]\n                  ),\n                column.filterable &&\n                  h(FilterPanel, {\n                    store,\n                    placement: column.filterPlacement || \"bottom-start\",\n                    column,\n                    upDataColumn: (key, value) => {\n                      column[key] = value;\n                    },\n                  }),\n              ]\n            ),\n          ]\n        );\n      })\n    )\n  )\n);\n```\n\ntable-body 和 table-header 的思路相似，也是利用 tr、td、tbody 这些原生标签实现 dom 的构建\n\n```jsx\n// tbody的render实现\nreturn h(\"tbody\", { tabIndex: -1 }, [\n  data.reduce((acc: VNode[], row) => {\n    return acc.concat(wrappedRowRender(row, acc.length));\n  }, []),\n]);\n```\n\n```jsx\n// tfoot标签的render实现\nreturn h(\n      h('tfoot', [\n        h('tr', {}, [\n          ...columns.map((column, cellIndex) =>\n            h(\n              'td',\n              {\n                key: cellIndex,\n                colspan: column.colSpan,\n                rowspan: column.rowSpan,\n                class: getCellClasses(columns, cellIndex),\n                style: getCellStyles(column, cellIndex),\n              },\n              [\n                h(\n                  'div',\n                  {\n                    class: ['cell', column.labelClassName],\n                  },\n                  [sums[cellIndex]]\n                ),\n              ]\n            )\n          ),\n        ]),\n      ])\n```\n\n# 可以借鉴的一些做法\n\n- Style：和样式相关的内容，放在同一个文件内，如 styles-helper.ts，避免样式失效，要注意 style 行内样式顺序，classnames 的合并注意同名 class\n- Events：emit 事件放在 events-hepler.ts\n- 将不同的渲染内容区分开：如 table 的 footer、header、column 等等，都是作为单独 render 的组件聚合到一起\n- Provider 和 Inject 的 key 用 symbol 修饰，并且使用常量命名，注意，使用 ts 类型断言的 as const\n- 是否需要使用 store，看组件的复杂程度，element-UI 中的 Table 和 Form 均使用了 store，store 会增加组件的复杂度，谨慎使用\n- Vue3 版本中推荐使用 hooks 抽象逻辑\n- 单元测试：开发组件一定要加入单元测试，目的是为了发现组件设计的盲点和不合理的地方，甚至是内存管理问题。\n\n# 最后，附上 Element-UI 的仓库地址和文档地址\n\n[Element-UI 文档](https://element-plus.org/zh-CN/component/form.html)\n\n[Element-Git 仓库](https://github.com/element-plus/element-plus/tree/dev/packages)\n","slug":"Element-UI组件解析","published":1,"date":"2024-05-19T13:34:38.793Z","updated":"2024-05-19T13:35:20.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrq00043jf00ogagz7u","content":"<aside>\n💡 组件上层封装基本上都是基于已有的UI组件库或者是结合一些前端框架开进行的，如利用ElementUI或者antd进行二次开发，利用Vue/React等前端框架，结合一下UI库如TailwindCSS进行UI修饰，完成封装\n\n</aside>\n\n<p>ElementUI：Form 组件拆解</p>\n<aside>\n💡 Form组件一直是各大UI框架的重头戏，以ElementUI为例，看看Form组件是如何设计的。\n\n</aside>\n\n<p>先来看看 ElementUI 的 Form 组件是如何使用的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">el-form</span> <span class=\"attr\">:model</span>=<span class=\"string\">&quot;form&quot;</span> <span class=\"attr\">label-width</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;max-width: 600px&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">el-form-item</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;Activity name&quot;</span> <span class=\"attr\">props</span>=<span class=\"string\">&quot;name&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;form.name&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">el-form-item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>el-form 组件作为最外层包裹的标签，model 属性是整个 form 组件传入的对象，内部的 form-item 包裹了具体组件内容，作为每个 form 组件的具体表现形式，在 form-item 标签上的属性 props 则是接收 form 传入的 model 对象的属性值，不需要在 input 上指定 v-model，即可更新 form.name 的值，那么这里面是怎么做的呢。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--! Form组件 --&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;formClasses&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的 Form 组件能看到，ElementUI 的 Form 组件是用的 html 原声的 form 标签实现的，传入一个 formClasses 覆盖原声的 class 样式</p>\n<p>Form 组件用了 provide&#x2F;inject 依赖注入的方式传递深层次属性，首先进行 provide 依赖收集</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">provide</span>(</span><br><span class=\"line\">  formContextKey,</span><br><span class=\"line\">  <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">toRefs</span>(props),</span><br><span class=\"line\">    emit,</span><br><span class=\"line\"></span><br><span class=\"line\">    resetFields,</span><br><span class=\"line\">    clearValidate,</span><br><span class=\"line\">    validateField,</span><br><span class=\"line\">    getField,</span><br><span class=\"line\">    addField,</span><br><span class=\"line\">    removeField,</span><br><span class=\"line\"></span><br><span class=\"line\">    ...<span class=\"title function_\">useFormLabelWidth</span>(),</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\">这里的formContextKey是一个常量，用<span class=\"built_in\">symbol</span>修饰的变量</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">formContextKey</span>: <span class=\"title class_\">InjectionKey</span>&lt;<span class=\"title class_\">FormContext</span>&gt; =</span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;formContextKey&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">formItemContextKey</span>: <span class=\"title class_\">InjectionKey</span>&lt;<span class=\"title class_\">FormItemContext</span>&gt; =</span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;formItemContextKey&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面的 emit 是 form 组件导出的方法：validate，以及 resetField 之类的都是 form 全局方法，通过 form 全局依赖注入到 formContextKey 上，具体使用场景举个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> formRef = <span class=\"title function_\">ref</span>(); <span class=\"comment\">// 赋值给Form组件的ref属性变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">formRef.<span class=\"title function_\">validate</span>();</span><br><span class=\"line\">formRef.<span class=\"title function_\">resetFields</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的formRef是赋值给elForm组件的ref变量，使用的就是Form组件导出的全局变量</span></span><br></pre></td></tr></table></figure>\n\n<p>Form 组件完成了一些全局方法的注册，外层 props 的定义，以及顶层 form 标签的构建，那么 formItem 是如何接收这些属性的呢：inject</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> formContext = <span class=\"title function_\">inject</span>(formContextKey, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> parentFormItemContext = <span class=\"title function_\">inject</span>(formItemContextKey, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"comment\">// formContext就是从Form组件传入的属性内容</span></span><br><span class=\"line\"><span class=\"comment\">// 将Form组件的属性model的数据获取之后，返回对应的value，用于在formItem中进行表单校验等处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里获取的propString就是在formItem标签上的属性prop的内容，表示获取每个formItem的字段</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> propString = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!props.<span class=\"property\">prop</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isString</span>(props.<span class=\"property\">prop</span>) ? props.<span class=\"property\">prop</span> : props.<span class=\"property\">prop</span>.<span class=\"title function_\">join</span>(<span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对每个formItem上的prop属性进行表单检验处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doValidate = <span class=\"keyword\">async</span> (<span class=\"attr\">rules</span>: <span class=\"title class_\">RuleItem</span>[]): <span class=\"title class_\">Promise</span>&lt;<span class=\"literal\">true</span>&gt; =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> modelName = propString.<span class=\"property\">value</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncValidator</span>(&#123;</span><br><span class=\"line\">    [modelName]: rules,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> validator</span><br><span class=\"line\">    .<span class=\"title function_\">validate</span>(&#123; [modelName]: fieldValue.<span class=\"property\">value</span> &#125;, &#123; <span class=\"attr\">firstFields</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onValidationSucceeded</span>();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err: FormValidateFailure</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onValidationFailed</span>(err <span class=\"keyword\">as</span> <span class=\"title class_\">FormValidateFailure</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个问题，如何将 formItem 下的组件的值赋值给 model.prop 的属性上</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里model.prop会将值作为fieldValue的默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">initialValue = <span class=\"title function_\">clone</span>(fieldValue.<span class=\"property\">value</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么在input等组件的值发生改变的时候，formItem又是如何监听到值的变化并且完成model.prop的更新的呢</span></span><br><span class=\"line\"><span class=\"comment\">// 这里用computed计算属性，返回model.prop的值，而在input等组件上使用v-model对model.prop实现数据的双向绑定</span></span><br><span class=\"line\"><span class=\"comment\">// 因此formItem下的input等组件必须要显示的将model.prop双向绑定上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此外，input组件会传入form属性，这个form属性的值就是从Form组件全局导出的，用于确定form表单下的id对应值</span></span><br><span class=\"line\"><span class=\"comment\">// 同一个id对应的表单项会互相关联</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">:id</span>=<span class=\"string\">&quot;inputId&quot;</span> <span class=\"attr\">:form</span>=<span class=\"string\">&quot;form&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; form: elForm, formItem: elFormItem &#125; = useFormItem() &lt;--!</span><br><span class=\"line\">这里的inputId和Form导出的是同一个实例 --&gt;</span><br></pre></td></tr></table></figure>\n\n<aside>\n💡 总结：Form和FormItem之间的数据传递是用的provide和inject，FormItem组件下的input等组件的数据双向绑定则是借助了form属性和id属性，封装了formItemHooks用于组件内部调用以使用Form和FormItem这两个全局变量，所有的全局方法以defineExpose的形式导出\n\n</aside>\n\n<p>ElementUI：Table 组件</p>\n<aside>\n💡 Table组件的难点主要在表格宽高自适应，固定行和列，多级表格的样式，是比Form组件的设计难度更加大的存在\n\n</aside>\n\n<p>Table 组件导出了两个组件模块：Table 和 TableColumn，先来看看 Table 组件的设计</p>\n<p>整个 Table 组件的 template 部分分为两个区域，整个组件由外层的 tableWrapper 包裹，tableWrapper 外层布局融合了传入的 style 和 class 属性，规定了 table 整体的布局，这些 style 和 class 以命名空间的形式动态的加载到 class 中</p>\n<p>table 的核心分为：原生 table 包裹，table-header 组件，table-body，table-footer</p>\n<p>其中，bodyWrapper 下使用了 scrollbar 组件包裹，目的是解决表格超出当前页面高度时，出现滚动条</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bodyWrapper&quot;</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-wrapper&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">el-scrollbar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">ref</span>=<span class=\"string\">&quot;scrollBarRef&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:view-style</span>=<span class=\"string\">&quot;scrollbarViewStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:wrap-style</span>=<span class=\"string\">&quot;scrollbarStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:always</span>=<span class=\"string\">&quot;scrollbarAlwaysOn&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;tableBody&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">cellspacing</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">cellpadding</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">border</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:style</span>=<span class=\"string\">&quot;&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">              width: bodyWidth,</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">              tableLayout,</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">            &#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">hColgroup</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:columns</span>=<span class=\"string\">&quot;store.states.columns.value&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:table-layout</span>=<span class=\"string\">&quot;tableLayout&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-header</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;showHeader &amp;&amp; tableLayout === &#x27;auto&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">ref</span>=<span class=\"string\">&quot;tableHeaderRef&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-header&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:border</span>=<span class=\"string\">&quot;border&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:default-sort</span>=<span class=\"string\">&quot;defaultSort&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        @<span class=\"attr\">set-drag-visible</span>=<span class=\"string\">&quot;setDragVisible&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-body</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:context</span>=<span class=\"string\">&quot;context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:highlight</span>=<span class=\"string\">&quot;highlightCurrentRow&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:row-class-name</span>=<span class=\"string\">&quot;rowClassName&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:tooltip-effect</span>=<span class=\"string\">&quot;tooltipEffect&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:tooltip-options</span>=<span class=\"string\">&quot;tooltipOptions&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:row-style</span>=<span class=\"string\">&quot;rowStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:stripe</span>=<span class=\"string\">&quot;stripe&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-footer</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;showSummary &amp;&amp; tableLayout === &#x27;auto&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-footer&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:border</span>=<span class=\"string\">&quot;border&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:default-sort</span>=<span class=\"string\">&quot;defaultSort&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:sum-text</span>=<span class=\"string\">&quot;computedSumText&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:summary-method</span>=<span class=\"string\">&quot;summaryMethod&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;isEmpty&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;emptyBlock&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:style</span>=<span class=\"string\">&quot;emptyBlockStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;empty-block&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;empty-text&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;empty&quot;</span>&gt;</span>&#123;&#123; computedEmptyText &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;$slots.append&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;appendWrapper&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;append-wrapper&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;append&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">el-scrollbar</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>table-footer 是为了显示什么内容呢，上图能看到 showSummary，当需要显示表格总计的情况时，就在 table-footer 上显示</p>\n<p>一个一个分析 Table 组件，从 table-header 开始</p>\n<p>table-header 是用的 h()方法渲染的 UI，导出的是一个含有 setup 方法并且返回用 h 函数渲染的 dom 结构，具体设计如下</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;thead&quot;</span>,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">class</span>: &#123; [ns.<span class=\"title function_\">is</span>(<span class=\"string\">&quot;group&quot;</span>)]: isGroup &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  columnRows.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">subColumns, rowIndex</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">h</span>(</span><br><span class=\"line\">      <span class=\"string\">&quot;tr&quot;</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">class</span>: <span class=\"title function_\">getHeaderRowClass</span>(rowIndex),</span><br><span class=\"line\">        <span class=\"attr\">key</span>: rowIndex,</span><br><span class=\"line\">        <span class=\"attr\">style</span>: <span class=\"title function_\">getHeaderRowStyle</span>(rowIndex),</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      subColumns.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">column, cellIndex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (column.<span class=\"property\">rowSpan</span> &gt; rowSpan) &#123;</span><br><span class=\"line\">          rowSpan = column.<span class=\"property\">rowSpan</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">          <span class=\"string\">&quot;th&quot;</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">class</span>: <span class=\"title function_\">getHeaderCellClass</span>(rowIndex, cellIndex, subColumns, column),</span><br><span class=\"line\">            <span class=\"attr\">colspan</span>: column.<span class=\"property\">colSpan</span>,</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">`<span class=\"subst\">$&#123;column.id&#125;</span>-thead`</span>,</span><br><span class=\"line\">            <span class=\"attr\">rowspan</span>: column.<span class=\"property\">rowSpan</span>,</span><br><span class=\"line\">            <span class=\"attr\">style</span>: <span class=\"title function_\">getHeaderCellStyle</span>(rowIndex, cellIndex, subColumns, column),</span><br><span class=\"line\">            <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleHeaderClick</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onContextmenu</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleHeaderContextMenu</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMousedown</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleMouseDown</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMousemove</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleMouseMove</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMouseout</span>: handleMouseOut,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          [</span><br><span class=\"line\">            <span class=\"title function_\">h</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"attr\">class</span>: [</span><br><span class=\"line\">                  <span class=\"string\">&quot;cell&quot;</span>,</span><br><span class=\"line\">                  column.<span class=\"property\">filteredValue</span> &amp;&amp; column.<span class=\"property\">filteredValue</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                    ? <span class=\"string\">&quot;highlight&quot;</span></span><br><span class=\"line\">                    : <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              [</span><br><span class=\"line\">                column.<span class=\"property\">renderHeader</span></span><br><span class=\"line\">                  ? column.<span class=\"title function_\">renderHeader</span>(&#123;</span><br><span class=\"line\">                      column,</span><br><span class=\"line\">                      <span class=\"attr\">$index</span>: cellIndex,</span><br><span class=\"line\">                      store,</span><br><span class=\"line\">                      <span class=\"attr\">_self</span>: $parent,</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  : column.<span class=\"property\">label</span>,</span><br><span class=\"line\">                column.<span class=\"property\">sortable</span> &amp;&amp;</span><br><span class=\"line\">                  <span class=\"title function_\">h</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;span&quot;</span>,</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleSortClick</span>($event, column),</span><br><span class=\"line\">                      <span class=\"attr\">class</span>: <span class=\"string\">&quot;caret-wrapper&quot;</span>,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    [</span><br><span class=\"line\">                      <span class=\"title function_\">h</span>(<span class=\"string\">&quot;i&quot;</span>, &#123;</span><br><span class=\"line\">                        <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span></span><br><span class=\"line\">                          <span class=\"title function_\">handleSortClick</span>($event, column, <span class=\"string\">&quot;ascending&quot;</span>),</span><br><span class=\"line\">                        <span class=\"attr\">class</span>: <span class=\"string\">&quot;sort-caret ascending&quot;</span>,</span><br><span class=\"line\">                      &#125;),</span><br><span class=\"line\">                      <span class=\"title function_\">h</span>(<span class=\"string\">&quot;i&quot;</span>, &#123;</span><br><span class=\"line\">                        <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span></span><br><span class=\"line\">                          <span class=\"title function_\">handleSortClick</span>($event, column, <span class=\"string\">&quot;descending&quot;</span>),</span><br><span class=\"line\">                        <span class=\"attr\">class</span>: <span class=\"string\">&quot;sort-caret descending&quot;</span>,</span><br><span class=\"line\">                      &#125;),</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                  ),</span><br><span class=\"line\">                column.<span class=\"property\">filterable</span> &amp;&amp;</span><br><span class=\"line\">                  <span class=\"title function_\">h</span>(<span class=\"title class_\">FilterPanel</span>, &#123;</span><br><span class=\"line\">                    store,</span><br><span class=\"line\">                    <span class=\"attr\">placement</span>: column.<span class=\"property\">filterPlacement</span> || <span class=\"string\">&quot;bottom-start&quot;</span>,</span><br><span class=\"line\">                    column,</span><br><span class=\"line\">                    <span class=\"attr\">upDataColumn</span>: <span class=\"function\">(<span class=\"params\">key, value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                      column[key] = value;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                  &#125;),</span><br><span class=\"line\">              ]</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>table-body 和 table-header 的思路相似，也是利用 tr、td、tbody 这些原生标签实现 dom 的构建</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tbody的render实现</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(<span class=\"string\">&quot;tbody&quot;</span>, &#123; <span class=\"attr\">tabIndex</span>: -<span class=\"number\">1</span> &#125;, [</span><br><span class=\"line\">  data.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">acc: VNode[], row</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc.<span class=\"title function_\">concat</span>(<span class=\"title function_\">wrappedRowRender</span>(row, acc.<span class=\"property\">length</span>));</span><br><span class=\"line\">  &#125;, []),</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tfoot标签的render实现</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">      <span class=\"title function_\">h</span>(<span class=\"string\">&#x27;tfoot&#x27;</span>, [</span><br><span class=\"line\">        <span class=\"title function_\">h</span>(<span class=\"string\">&#x27;tr&#x27;</span>, &#123;&#125;, [</span><br><span class=\"line\">          ...columns.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">column, cellIndex</span>) =&gt;</span></span><br><span class=\"line\">            <span class=\"title function_\">h</span>(</span><br><span class=\"line\">              <span class=\"string\">&#x27;td&#x27;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"attr\">key</span>: cellIndex,</span><br><span class=\"line\">                <span class=\"attr\">colspan</span>: column.<span class=\"property\">colSpan</span>,</span><br><span class=\"line\">                <span class=\"attr\">rowspan</span>: column.<span class=\"property\">rowSpan</span>,</span><br><span class=\"line\">                <span class=\"attr\">class</span>: <span class=\"title function_\">getCellClasses</span>(columns, cellIndex),</span><br><span class=\"line\">                <span class=\"attr\">style</span>: <span class=\"title function_\">getCellStyles</span>(column, cellIndex),</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              [</span><br><span class=\"line\">                <span class=\"title function_\">h</span>(</span><br><span class=\"line\">                  <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    <span class=\"attr\">class</span>: [<span class=\"string\">&#x27;cell&#x27;</span>, column.<span class=\"property\">labelClassName</span>],</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  [sums[cellIndex]]</span><br><span class=\"line\">                ),</span><br><span class=\"line\">              ]</span><br><span class=\"line\">            )</span><br><span class=\"line\">          ),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      ])</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可以借鉴的一些做法\"><a href=\"#可以借鉴的一些做法\" class=\"headerlink\" title=\"可以借鉴的一些做法\"></a>可以借鉴的一些做法</h1><ul>\n<li>Style：和样式相关的内容，放在同一个文件内，如 styles-helper.ts，避免样式失效，要注意 style 行内样式顺序，classnames 的合并注意同名 class</li>\n<li>Events：emit 事件放在 events-hepler.ts</li>\n<li>将不同的渲染内容区分开：如 table 的 footer、header、column 等等，都是作为单独 render 的组件聚合到一起</li>\n<li>Provider 和 Inject 的 key 用 symbol 修饰，并且使用常量命名，注意，使用 ts 类型断言的 as const</li>\n<li>是否需要使用 store，看组件的复杂程度，element-UI 中的 Table 和 Form 均使用了 store，store 会增加组件的复杂度，谨慎使用</li>\n<li>Vue3 版本中推荐使用 hooks 抽象逻辑</li>\n<li>单元测试：开发组件一定要加入单元测试，目的是为了发现组件设计的盲点和不合理的地方，甚至是内存管理问题。</li>\n</ul>\n<h1 id=\"最后，附上-Element-UI-的仓库地址和文档地址\"><a href=\"#最后，附上-Element-UI-的仓库地址和文档地址\" class=\"headerlink\" title=\"最后，附上 Element-UI 的仓库地址和文档地址\"></a>最后，附上 Element-UI 的仓库地址和文档地址</h1><p><a class=\"link\"   href=\"https://element-plus.org/zh-CN/component/form.html\" >Element-UI 文档<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://github.com/element-plus/element-plus/tree/dev/packages\" >Element-Git 仓库<i class=\"fas fa-external-link-alt\"></i></a></p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<aside>\n💡 组件上层封装基本上都是基于已有的UI组件库或者是结合一些前端框架开进行的，如利用ElementUI或者antd进行二次开发，利用Vue/React等前端框架，结合一下UI库如TailwindCSS进行UI修饰，完成封装\n\n</aside>\n\n<p>ElementUI：Form 组件拆解</p>\n<aside>\n💡 Form组件一直是各大UI框架的重头戏，以ElementUI为例，看看Form组件是如何设计的。\n\n</aside>\n\n<p>先来看看 ElementUI 的 Form 组件是如何使用的</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">el-form</span> <span class=\"attr\">:model</span>=<span class=\"string\">&quot;form&quot;</span> <span class=\"attr\">label-width</span>=<span class=\"string\">&quot;auto&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&quot;max-width: 600px&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">el-form-item</span> <span class=\"attr\">label</span>=<span class=\"string\">&quot;Activity name&quot;</span> <span class=\"attr\">props</span>=<span class=\"string\">&quot;name&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">el-input</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;form.name&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">el-form-item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>el-form 组件作为最外层包裹的标签，model 属性是整个 form 组件传入的对象，内部的 form-item 包裹了具体组件内容，作为每个 form 组件的具体表现形式，在 form-item 标签上的属性 props 则是接收 form 传入的 model 对象的属性值，不需要在 input 上指定 v-model，即可更新 form.name 的值，那么这里面是怎么做的呢。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;--! Form组件 --&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;formClasses&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slot</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的 Form 组件能看到，ElementUI 的 Form 组件是用的 html 原声的 form 标签实现的，传入一个 formClasses 覆盖原声的 class 样式</p>\n<p>Form 组件用了 provide&#x2F;inject 依赖注入的方式传递深层次属性，首先进行 provide 依赖收集</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">provide</span>(</span><br><span class=\"line\">  formContextKey,</span><br><span class=\"line\">  <span class=\"title function_\">reactive</span>(&#123;</span><br><span class=\"line\">    ...<span class=\"title function_\">toRefs</span>(props),</span><br><span class=\"line\">    emit,</span><br><span class=\"line\"></span><br><span class=\"line\">    resetFields,</span><br><span class=\"line\">    clearValidate,</span><br><span class=\"line\">    validateField,</span><br><span class=\"line\">    getField,</span><br><span class=\"line\">    addField,</span><br><span class=\"line\">    removeField,</span><br><span class=\"line\"></span><br><span class=\"line\">    ...<span class=\"title function_\">useFormLabelWidth</span>(),</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\">这里的formContextKey是一个常量，用<span class=\"built_in\">symbol</span>修饰的变量</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">formContextKey</span>: <span class=\"title class_\">InjectionKey</span>&lt;<span class=\"title class_\">FormContext</span>&gt; =</span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;formContextKey&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">formItemContextKey</span>: <span class=\"title class_\">InjectionKey</span>&lt;<span class=\"title class_\">FormItemContext</span>&gt; =</span><br><span class=\"line\">  <span class=\"title class_\">Symbol</span>(<span class=\"string\">&#x27;formItemContextKey&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>上面的 emit 是 form 组件导出的方法：validate，以及 resetField 之类的都是 form 全局方法，通过 form 全局依赖注入到 formContextKey 上，具体使用场景举个例子：</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> formRef = <span class=\"title function_\">ref</span>(); <span class=\"comment\">// 赋值给Form组件的ref属性变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">formRef.<span class=\"title function_\">validate</span>();</span><br><span class=\"line\">formRef.<span class=\"title function_\">resetFields</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里的formRef是赋值给elForm组件的ref变量，使用的就是Form组件导出的全局变量</span></span><br></pre></td></tr></table></figure>\n\n<p>Form 组件完成了一些全局方法的注册，外层 props 的定义，以及顶层 form 标签的构建，那么 formItem 是如何接收这些属性的呢：inject</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> formContext = <span class=\"title function_\">inject</span>(formContextKey, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> parentFormItemContext = <span class=\"title function_\">inject</span>(formItemContextKey, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"comment\">// formContext就是从Form组件传入的属性内容</span></span><br><span class=\"line\"><span class=\"comment\">// 将Form组件的属性model的数据获取之后，返回对应的value，用于在formItem中进行表单校验等处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里获取的propString就是在formItem标签上的属性prop的内容，表示获取每个formItem的字段</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> propString = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!props.<span class=\"property\">prop</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">isString</span>(props.<span class=\"property\">prop</span>) ? props.<span class=\"property\">prop</span> : props.<span class=\"property\">prop</span>.<span class=\"title function_\">join</span>(<span class=\"string\">&quot;.&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对每个formItem上的prop属性进行表单检验处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> doValidate = <span class=\"keyword\">async</span> (<span class=\"attr\">rules</span>: <span class=\"title class_\">RuleItem</span>[]): <span class=\"title class_\">Promise</span>&lt;<span class=\"literal\">true</span>&gt; =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> modelName = propString.<span class=\"property\">value</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> validator = <span class=\"keyword\">new</span> <span class=\"title class_\">AsyncValidator</span>(&#123;</span><br><span class=\"line\">    [modelName]: rules,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> validator</span><br><span class=\"line\">    .<span class=\"title function_\">validate</span>(&#123; [modelName]: fieldValue.<span class=\"property\">value</span> &#125;, &#123; <span class=\"attr\">firstFields</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onValidationSucceeded</span>();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">as</span> <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">err: FormValidateFailure</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">onValidationFailed</span>(err <span class=\"keyword\">as</span> <span class=\"title class_\">FormValidateFailure</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(err);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里有个问题，如何将 formItem 下的组件的值赋值给 model.prop 的属性上</p>\n<figure class=\"highlight tsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里model.prop会将值作为fieldValue的默认值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">initialValue = <span class=\"title function_\">clone</span>(fieldValue.<span class=\"property\">value</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么在input等组件的值发生改变的时候，formItem又是如何监听到值的变化并且完成model.prop的更新的呢</span></span><br><span class=\"line\"><span class=\"comment\">// 这里用computed计算属性，返回model.prop的值，而在input等组件上使用v-model对model.prop实现数据的双向绑定</span></span><br><span class=\"line\"><span class=\"comment\">// 因此formItem下的input等组件必须要显示的将model.prop双向绑定上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fieldValue = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> model = formContext?.<span class=\"property\">model</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!model || !props.<span class=\"property\">prop</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">getProp</span>(model, props.<span class=\"property\">prop</span>).<span class=\"property\">value</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此外，input组件会传入form属性，这个form属性的值就是从Form组件全局导出的，用于确定form表单下的id对应值</span></span><br><span class=\"line\"><span class=\"comment\">// 同一个id对应的表单项会互相关联</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">:id</span>=<span class=\"string\">&quot;inputId&quot;</span> <span class=\"attr\">:form</span>=<span class=\"string\">&quot;form&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">const &#123; form: elForm, formItem: elFormItem &#125; = useFormItem() &lt;--!</span><br><span class=\"line\">这里的inputId和Form导出的是同一个实例 --&gt;</span><br></pre></td></tr></table></figure>\n\n<aside>\n💡 总结：Form和FormItem之间的数据传递是用的provide和inject，FormItem组件下的input等组件的数据双向绑定则是借助了form属性和id属性，封装了formItemHooks用于组件内部调用以使用Form和FormItem这两个全局变量，所有的全局方法以defineExpose的形式导出\n\n</aside>\n\n<p>ElementUI：Table 组件</p>\n<aside>\n💡 Table组件的难点主要在表格宽高自适应，固定行和列，多级表格的样式，是比Form组件的设计难度更加大的存在\n\n</aside>\n\n<p>Table 组件导出了两个组件模块：Table 和 TableColumn，先来看看 Table 组件的设计</p>\n<p>整个 Table 组件的 template 部分分为两个区域，整个组件由外层的 tableWrapper 包裹，tableWrapper 外层布局融合了传入的 style 和 class 属性，规定了 table 整体的布局，这些 style 和 class 以命名空间的形式动态的加载到 class 中</p>\n<p>table 的核心分为：原生 table 包裹，table-header 组件，table-body，table-footer</p>\n<p>其中，bodyWrapper 下使用了 scrollbar 组件包裹，目的是解决表格超出当前页面高度时，出现滚动条</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;bodyWrapper&quot;</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-wrapper&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">el-scrollbar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">ref</span>=<span class=\"string\">&quot;scrollBarRef&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:view-style</span>=<span class=\"string\">&quot;scrollbarViewStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:wrap-style</span>=<span class=\"string\">&quot;scrollbarStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">:always</span>=<span class=\"string\">&quot;scrollbarAlwaysOn&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">  &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">table</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;tableBody&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">cellspacing</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">cellpadding</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">border</span>=<span class=\"string\">&quot;0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:style</span>=<span class=\"string\">&quot;&#123;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">              width: bodyWidth,</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">              tableLayout,</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">            &#125;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">hColgroup</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:columns</span>=<span class=\"string\">&quot;store.states.columns.value&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:table-layout</span>=<span class=\"string\">&quot;tableLayout&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-header</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;showHeader &amp;&amp; tableLayout === &#x27;auto&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">ref</span>=<span class=\"string\">&quot;tableHeaderRef&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-header&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:border</span>=<span class=\"string\">&quot;border&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:default-sort</span>=<span class=\"string\">&quot;defaultSort&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        @<span class=\"attr\">set-drag-visible</span>=<span class=\"string\">&quot;setDragVisible&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-body</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:context</span>=<span class=\"string\">&quot;context&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:highlight</span>=<span class=\"string\">&quot;highlightCurrentRow&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:row-class-name</span>=<span class=\"string\">&quot;rowClassName&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:tooltip-effect</span>=<span class=\"string\">&quot;tooltipEffect&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:tooltip-options</span>=<span class=\"string\">&quot;tooltipOptions&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:row-style</span>=<span class=\"string\">&quot;rowStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:stripe</span>=<span class=\"string\">&quot;stripe&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">table-footer</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;showSummary &amp;&amp; tableLayout === &#x27;auto&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;body-footer&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:border</span>=<span class=\"string\">&quot;border&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:default-sort</span>=<span class=\"string\">&quot;defaultSort&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:store</span>=<span class=\"string\">&quot;store&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:sum-text</span>=<span class=\"string\">&quot;computedSumText&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">:summary-method</span>=<span class=\"string\">&quot;summaryMethod&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;isEmpty&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;emptyBlock&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:style</span>=<span class=\"string\">&quot;emptyBlockStyle&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;empty-block&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;empty-text&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;empty&quot;</span>&gt;</span>&#123;&#123; computedEmptyText &#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">v-if</span>=<span class=\"string\">&quot;$slots.append&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">ref</span>=<span class=\"string\">&quot;appendWrapper&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">:class</span>=<span class=\"string\">&quot;ns.e(&#x27;append-wrapper&#x27;)&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;append&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">el-scrollbar</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>table-footer 是为了显示什么内容呢，上图能看到 showSummary，当需要显示表格总计的情况时，就在 table-footer 上显示</p>\n<p>一个一个分析 Table 组件，从 table-header 开始</p>\n<p>table-header 是用的 h()方法渲染的 UI，导出的是一个含有 setup 方法并且返回用 h 函数渲染的 dom 结构，具体设计如下</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">  <span class=\"string\">&quot;thead&quot;</span>,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">class</span>: &#123; [ns.<span class=\"title function_\">is</span>(<span class=\"string\">&quot;group&quot;</span>)]: isGroup &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  columnRows.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">subColumns, rowIndex</span>) =&gt;</span></span><br><span class=\"line\">    <span class=\"title function_\">h</span>(</span><br><span class=\"line\">      <span class=\"string\">&quot;tr&quot;</span>,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"attr\">class</span>: <span class=\"title function_\">getHeaderRowClass</span>(rowIndex),</span><br><span class=\"line\">        <span class=\"attr\">key</span>: rowIndex,</span><br><span class=\"line\">        <span class=\"attr\">style</span>: <span class=\"title function_\">getHeaderRowStyle</span>(rowIndex),</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      subColumns.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">column, cellIndex</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (column.<span class=\"property\">rowSpan</span> &gt; rowSpan) &#123;</span><br><span class=\"line\">          rowSpan = column.<span class=\"property\">rowSpan</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">          <span class=\"string\">&quot;th&quot;</span>,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"attr\">class</span>: <span class=\"title function_\">getHeaderCellClass</span>(rowIndex, cellIndex, subColumns, column),</span><br><span class=\"line\">            <span class=\"attr\">colspan</span>: column.<span class=\"property\">colSpan</span>,</span><br><span class=\"line\">            <span class=\"attr\">key</span>: <span class=\"string\">`<span class=\"subst\">$&#123;column.id&#125;</span>-thead`</span>,</span><br><span class=\"line\">            <span class=\"attr\">rowspan</span>: column.<span class=\"property\">rowSpan</span>,</span><br><span class=\"line\">            <span class=\"attr\">style</span>: <span class=\"title function_\">getHeaderCellStyle</span>(rowIndex, cellIndex, subColumns, column),</span><br><span class=\"line\">            <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleHeaderClick</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onContextmenu</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleHeaderContextMenu</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMousedown</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleMouseDown</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMousemove</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleMouseMove</span>($event, column),</span><br><span class=\"line\">            <span class=\"attr\">onMouseout</span>: handleMouseOut,</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          [</span><br><span class=\"line\">            <span class=\"title function_\">h</span>(</span><br><span class=\"line\">              <span class=\"string\">&quot;div&quot;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"attr\">class</span>: [</span><br><span class=\"line\">                  <span class=\"string\">&quot;cell&quot;</span>,</span><br><span class=\"line\">                  column.<span class=\"property\">filteredValue</span> &amp;&amp; column.<span class=\"property\">filteredValue</span>.<span class=\"property\">length</span> &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                    ? <span class=\"string\">&quot;highlight&quot;</span></span><br><span class=\"line\">                    : <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">                ],</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              [</span><br><span class=\"line\">                column.<span class=\"property\">renderHeader</span></span><br><span class=\"line\">                  ? column.<span class=\"title function_\">renderHeader</span>(&#123;</span><br><span class=\"line\">                      column,</span><br><span class=\"line\">                      <span class=\"attr\">$index</span>: cellIndex,</span><br><span class=\"line\">                      store,</span><br><span class=\"line\">                      <span class=\"attr\">_self</span>: $parent,</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  : column.<span class=\"property\">label</span>,</span><br><span class=\"line\">                column.<span class=\"property\">sortable</span> &amp;&amp;</span><br><span class=\"line\">                  <span class=\"title function_\">h</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;span&quot;</span>,</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span> <span class=\"title function_\">handleSortClick</span>($event, column),</span><br><span class=\"line\">                      <span class=\"attr\">class</span>: <span class=\"string\">&quot;caret-wrapper&quot;</span>,</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                    [</span><br><span class=\"line\">                      <span class=\"title function_\">h</span>(<span class=\"string\">&quot;i&quot;</span>, &#123;</span><br><span class=\"line\">                        <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span></span><br><span class=\"line\">                          <span class=\"title function_\">handleSortClick</span>($event, column, <span class=\"string\">&quot;ascending&quot;</span>),</span><br><span class=\"line\">                        <span class=\"attr\">class</span>: <span class=\"string\">&quot;sort-caret ascending&quot;</span>,</span><br><span class=\"line\">                      &#125;),</span><br><span class=\"line\">                      <span class=\"title function_\">h</span>(<span class=\"string\">&quot;i&quot;</span>, &#123;</span><br><span class=\"line\">                        <span class=\"attr\">onClick</span>: <span class=\"function\">(<span class=\"params\">$event</span>) =&gt;</span></span><br><span class=\"line\">                          <span class=\"title function_\">handleSortClick</span>($event, column, <span class=\"string\">&quot;descending&quot;</span>),</span><br><span class=\"line\">                        <span class=\"attr\">class</span>: <span class=\"string\">&quot;sort-caret descending&quot;</span>,</span><br><span class=\"line\">                      &#125;),</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                  ),</span><br><span class=\"line\">                column.<span class=\"property\">filterable</span> &amp;&amp;</span><br><span class=\"line\">                  <span class=\"title function_\">h</span>(<span class=\"title class_\">FilterPanel</span>, &#123;</span><br><span class=\"line\">                    store,</span><br><span class=\"line\">                    <span class=\"attr\">placement</span>: column.<span class=\"property\">filterPlacement</span> || <span class=\"string\">&quot;bottom-start&quot;</span>,</span><br><span class=\"line\">                    column,</span><br><span class=\"line\">                    <span class=\"attr\">upDataColumn</span>: <span class=\"function\">(<span class=\"params\">key, value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                      column[key] = value;</span><br><span class=\"line\">                    &#125;,</span><br><span class=\"line\">                  &#125;),</span><br><span class=\"line\">              ]</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          ]</span><br><span class=\"line\">        );</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>table-body 和 table-header 的思路相似，也是利用 tr、td、tbody 这些原生标签实现 dom 的构建</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tbody的render实现</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(<span class=\"string\">&quot;tbody&quot;</span>, &#123; <span class=\"attr\">tabIndex</span>: -<span class=\"number\">1</span> &#125;, [</span><br><span class=\"line\">  data.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">acc: VNode[], row</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> acc.<span class=\"title function_\">concat</span>(<span class=\"title function_\">wrappedRowRender</span>(row, acc.<span class=\"property\">length</span>));</span><br><span class=\"line\">  &#125;, []),</span><br><span class=\"line\">]);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// tfoot标签的render实现</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"title function_\">h</span>(</span><br><span class=\"line\">      <span class=\"title function_\">h</span>(<span class=\"string\">&#x27;tfoot&#x27;</span>, [</span><br><span class=\"line\">        <span class=\"title function_\">h</span>(<span class=\"string\">&#x27;tr&#x27;</span>, &#123;&#125;, [</span><br><span class=\"line\">          ...columns.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">column, cellIndex</span>) =&gt;</span></span><br><span class=\"line\">            <span class=\"title function_\">h</span>(</span><br><span class=\"line\">              <span class=\"string\">&#x27;td&#x27;</span>,</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                <span class=\"attr\">key</span>: cellIndex,</span><br><span class=\"line\">                <span class=\"attr\">colspan</span>: column.<span class=\"property\">colSpan</span>,</span><br><span class=\"line\">                <span class=\"attr\">rowspan</span>: column.<span class=\"property\">rowSpan</span>,</span><br><span class=\"line\">                <span class=\"attr\">class</span>: <span class=\"title function_\">getCellClasses</span>(columns, cellIndex),</span><br><span class=\"line\">                <span class=\"attr\">style</span>: <span class=\"title function_\">getCellStyles</span>(column, cellIndex),</span><br><span class=\"line\">              &#125;,</span><br><span class=\"line\">              [</span><br><span class=\"line\">                <span class=\"title function_\">h</span>(</span><br><span class=\"line\">                  <span class=\"string\">&#x27;div&#x27;</span>,</span><br><span class=\"line\">                  &#123;</span><br><span class=\"line\">                    <span class=\"attr\">class</span>: [<span class=\"string\">&#x27;cell&#x27;</span>, column.<span class=\"property\">labelClassName</span>],</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  [sums[cellIndex]]</span><br><span class=\"line\">                ),</span><br><span class=\"line\">              ]</span><br><span class=\"line\">            )</span><br><span class=\"line\">          ),</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">      ])</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"可以借鉴的一些做法\"><a href=\"#可以借鉴的一些做法\" class=\"headerlink\" title=\"可以借鉴的一些做法\"></a>可以借鉴的一些做法</h1><ul>\n<li>Style：和样式相关的内容，放在同一个文件内，如 styles-helper.ts，避免样式失效，要注意 style 行内样式顺序，classnames 的合并注意同名 class</li>\n<li>Events：emit 事件放在 events-hepler.ts</li>\n<li>将不同的渲染内容区分开：如 table 的 footer、header、column 等等，都是作为单独 render 的组件聚合到一起</li>\n<li>Provider 和 Inject 的 key 用 symbol 修饰，并且使用常量命名，注意，使用 ts 类型断言的 as const</li>\n<li>是否需要使用 store，看组件的复杂程度，element-UI 中的 Table 和 Form 均使用了 store，store 会增加组件的复杂度，谨慎使用</li>\n<li>Vue3 版本中推荐使用 hooks 抽象逻辑</li>\n<li>单元测试：开发组件一定要加入单元测试，目的是为了发现组件设计的盲点和不合理的地方，甚至是内存管理问题。</li>\n</ul>\n<h1 id=\"最后，附上-Element-UI-的仓库地址和文档地址\"><a href=\"#最后，附上-Element-UI-的仓库地址和文档地址\" class=\"headerlink\" title=\"最后，附上 Element-UI 的仓库地址和文档地址\"></a>最后，附上 Element-UI 的仓库地址和文档地址</h1><p><a class=\"link\"   href=\"https://element-plus.org/zh-CN/component/form.html\" >Element-UI 文档<i class=\"fas fa-external-link-alt\"></i></a></p>\n<p><a class=\"link\"   href=\"https://github.com/element-plus/element-plus/tree/dev/packages\" >Element-Git 仓库<i class=\"fas fa-external-link-alt\"></i></a></p>\n"},{"title":"GameFi(Defi的游戏化)","_content":"\n## 什么都没留下","source":"_posts/GameFi.md","raw":"---\ntitle: GameFi(Defi的游戏化)\n---\n\n## 什么都没留下","slug":"GameFi","published":1,"date":"2024-03-26T07:13:35.915Z","updated":"2024-03-26T07:13:35.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrr00053jf0e0owdfik","content":"<h2 id=\"什么都没留下\"><a href=\"#什么都没留下\" class=\"headerlink\" title=\"什么都没留下\"></a>什么都没留下</h2>","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h2 id=\"什么都没留下\"><a href=\"#什么都没留下\" class=\"headerlink\" title=\"什么都没留下\"></a>什么都没留下</h2>"},{"title":"React Server Component","_content":"\n## 什么是 RSC\n\nreact server component 是 react 推出的服务端组件，顾名思义，服务端组件是运行在服务端的 react 组件，所以要想开发并使用服务端组件，需要先启动一个 node 服务\n\n### RSC 和 SSR 不是一个东西\n\n服务端组件不能使用客户端的一切变量和方法、事件，因为没有 DOM 和 BOM，所以服务端组件在使用的时候要做融合和水合(Hydrate)\n\n区分标识：\n\n- 服务端组件：’use server’\n- 客户端组件: ‘use client’\n\n在服务端代码执行开始之前，先执行 React 提供的 register 方法，通过自定义的 NodeJS 的 Module.prototype.\\_compile 方法在 NodeJS 每次 require 文件时检测头部是否有’use client’,有的话就做 client component 相关逻辑的处理\n\n```jsx\nconst register = require(\"react-server-dom-webpack/node-register\");\nregister();\n```\n\n`react-server-dom-webpack`是 react 针对 RSC 开发的`webpack`插件\n\n## 为什么要有 RSC\n\n一个 React 组件，可能包含两种类型的状态：\n\n- 前端交互用的状态，比如加载按钮的显/隐状态\n- 后端请求回的数据，比如下面代码中的 data 状态用于保存后端数据\n\n```jsx\nfunction App() {\n  const [data, update] = useState(null);\n\n  useEffect(() => {\n    fetch(url).then((res) => update(res.json()));\n  }, []);\n  return <Button data={data} />;\n}\n```\n\n前端交互状态放在前端最合适，单后端请求返回的数据放在前端则比较繁琐，整个链路如下：\n\n1. 前端请求并加载 React 业务逻辑代码\n2. 应用执行渲染流程\n3. App 组件 mount，执行 useEffect，请求后端数据\n4. 后端数据返回，App 组件的子组件消费数据\n\n那么，我们根据状态类型将组件分类，比如：\n\n- 「只包含交互相关状态」的组件，叫做客户端组件(React Client Component) RCC\n- 「只从数据源获取数据」的组件，叫做服务端组件(React Server Component) RSC\n\nRSC 的理念就是，一句话概括，根据状态类型，划分组件类型，RCC 在前端运行，RSC 在后端运行\n\n## 与 SSR、SSG 的区别\n\n这两者都是结合了客户端组件和服务端组件的方案，而 RSC 则是其中的组成部分\n\nSSG 是后端编译时方案，使用 SSG 的业务，后端代码在编译时回生成 HTML，当前端发起请求时，后端始终会返回编译生成的 HTML\n\nSSR 与 RSC 都是后端运行时方案，也就是说，他们都是前端发起请求后，后端对请求的实时响应，根据请求参数不同，可以作出不同响应。\n\n同为后端运行时方案，RSC 和 SSR 的区别主要体现在输出产物：\n\n- SSR 的输出产物都是 HTML，浏览器可以解析\n- RSC 会流式输出一种「类 JSON」的数据结构（React Flight），由前端的 React 相关插件解析，即上文提到的`react-server-dom-webpack`\n\n在应用上，需要考虑 SEO 时，SSR 和 SSG 都可以胜任，都是输出 HTML，而 RSC 不行，因为是流式输出\n\n## 如何区分 RSC 和 RCC\n\n- 带有`.server.tsx`后缀的文件导出的是 RSC\n- 带有`.client.tsx`后缀的文件导出的是 RCC\n- 没有带以上后缀的文件名是通用组件\n\n## 用法注意\n\nRCC 不允许 import 导入 RSC 组件，原因很简单，运行环境决定的，客户端组件要在前端运行，服务端组件要在服务端运行\n\n需要交替使用的话，使用 children，即将 RSC 组件作为 RCC 组件的子组件\n\n```jsx\n// client.tsx\nexport default function Client(children) {\n  return <main>{children}</main>;\n}\n```\n\n```jsx\n// server.tsx\nimport Client from \"./client.tsx\";\nimport Server from \"./server.tsx\";\n\nexport default function Outer() {\n  return (\n    <Client>\n      <Server />\n    </Client>\n  );\n}\n```\n\n上面说了 RSC 组件是以流的形式传输到前端的，那么这个流的格式是什么样的呢\n\n```jsx\nM1:{\"id\":\"./src/ClientCpn.client.js\",\"chunks\":[\"client1\"],\"name\":\"\"}\nJ0:[\"$\",\"div\",null,{\"className\":\"main\",\"children\":[\"$\",\"@1\",null,{\"children\":[\"$\",\"div\",null,{\"children\":\"服务端组件\"}]}]}]\n```\n\nRSC 是一种按行分隔的数据结构，方便流式传输，每行的格式为：\n\n<aside>\n<img src=\"/icons/code_yellow.svg\" alt=\"/icons/code_yellow.svg\" width=\"40px\" /> [标记][id]: JSON数据\n\n</aside>\n\n标记：代表这行的数据类型，比如 J 代表组件树，M 代表「一个 RCC 的引用」，S 代表 Suspense\n\nid：代表这行数据的 id\n\nJSON 数据保存了这行具体的数据\n\nRSC 的序列化和反序列化就是 JSON 的序列化和反序列化，反序列化后的数据再根据「标记」不同做不同处理\n\n## 传输协议\n\nRSC 数据以什么格式在前后端传递呢，不同于一些 rpc 协议会基于 TCP 或者 UDP 实现，「RSC 协议」基于「HTTP 协议」实现，其中的`Content-Type = text/x-component`\n","source":"_posts/ReactServerComponent.md","raw":"---\ntitle: React Server Component\n---\n\n## 什么是 RSC\n\nreact server component 是 react 推出的服务端组件，顾名思义，服务端组件是运行在服务端的 react 组件，所以要想开发并使用服务端组件，需要先启动一个 node 服务\n\n### RSC 和 SSR 不是一个东西\n\n服务端组件不能使用客户端的一切变量和方法、事件，因为没有 DOM 和 BOM，所以服务端组件在使用的时候要做融合和水合(Hydrate)\n\n区分标识：\n\n- 服务端组件：’use server’\n- 客户端组件: ‘use client’\n\n在服务端代码执行开始之前，先执行 React 提供的 register 方法，通过自定义的 NodeJS 的 Module.prototype.\\_compile 方法在 NodeJS 每次 require 文件时检测头部是否有’use client’,有的话就做 client component 相关逻辑的处理\n\n```jsx\nconst register = require(\"react-server-dom-webpack/node-register\");\nregister();\n```\n\n`react-server-dom-webpack`是 react 针对 RSC 开发的`webpack`插件\n\n## 为什么要有 RSC\n\n一个 React 组件，可能包含两种类型的状态：\n\n- 前端交互用的状态，比如加载按钮的显/隐状态\n- 后端请求回的数据，比如下面代码中的 data 状态用于保存后端数据\n\n```jsx\nfunction App() {\n  const [data, update] = useState(null);\n\n  useEffect(() => {\n    fetch(url).then((res) => update(res.json()));\n  }, []);\n  return <Button data={data} />;\n}\n```\n\n前端交互状态放在前端最合适，单后端请求返回的数据放在前端则比较繁琐，整个链路如下：\n\n1. 前端请求并加载 React 业务逻辑代码\n2. 应用执行渲染流程\n3. App 组件 mount，执行 useEffect，请求后端数据\n4. 后端数据返回，App 组件的子组件消费数据\n\n那么，我们根据状态类型将组件分类，比如：\n\n- 「只包含交互相关状态」的组件，叫做客户端组件(React Client Component) RCC\n- 「只从数据源获取数据」的组件，叫做服务端组件(React Server Component) RSC\n\nRSC 的理念就是，一句话概括，根据状态类型，划分组件类型，RCC 在前端运行，RSC 在后端运行\n\n## 与 SSR、SSG 的区别\n\n这两者都是结合了客户端组件和服务端组件的方案，而 RSC 则是其中的组成部分\n\nSSG 是后端编译时方案，使用 SSG 的业务，后端代码在编译时回生成 HTML，当前端发起请求时，后端始终会返回编译生成的 HTML\n\nSSR 与 RSC 都是后端运行时方案，也就是说，他们都是前端发起请求后，后端对请求的实时响应，根据请求参数不同，可以作出不同响应。\n\n同为后端运行时方案，RSC 和 SSR 的区别主要体现在输出产物：\n\n- SSR 的输出产物都是 HTML，浏览器可以解析\n- RSC 会流式输出一种「类 JSON」的数据结构（React Flight），由前端的 React 相关插件解析，即上文提到的`react-server-dom-webpack`\n\n在应用上，需要考虑 SEO 时，SSR 和 SSG 都可以胜任，都是输出 HTML，而 RSC 不行，因为是流式输出\n\n## 如何区分 RSC 和 RCC\n\n- 带有`.server.tsx`后缀的文件导出的是 RSC\n- 带有`.client.tsx`后缀的文件导出的是 RCC\n- 没有带以上后缀的文件名是通用组件\n\n## 用法注意\n\nRCC 不允许 import 导入 RSC 组件，原因很简单，运行环境决定的，客户端组件要在前端运行，服务端组件要在服务端运行\n\n需要交替使用的话，使用 children，即将 RSC 组件作为 RCC 组件的子组件\n\n```jsx\n// client.tsx\nexport default function Client(children) {\n  return <main>{children}</main>;\n}\n```\n\n```jsx\n// server.tsx\nimport Client from \"./client.tsx\";\nimport Server from \"./server.tsx\";\n\nexport default function Outer() {\n  return (\n    <Client>\n      <Server />\n    </Client>\n  );\n}\n```\n\n上面说了 RSC 组件是以流的形式传输到前端的，那么这个流的格式是什么样的呢\n\n```jsx\nM1:{\"id\":\"./src/ClientCpn.client.js\",\"chunks\":[\"client1\"],\"name\":\"\"}\nJ0:[\"$\",\"div\",null,{\"className\":\"main\",\"children\":[\"$\",\"@1\",null,{\"children\":[\"$\",\"div\",null,{\"children\":\"服务端组件\"}]}]}]\n```\n\nRSC 是一种按行分隔的数据结构，方便流式传输，每行的格式为：\n\n<aside>\n<img src=\"/icons/code_yellow.svg\" alt=\"/icons/code_yellow.svg\" width=\"40px\" /> [标记][id]: JSON数据\n\n</aside>\n\n标记：代表这行的数据类型，比如 J 代表组件树，M 代表「一个 RCC 的引用」，S 代表 Suspense\n\nid：代表这行数据的 id\n\nJSON 数据保存了这行具体的数据\n\nRSC 的序列化和反序列化就是 JSON 的序列化和反序列化，反序列化后的数据再根据「标记」不同做不同处理\n\n## 传输协议\n\nRSC 数据以什么格式在前后端传递呢，不同于一些 rpc 协议会基于 TCP 或者 UDP 实现，「RSC 协议」基于「HTTP 协议」实现，其中的`Content-Type = text/x-component`\n","slug":"ReactServerComponent","published":1,"date":"2024-05-22T02:48:28.070Z","updated":"2024-05-22T02:49:58.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrr00063jf0ctgu4r6t","content":"<h2 id=\"什么是-RSC\"><a href=\"#什么是-RSC\" class=\"headerlink\" title=\"什么是 RSC\"></a>什么是 RSC</h2><p>react server component 是 react 推出的服务端组件，顾名思义，服务端组件是运行在服务端的 react 组件，所以要想开发并使用服务端组件，需要先启动一个 node 服务</p>\n<h3 id=\"RSC-和-SSR-不是一个东西\"><a href=\"#RSC-和-SSR-不是一个东西\" class=\"headerlink\" title=\"RSC 和 SSR 不是一个东西\"></a>RSC 和 SSR 不是一个东西</h3><p>服务端组件不能使用客户端的一切变量和方法、事件，因为没有 DOM 和 BOM，所以服务端组件在使用的时候要做融合和水合(Hydrate)</p>\n<p>区分标识：</p>\n<ul>\n<li>服务端组件：’use server’</li>\n<li>客户端组件: ‘use client’</li>\n</ul>\n<p>在服务端代码执行开始之前，先执行 React 提供的 register 方法，通过自定义的 NodeJS 的 Module.prototype._compile 方法在 NodeJS 每次 require 文件时检测头部是否有’use client’,有的话就做 client component 相关逻辑的处理</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> register = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;react-server-dom-webpack/node-register&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">register</span>();</span><br></pre></td></tr></table></figure>\n\n<p><code>react-server-dom-webpack</code>是 react 针对 RSC 开发的<code>webpack</code>插件</p>\n<h2 id=\"为什么要有-RSC\"><a href=\"#为什么要有-RSC\" class=\"headerlink\" title=\"为什么要有 RSC\"></a>为什么要有 RSC</h2><p>一个 React 组件，可能包含两种类型的状态：</p>\n<ul>\n<li>前端交互用的状态，比如加载按钮的显&#x2F;隐状态</li>\n<li>后端请求回的数据，比如下面代码中的 data 状态用于保存后端数据</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, update] = <span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(url).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> <span class=\"title function_\">update</span>(res.<span class=\"title function_\">json</span>()));</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;data&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端交互状态放在前端最合适，单后端请求返回的数据放在前端则比较繁琐，整个链路如下：</p>\n<ol>\n<li>前端请求并加载 React 业务逻辑代码</li>\n<li>应用执行渲染流程</li>\n<li>App 组件 mount，执行 useEffect，请求后端数据</li>\n<li>后端数据返回，App 组件的子组件消费数据</li>\n</ol>\n<p>那么，我们根据状态类型将组件分类，比如：</p>\n<ul>\n<li>「只包含交互相关状态」的组件，叫做客户端组件(React Client Component) RCC</li>\n<li>「只从数据源获取数据」的组件，叫做服务端组件(React Server Component) RSC</li>\n</ul>\n<p>RSC 的理念就是，一句话概括，根据状态类型，划分组件类型，RCC 在前端运行，RSC 在后端运行</p>\n<h2 id=\"与-SSR、SSG-的区别\"><a href=\"#与-SSR、SSG-的区别\" class=\"headerlink\" title=\"与 SSR、SSG 的区别\"></a>与 SSR、SSG 的区别</h2><p>这两者都是结合了客户端组件和服务端组件的方案，而 RSC 则是其中的组成部分</p>\n<p>SSG 是后端编译时方案，使用 SSG 的业务，后端代码在编译时回生成 HTML，当前端发起请求时，后端始终会返回编译生成的 HTML</p>\n<p>SSR 与 RSC 都是后端运行时方案，也就是说，他们都是前端发起请求后，后端对请求的实时响应，根据请求参数不同，可以作出不同响应。</p>\n<p>同为后端运行时方案，RSC 和 SSR 的区别主要体现在输出产物：</p>\n<ul>\n<li>SSR 的输出产物都是 HTML，浏览器可以解析</li>\n<li>RSC 会流式输出一种「类 JSON」的数据结构（React Flight），由前端的 React 相关插件解析，即上文提到的<code>react-server-dom-webpack</code></li>\n</ul>\n<p>在应用上，需要考虑 SEO 时，SSR 和 SSG 都可以胜任，都是输出 HTML，而 RSC 不行，因为是流式输出</p>\n<h2 id=\"如何区分-RSC-和-RCC\"><a href=\"#如何区分-RSC-和-RCC\" class=\"headerlink\" title=\"如何区分 RSC 和 RCC\"></a>如何区分 RSC 和 RCC</h2><ul>\n<li>带有<code>.server.tsx</code>后缀的文件导出的是 RSC</li>\n<li>带有<code>.client.tsx</code>后缀的文件导出的是 RCC</li>\n<li>没有带以上后缀的文件名是通用组件</li>\n</ul>\n<h2 id=\"用法注意\"><a href=\"#用法注意\" class=\"headerlink\" title=\"用法注意\"></a>用法注意</h2><p>RCC 不允许 import 导入 RSC 组件，原因很简单，运行环境决定的，客户端组件要在前端运行，服务端组件要在服务端运行</p>\n<p>需要交替使用的话，使用 children，即将 RSC 组件作为 RCC 组件的子组件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// client.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Client</span>(<span class=\"params\">children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Client</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./client.tsx&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Server</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./server.tsx&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Outer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Client</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Server</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Client</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面说了 RSC 组件是以流的形式传输到前端的，那么这个流的格式是什么样的呢</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">M1</span>:&#123;<span class=\"string\">&quot;id&quot;</span>:<span class=\"string\">&quot;./src/ClientCpn.client.js&quot;</span>,<span class=\"string\">&quot;chunks&quot;</span>:[<span class=\"string\">&quot;client1&quot;</span>],<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"attr\">J0</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;div&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;className&quot;</span>:<span class=\"string\">&quot;main&quot;</span>,<span class=\"string\">&quot;children&quot;</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;@1&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;children&quot;</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;div&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;children&quot;</span>:<span class=\"string\">&quot;服务端组件&quot;</span>&#125;]&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>RSC 是一种按行分隔的数据结构，方便流式传输，每行的格式为：</p>\n<aside>\n<img src=\"/icons/code_yellow.svg\" alt=\"/icons/code_yellow.svg\" width=\"40px\" /> [标记][id]: JSON数据\n\n</aside>\n\n<p>标记：代表这行的数据类型，比如 J 代表组件树，M 代表「一个 RCC 的引用」，S 代表 Suspense</p>\n<p>id：代表这行数据的 id</p>\n<p>JSON 数据保存了这行具体的数据</p>\n<p>RSC 的序列化和反序列化就是 JSON 的序列化和反序列化，反序列化后的数据再根据「标记」不同做不同处理</p>\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><p>RSC 数据以什么格式在前后端传递呢，不同于一些 rpc 协议会基于 TCP 或者 UDP 实现，「RSC 协议」基于「HTTP 协议」实现，其中的<code>Content-Type = text/x-component</code></p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h2 id=\"什么是-RSC\"><a href=\"#什么是-RSC\" class=\"headerlink\" title=\"什么是 RSC\"></a>什么是 RSC</h2><p>react server component 是 react 推出的服务端组件，顾名思义，服务端组件是运行在服务端的 react 组件，所以要想开发并使用服务端组件，需要先启动一个 node 服务</p>\n<h3 id=\"RSC-和-SSR-不是一个东西\"><a href=\"#RSC-和-SSR-不是一个东西\" class=\"headerlink\" title=\"RSC 和 SSR 不是一个东西\"></a>RSC 和 SSR 不是一个东西</h3><p>服务端组件不能使用客户端的一切变量和方法、事件，因为没有 DOM 和 BOM，所以服务端组件在使用的时候要做融合和水合(Hydrate)</p>\n<p>区分标识：</p>\n<ul>\n<li>服务端组件：’use server’</li>\n<li>客户端组件: ‘use client’</li>\n</ul>\n<p>在服务端代码执行开始之前，先执行 React 提供的 register 方法，通过自定义的 NodeJS 的 Module.prototype._compile 方法在 NodeJS 每次 require 文件时检测头部是否有’use client’,有的话就做 client component 相关逻辑的处理</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> register = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;react-server-dom-webpack/node-register&quot;</span>);</span><br><span class=\"line\"><span class=\"title function_\">register</span>();</span><br></pre></td></tr></table></figure>\n\n<p><code>react-server-dom-webpack</code>是 react 针对 RSC 开发的<code>webpack</code>插件</p>\n<h2 id=\"为什么要有-RSC\"><a href=\"#为什么要有-RSC\" class=\"headerlink\" title=\"为什么要有 RSC\"></a>为什么要有 RSC</h2><p>一个 React 组件，可能包含两种类型的状态：</p>\n<ul>\n<li>前端交互用的状态，比如加载按钮的显&#x2F;隐状态</li>\n<li>后端请求回的数据，比如下面代码中的 data 状态用于保存后端数据</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, update] = <span class=\"title function_\">useState</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(url).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> <span class=\"title function_\">update</span>(res.<span class=\"title function_\">json</span>()));</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">data</span>=<span class=\"string\">&#123;data&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端交互状态放在前端最合适，单后端请求返回的数据放在前端则比较繁琐，整个链路如下：</p>\n<ol>\n<li>前端请求并加载 React 业务逻辑代码</li>\n<li>应用执行渲染流程</li>\n<li>App 组件 mount，执行 useEffect，请求后端数据</li>\n<li>后端数据返回，App 组件的子组件消费数据</li>\n</ol>\n<p>那么，我们根据状态类型将组件分类，比如：</p>\n<ul>\n<li>「只包含交互相关状态」的组件，叫做客户端组件(React Client Component) RCC</li>\n<li>「只从数据源获取数据」的组件，叫做服务端组件(React Server Component) RSC</li>\n</ul>\n<p>RSC 的理念就是，一句话概括，根据状态类型，划分组件类型，RCC 在前端运行，RSC 在后端运行</p>\n<h2 id=\"与-SSR、SSG-的区别\"><a href=\"#与-SSR、SSG-的区别\" class=\"headerlink\" title=\"与 SSR、SSG 的区别\"></a>与 SSR、SSG 的区别</h2><p>这两者都是结合了客户端组件和服务端组件的方案，而 RSC 则是其中的组成部分</p>\n<p>SSG 是后端编译时方案，使用 SSG 的业务，后端代码在编译时回生成 HTML，当前端发起请求时，后端始终会返回编译生成的 HTML</p>\n<p>SSR 与 RSC 都是后端运行时方案，也就是说，他们都是前端发起请求后，后端对请求的实时响应，根据请求参数不同，可以作出不同响应。</p>\n<p>同为后端运行时方案，RSC 和 SSR 的区别主要体现在输出产物：</p>\n<ul>\n<li>SSR 的输出产物都是 HTML，浏览器可以解析</li>\n<li>RSC 会流式输出一种「类 JSON」的数据结构（React Flight），由前端的 React 相关插件解析，即上文提到的<code>react-server-dom-webpack</code></li>\n</ul>\n<p>在应用上，需要考虑 SEO 时，SSR 和 SSG 都可以胜任，都是输出 HTML，而 RSC 不行，因为是流式输出</p>\n<h2 id=\"如何区分-RSC-和-RCC\"><a href=\"#如何区分-RSC-和-RCC\" class=\"headerlink\" title=\"如何区分 RSC 和 RCC\"></a>如何区分 RSC 和 RCC</h2><ul>\n<li>带有<code>.server.tsx</code>后缀的文件导出的是 RSC</li>\n<li>带有<code>.client.tsx</code>后缀的文件导出的是 RCC</li>\n<li>没有带以上后缀的文件名是通用组件</li>\n</ul>\n<h2 id=\"用法注意\"><a href=\"#用法注意\" class=\"headerlink\" title=\"用法注意\"></a>用法注意</h2><p>RCC 不允许 import 导入 RSC 组件，原因很简单，运行环境决定的，客户端组件要在前端运行，服务端组件要在服务端运行</p>\n<p>需要交替使用的话，使用 children，即将 RSC 组件作为 RCC 组件的子组件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// client.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Client</span>(<span class=\"params\">children</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.tsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Client</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./client.tsx&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Server</span> <span class=\"keyword\">from</span> <span class=\"string\">&quot;./server.tsx&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Outer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Client</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Server</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Client</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面说了 RSC 组件是以流的形式传输到前端的，那么这个流的格式是什么样的呢</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">M1</span>:&#123;<span class=\"string\">&quot;id&quot;</span>:<span class=\"string\">&quot;./src/ClientCpn.client.js&quot;</span>,<span class=\"string\">&quot;chunks&quot;</span>:[<span class=\"string\">&quot;client1&quot;</span>],<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"attr\">J0</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;div&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;className&quot;</span>:<span class=\"string\">&quot;main&quot;</span>,<span class=\"string\">&quot;children&quot;</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;@1&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;children&quot;</span>:[<span class=\"string\">&quot;$&quot;</span>,<span class=\"string\">&quot;div&quot;</span>,<span class=\"literal\">null</span>,&#123;<span class=\"string\">&quot;children&quot;</span>:<span class=\"string\">&quot;服务端组件&quot;</span>&#125;]&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>RSC 是一种按行分隔的数据结构，方便流式传输，每行的格式为：</p>\n<aside>\n<img src=\"/icons/code_yellow.svg\" alt=\"/icons/code_yellow.svg\" width=\"40px\" /> [标记][id]: JSON数据\n\n</aside>\n\n<p>标记：代表这行的数据类型，比如 J 代表组件树，M 代表「一个 RCC 的引用」，S 代表 Suspense</p>\n<p>id：代表这行数据的 id</p>\n<p>JSON 数据保存了这行具体的数据</p>\n<p>RSC 的序列化和反序列化就是 JSON 的序列化和反序列化，反序列化后的数据再根据「标记」不同做不同处理</p>\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><p>RSC 数据以什么格式在前后端传递呢，不同于一些 rpc 协议会基于 TCP 或者 UDP 实现，「RSC 协议」基于「HTTP 协议」实现，其中的<code>Content-Type = text/x-component</code></p>\n"},{"title":"Recoil解决了什么问题","_content":"\n# Recoil\n","source":"_posts/Recoli.md","raw":"---\ntitle: Recoil解决了什么问题\n---\n\n# Recoil\n","slug":"Recoli","published":1,"date":"2024-03-27T03:59:24.862Z","updated":"2024-03-27T06:15:16.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrr00073jf00h3nbyky","content":"<h1 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h1>","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"Recoil\"><a href=\"#Recoil\" class=\"headerlink\" title=\"Recoil\"></a>Recoil</h1>"},{"title":"Redux-Middleware","_content":"\n# Redux-Middleware 解析\n\n<aside>\n💡 It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.\n\n</aside>\n\n以上是 Dan Abramov 对 middleware 的描述，他提供了一个分类处理 action 的机会，在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会，\n\n看一下使用方法：\n\n```jsx\nimport { Middleware } from \"react\";\nexport const logger: Middleware = (store) => (next) => (action) => {\n  console.log(action);\n  return next(action);\n};\n// 这里用了函数科里化的做法，将每个return的函数都改成一个参数的函数，为了解耦\n```\n\nMiddleware 具体是如何实现的呢\n\n```jsx\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    var store = createStore(reducer, preloadedState, enhancer);\n    var dispatch = store.dispatch;\n    var chain = [];\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action),\n    };\n    chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch,\n    };\n  };\n}\n```\n\n了解一下 compose 函数：\n\n```jsx\nlet result = compose(f1, f2, f3, f4)(value) -> let result = f1(f2(f3(f4(value))))\n```\n\n其中\n\n```jsx\nchain = middlewares.map(middleware => middleware(middlewareAPI))\ndispatch = compose(...chain)(store.dispatch)\n\n// 可以变化为\nfnMiddle = fn(middlewareAPI)\ndispatch = fnMiddle(store.dispatch)\n\n//也就是\ndispatch = fn(middlewareAPI)(store.dispatch)\n\n//接着\nstore.dispatch(action)\n// 等价于\nfn(middlewareAPI)(store.dispatch)(action)\n\n// 那么\ndispatch = compose(...chain)(store.dispatch) === dispatch = fn1Middle(fn2Middle(store.dispatch))\n\n// 每一次fnMiddle执行之后，就会返回一个函数\n(action) => {\n\t...\n\tnext(action)\n\t...\n}\n// 到了下一个fnMiddle执行的时候，接受一个传入的action参数，方法体里执行的是next(action)\n// 那么，什么事next方法呢，由第一个fnMiddleware执行的时候传入store.dispatch()\n// store.dispatch 就作为next函数的方法体\n// 也就是，每次的next(action)实际上就是执行的store.dispatch(action)\n```\n\n![redux.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/43b64f47-9fcc-42a0-ba9a-fbfb1e671f2c/8ad6a082-5e9c-4dc3-828a-a80fb97cd75d/redux.jpeg)\n\n以上的图示表明，redux 的 middleware 是多层函数包裹结构，每个 middleware 执行完之后，就会将结果返回给下一个 middleware，其中 return 的函数参数为 action，函数体会执行 next(action)，而 next 正是第一次传入 store.dispatch，因为这里是用了 compose 编程思想，将不变的函数参数以科里化的形式作为参数传入，如 store，next，而变化的参数如 action 则作为最后一个参数传入，形如：\n\n```jsx\nmiddleware = (store) => (next) => (action) => {};\n// store, next 都是不变的函数参数，action作为每个middleware需要处理的对象，最后一个传入\n```\n","source":"_posts/Redux-middleware.md","raw":"---\ntitle: Redux-Middleware\n---\n\n# Redux-Middleware 解析\n\n<aside>\n💡 It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.\n\n</aside>\n\n以上是 Dan Abramov 对 middleware 的描述，他提供了一个分类处理 action 的机会，在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会，\n\n看一下使用方法：\n\n```jsx\nimport { Middleware } from \"react\";\nexport const logger: Middleware = (store) => (next) => (action) => {\n  console.log(action);\n  return next(action);\n};\n// 这里用了函数科里化的做法，将每个return的函数都改成一个参数的函数，为了解耦\n```\n\nMiddleware 具体是如何实现的呢\n\n```jsx\nexport default function applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, preloadedState, enhancer) => {\n    var store = createStore(reducer, preloadedState, enhancer);\n    var dispatch = store.dispatch;\n    var chain = [];\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action),\n    };\n    chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n    return {\n      ...store,\n      dispatch,\n    };\n  };\n}\n```\n\n了解一下 compose 函数：\n\n```jsx\nlet result = compose(f1, f2, f3, f4)(value) -> let result = f1(f2(f3(f4(value))))\n```\n\n其中\n\n```jsx\nchain = middlewares.map(middleware => middleware(middlewareAPI))\ndispatch = compose(...chain)(store.dispatch)\n\n// 可以变化为\nfnMiddle = fn(middlewareAPI)\ndispatch = fnMiddle(store.dispatch)\n\n//也就是\ndispatch = fn(middlewareAPI)(store.dispatch)\n\n//接着\nstore.dispatch(action)\n// 等价于\nfn(middlewareAPI)(store.dispatch)(action)\n\n// 那么\ndispatch = compose(...chain)(store.dispatch) === dispatch = fn1Middle(fn2Middle(store.dispatch))\n\n// 每一次fnMiddle执行之后，就会返回一个函数\n(action) => {\n\t...\n\tnext(action)\n\t...\n}\n// 到了下一个fnMiddle执行的时候，接受一个传入的action参数，方法体里执行的是next(action)\n// 那么，什么事next方法呢，由第一个fnMiddleware执行的时候传入store.dispatch()\n// store.dispatch 就作为next函数的方法体\n// 也就是，每次的next(action)实际上就是执行的store.dispatch(action)\n```\n\n![redux.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/43b64f47-9fcc-42a0-ba9a-fbfb1e671f2c/8ad6a082-5e9c-4dc3-828a-a80fb97cd75d/redux.jpeg)\n\n以上的图示表明，redux 的 middleware 是多层函数包裹结构，每个 middleware 执行完之后，就会将结果返回给下一个 middleware，其中 return 的函数参数为 action，函数体会执行 next(action)，而 next 正是第一次传入 store.dispatch，因为这里是用了 compose 编程思想，将不变的函数参数以科里化的形式作为参数传入，如 store，next，而变化的参数如 action 则作为最后一个参数传入，形如：\n\n```jsx\nmiddleware = (store) => (next) => (action) => {};\n// store, next 都是不变的函数参数，action作为每个middleware需要处理的对象，最后一个传入\n```\n","slug":"Redux-middleware","published":1,"date":"2024-03-26T07:52:52.221Z","updated":"2024-03-26T07:54:01.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrs00083jf0fsob44x6","content":"<h1 id=\"Redux-Middleware-解析\"><a href=\"#Redux-Middleware-解析\" class=\"headerlink\" title=\"Redux-Middleware 解析\"></a>Redux-Middleware 解析</h1><aside>\n💡 It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.\n\n</aside>\n\n<p>以上是 Dan Abramov 对 middleware 的描述，他提供了一个分类处理 action 的机会，在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会，</p>\n<p>看一下使用方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Middleware</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">logger</span>: <span class=\"title class_\">Middleware</span> = <span class=\"function\">(<span class=\"params\">store</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(action);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">next</span>(action);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 这里用了函数科里化的做法，将每个return的函数都改成一个参数的函数，为了解耦</span></span><br></pre></td></tr></table></figure>\n\n<p>Middleware 具体是如何实现的呢</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = <span class=\"title function_\">createStore</span>(reducer, preloadedState, enhancer);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.<span class=\"property\">dispatch</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      <span class=\"attr\">getState</span>: store.<span class=\"property\">getState</span>,</span><br><span class=\"line\">      <span class=\"attr\">dispatch</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> <span class=\"title function_\">dispatch</span>(action),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    chain = middlewares.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">middleware</span>) =&gt;</span> <span class=\"title function_\">middleware</span>(middlewareAPI));</span><br><span class=\"line\">    dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>了解一下 compose 函数：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">compose</span>(f1, f2, f3, f4)(value) -&gt; <span class=\"keyword\">let</span> result = <span class=\"title function_\">f1</span>(<span class=\"title function_\">f2</span>(<span class=\"title function_\">f3</span>(<span class=\"title function_\">f4</span>(value))))</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chain = middlewares.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> <span class=\"title function_\">middleware</span>(middlewareAPI))</span><br><span class=\"line\">dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以变化为</span></span><br><span class=\"line\">fnMiddle = <span class=\"title function_\">fn</span>(middlewareAPI)</span><br><span class=\"line\">dispatch = <span class=\"title function_\">fnMiddle</span>(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//也就是</span></span><br><span class=\"line\">dispatch = <span class=\"title function_\">fn</span>(middlewareAPI)(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接着</span></span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(action)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"title function_\">fn</span>(middlewareAPI)(store.<span class=\"property\">dispatch</span>)(action)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么</span></span><br><span class=\"line\">dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>) === dispatch = <span class=\"title function_\">fn1Middle</span>(<span class=\"title function_\">fn2Middle</span>(store.<span class=\"property\">dispatch</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一次fnMiddle执行之后，就会返回一个函数</span></span><br><span class=\"line\">(action) =&gt; &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"title function_\">next</span>(action)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 到了下一个fnMiddle执行的时候，接受一个传入的action参数，方法体里执行的是next(action)</span></span><br><span class=\"line\"><span class=\"comment\">// 那么，什么事next方法呢，由第一个fnMiddleware执行的时候传入store.dispatch()</span></span><br><span class=\"line\"><span class=\"comment\">// store.dispatch 就作为next函数的方法体</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是，每次的next(action)实际上就是执行的store.dispatch(action)</span></span><br></pre></td></tr></table></figure>\n\n<p><img   src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/43b64f47-9fcc-42a0-ba9a-fbfb1e671f2c/8ad6a082-5e9c-4dc3-828a-a80fb97cd75d/redux.jpeg\"  alt=\"redux.jpeg\"></p>\n<p>以上的图示表明，redux 的 middleware 是多层函数包裹结构，每个 middleware 执行完之后，就会将结果返回给下一个 middleware，其中 return 的函数参数为 action，函数体会执行 next(action)，而 next 正是第一次传入 store.dispatch，因为这里是用了 compose 编程思想，将不变的函数参数以科里化的形式作为参数传入，如 store，next，而变化的参数如 action 则作为最后一个参数传入，形如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middleware = <span class=\"function\">(<span class=\"params\">store</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// store, next 都是不变的函数参数，action作为每个middleware需要处理的对象，最后一个传入</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"Redux-Middleware-解析\"><a href=\"#Redux-Middleware-解析\" class=\"headerlink\" title=\"Redux-Middleware 解析\"></a>Redux-Middleware 解析</h1><aside>\n💡 It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.\n\n</aside>\n\n<p>以上是 Dan Abramov 对 middleware 的描述，他提供了一个分类处理 action 的机会，在 middleware 中，你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会，</p>\n<p>看一下使用方法：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Middleware</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"attr\">logger</span>: <span class=\"title class_\">Middleware</span> = <span class=\"function\">(<span class=\"params\">store</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(action);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title function_\">next</span>(action);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 这里用了函数科里化的做法，将每个return的函数都改成一个参数的函数，为了解耦</span></span><br></pre></td></tr></table></figure>\n\n<p>Middleware 具体是如何实现的呢</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">createStore</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">reducer, preloadedState, enhancer</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = <span class=\"title function_\">createStore</span>(reducer, preloadedState, enhancer);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.<span class=\"property\">dispatch</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      <span class=\"attr\">getState</span>: store.<span class=\"property\">getState</span>,</span><br><span class=\"line\">      <span class=\"attr\">dispatch</span>: <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> <span class=\"title function_\">dispatch</span>(action),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    chain = middlewares.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">middleware</span>) =&gt;</span> <span class=\"title function_\">middleware</span>(middlewareAPI));</span><br><span class=\"line\">    dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>了解一下 compose 函数：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"title function_\">compose</span>(f1, f2, f3, f4)(value) -&gt; <span class=\"keyword\">let</span> result = <span class=\"title function_\">f1</span>(<span class=\"title function_\">f2</span>(<span class=\"title function_\">f3</span>(<span class=\"title function_\">f4</span>(value))))</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chain = middlewares.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> <span class=\"title function_\">middleware</span>(middlewareAPI))</span><br><span class=\"line\">dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以变化为</span></span><br><span class=\"line\">fnMiddle = <span class=\"title function_\">fn</span>(middlewareAPI)</span><br><span class=\"line\">dispatch = <span class=\"title function_\">fnMiddle</span>(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//也就是</span></span><br><span class=\"line\">dispatch = <span class=\"title function_\">fn</span>(middlewareAPI)(store.<span class=\"property\">dispatch</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接着</span></span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(action)</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\"><span class=\"title function_\">fn</span>(middlewareAPI)(store.<span class=\"property\">dispatch</span>)(action)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 那么</span></span><br><span class=\"line\">dispatch = <span class=\"title function_\">compose</span>(...chain)(store.<span class=\"property\">dispatch</span>) === dispatch = <span class=\"title function_\">fn1Middle</span>(<span class=\"title function_\">fn2Middle</span>(store.<span class=\"property\">dispatch</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每一次fnMiddle执行之后，就会返回一个函数</span></span><br><span class=\"line\">(action) =&gt; &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"title function_\">next</span>(action)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 到了下一个fnMiddle执行的时候，接受一个传入的action参数，方法体里执行的是next(action)</span></span><br><span class=\"line\"><span class=\"comment\">// 那么，什么事next方法呢，由第一个fnMiddleware执行的时候传入store.dispatch()</span></span><br><span class=\"line\"><span class=\"comment\">// store.dispatch 就作为next函数的方法体</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是，每次的next(action)实际上就是执行的store.dispatch(action)</span></span><br></pre></td></tr></table></figure>\n\n<p><img   src=\"https://prod-files-secure.s3.us-west-2.amazonaws.com/43b64f47-9fcc-42a0-ba9a-fbfb1e671f2c/8ad6a082-5e9c-4dc3-828a-a80fb97cd75d/redux.jpeg\"  alt=\"redux.jpeg\"></p>\n<p>以上的图示表明，redux 的 middleware 是多层函数包裹结构，每个 middleware 执行完之后，就会将结果返回给下一个 middleware，其中 return 的函数参数为 action，函数体会执行 next(action)，而 next 正是第一次传入 store.dispatch，因为这里是用了 compose 编程思想，将不变的函数参数以科里化的形式作为参数传入，如 store，next，而变化的参数如 action 则作为最后一个参数传入，形如：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middleware = <span class=\"function\">(<span class=\"params\">store</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// store, next 都是不变的函数参数，action作为每个middleware需要处理的对象，最后一个传入</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Farm(耕种)","_content":"\n## Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]","source":"_posts/farm.md","raw":"---\ntitle: Farm(耕种)\n---\n\n## Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]","slug":"farm","published":1,"date":"2024-03-26T07:13:35.915Z","updated":"2024-03-26T07:13:35.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrs00093jf0609id9xe","content":"<h2 id=\"Yield-Farming-流动性挖矿-Yield-收益-Farm-耕种-，指将资金投入到不同的Defi协议中赚取回报\"><a href=\"#Yield-Farming-流动性挖矿-Yield-收益-Farm-耕种-，指将资金投入到不同的Defi协议中赚取回报\" class=\"headerlink\" title=\"Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]\"></a>Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]</h2>","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h2 id=\"Yield-Farming-流动性挖矿-Yield-收益-Farm-耕种-，指将资金投入到不同的Defi协议中赚取回报\"><a href=\"#Yield-Farming-流动性挖矿-Yield-收益-Farm-耕种-，指将资金投入到不同的Defi协议中赚取回报\" class=\"headerlink\" title=\"Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]\"></a>Yield Farming(流动性挖矿) [  Yield(收益), Farm(耕种)，指将资金投入到不同的Defi协议中赚取回报 ]</h2>"},{"title":"Oracle(预言机)","_content":"\n# 预言机(Oracle)\n\n```jsx\n什么是预言机？\n```\n\n预言机是指数据馈送，它提取区块链数据源（下链）的数据并将数据存放到区块链（上链）上供智能合约使用。因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可上的。\n\n预言的意思（Oracle）是指古希腊神话中的神谕，由神或者女祭司发表的预言或指示，因此，这里将外部数据引入区块链的机制被称为 Oracle，即预言机\n\n预言机赋予了智能合约使用链下数据输入执行的能力，扩展了去中心化应用的价值，例如，去中心化预测市场依靠预言机提供的关于结果的信息，并且能够使用这些信息验证用户的预测。假设 A 下注了 20 个以太币赌谁将成为下一任美国总统，这种情况，链上的数据中是没有关于下一任总统的信息的，预测市场去中心化应用程序需要预言机来确认选举结果，并判定 A 是否有资格获得赌注\n\n区块链预言机获取验证外部信息（即存储在链下的信息）并将外部信息传送给区块链上运行的智能合约的应用程序。除了拉取链下数据用户并在以太坊进行广播之外，预言机还将信息从区块链推送到外部系统，用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。\n\n预言机充当了一座桥梁，链接区块链上的智能合约与链下数据提供者，如果没有预言机，智能合约智能访问链上的数据，预言机提供了一种使用链下数据处罚智能合约的功能机制。\n\n预言机的分类：\n\n- 数据来源（一种或多种）\n- 信任模型（中心化/去中心化）\n- 系统架构（立即读取或发布订阅）\n- 是否检索外部数据供链上合约使用（输入预言机）\n- 是否将区块量的信息发送给链下应用程序（输出预言机）\n- 在链下执行计算任务（计算预言机）\n\n## 预言机解决了什么问题\n\n智能合约不仅仅只是作为区块链特定地址运行的代码段，更广义来说，智能合约是指满足特定条件后能够执行各方之间协议的**自执行软件程序**\n\n但是问题也在于此，因为以太坊是确定性系统，确定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性和变化\n\n要实现确定性执行，区块链节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制(true/false)问题达成共识，这类问题的示例包括：\n\n- 账户所有者（由公钥识别）是否使用配对私钥签署该交易\n- 该账户是否有足够资金支付这笔交易\n- 这笔交易在该智能合约中是否有效\n\n如果区块链从外部来源（现实世界）接受信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致，以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前的以太币-美元（ETH/USDT）汇率窒执行交易。该汇率会经常变动，甚至会被弃用会黑客攻击，这意味着执行相同合约代码的节点会得出不同的结果\n\n全球会数千个节点处理交易的公共区块链，如以太坊，确定性至关重要，由于没有中心化阻止作为真实性来源，期望节点在进行相同交易后达到相同状态。节点 A 执行智能合约的代码得到结果“3”，而 B 节点运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。\n\n以上就是**区块链从外部来源获取信息的问题**\n\n预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。由于存储在链上的信息是不可更改和公共可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化。\n\n为此，预言机通常由链上运行的智能合约和一些链下组件构成。链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。这类预言机节点可以查询数据源-例如使用 API 并发送交易将请求的数据存储在智能合约的存储中。\n\n总结就是：预言机弥合了区块链和外部环境（如真实世界）的信息缺口，创建了混合智能合约，原理是基于链上合约代码和链下基础设施的结合。\n\n## 什么是预言机问题\n\n如何依赖一个实体或多个实体向区块链引入外部信息（即将信息存储在交易的数据有效负载中），智能合约很容易获取链下数据，但是会有新的问题：\n\n- 如何验证注入信息是从正确来源提取的或者未被篡改\n- 如何确保这些数据始终可用且定期更新。\n\n重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果，这是一个**信任**问题\n\n不同的预言机在解决预言机问题方面采取的方法各不相同，只需要满足以下几点的中几个即可：\n\n- **正确性**：预言机不应导致智能合约基于无效的链下数据触发状态变化。因此，预言机必须保证数据的真实性和完整性-真实性是指数据从正确来源获取，完整性是指数据在发送到链上前保持完好无缺。\n- **可用性**：预言机不应延迟或阻止智能合约执行操作或触发状态变化，该特点要求预言机提供的数据在请求时可用并且不会出现间断。\n- 激励兼容性：预言机激励链下数据提供者向智能合约提交正确的信息。包括可归因性和问责性，可归因性允许将一条外部信息与其提供者关联起来，问责性指的是数据提供者与提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。\n\n## 预言机合约\n\n预言机合约是预言机服务的链上组成部分，它侦听其他合约发出的数据请求，将数据查询转发到预言机及诶单并将返回的数据向客户端合约广播，该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。\n\n以下是合约示例\n\n```jsx\npragma solidity >=0.4.21 <0.6.0;\n\ncontract Oracle {\n  Request[] requests; //list of requests made to the contract\n  uint currentId = 0; //increasing request id\n  uint minQuorum = 2; //minimum number of responses to receive before declaring final result\n  uint totalOracleCount = 3; // Hardcoded oracle count\n\n  // defines a general api request\n  struct Request {\n    uint id;                            //request id\n    string urlToQuery;                  //API url\n    string attributeToFetch;            //json attribute (key) to retrieve in the response\n    string agreedValue;                 //value from key\n    mapping(uint => string) answers;     //answers provided by the oracles\n    mapping(address => uint) quorum;    //oracles which will query the answer (1=oracle hasn't voted, 2=oracle has voted)\n  }\n\n  //event that triggers oracle outside of the blockchain\n  event NewRequest (\n    uint id,\n    string urlToQuery,\n    string attributeToFetch\n  );\n\n  //triggered when there's a consensus on the final result\n  event UpdatedRequest (\n    uint id,\n    string urlToQuery,\n    string attributeToFetch,\n    string agreedValue\n  );\n\n  function createRequest (\n    string memory _urlToQuery,\n    string memory _attributeToFetch\n  )\n  public\n  {\n    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, \"\"));\n    Request storage r = requests[length-1];\n\n    // Hardcoded oracles address\n    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;\n    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;\n    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;\n\n    // launch an event to be detected by oracle outside of blockchain\n    emit NewRequest (\n      currentId,\n      _urlToQuery,\n      _attributeToFetch\n    );\n\n    // increase request id\n    currentId++;\n  }\n\n  //called by the oracle to record its answer\n  function updateRequest (\n    uint _id,\n    string memory _valueRetrieved\n  ) public {\n\n    Request storage currRequest = requests[_id];\n\n    //check if oracle is in the list of trusted oracles\n    //and if the oracle hasn't voted yet\n    if(currRequest.quorum[address(msg.sender)] == 1){\n\n      //marking that this address has voted\n      currRequest.quorum[msg.sender] = 2;\n\n      //iterate through \"array\" of answers until a position if free and save the retrieved value\n      uint tmpI = 0;\n      bool found = false;\n      while(!found) {\n        //find first empty slot\n        if(bytes(currRequest.answers[tmpI]).length == 0){\n          found = true;\n          currRequest.answers[tmpI] = _valueRetrieved;\n        }\n        tmpI++;\n      }\n\n      uint currentQuorum = 0;\n\n      //iterate through oracle list and check if enough oracles(minimum quorum)\n      //have voted the same answer has the current one\n      for(uint i = 0; i < totalOracleCount; i++){\n        bytes memory a = bytes(currRequest.answers[i]);\n        bytes memory b = bytes(_valueRetrieved);\n\n        if(keccak256(a) == keccak256(b)){\n          currentQuorum++;\n          if(currentQuorum >= minQuorum){\n            currRequest.agreedValue = _valueRetrieved;\n            emit UpdatedRequest (\n              currRequest.id,\n              currRequest.urlToQuery,\n              currRequest.attributeToFetch,\n              currRequest.agreedValue\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n预言机的节点的常见任务是，想 api 发送请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上，在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点。\n\n预言机类型：\n\n- 中心化预言机，由单体控制，该实体负责聚合链下信息并按照请求更新预言机合约的数据，中心化预言机效率高，因为他们依赖单一真实性来源，在专有数据集由所有者直接发布且有公认签名的情况下，中心化预言机可能是更好的选择。但是存在低正确性保障和可用性差的问题，中心化预言机的提供者如何关闭服务或者遭遇了黑客的攻击的话，智能合约会面临 Dos 攻击的风险\n- 去中心化预言机，会尝试不同的方法实现数据的正确性，其中包括使用证明来证明返回信息的真实性和完整性。\n\n## 预言机的应用\n\n- 检索金融数据\n  DeFi 应用允许 p2p 贷款，借贷和资产交易，需要获取不同的金融信息，包括汇率数据的资本市场数据，常用的如：Chainlink price Feeds、Compound Protocol 的[开放式喂价工具](https://docs.compound.finance/v2/prices/)、Uniswap 的[时间加权平均价格(TWAP)](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles)\n- 生成可验证的随机性\n  某些区块链的应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能工作，然而，区块链的确定性执行消除了任何随机来源\n  通常方法是伪随机密码函数，例如 blockhash，但是以太坊过渡到权益证明意味着不能再依靠 blockhash 获得链上随机性。可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求，他们必须相信值确实是通过不可预测的机制产生的，并且在传输过程中未被改动。\n  计算预言机则可以解决这一问题，可以安全的生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。\n- 获取事件结果\n  预言机可以创建响应真实事件的智能合约，预言机服务可以允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息。\n- 智能合约自动化\n\n## 预言机应用\n\n- [Chainlink](https://chain.link/)\n- [Witnet](https://witnet.io/)\n- [UMA 预言机](https://uma.xyz/)\n- [Tellor](https://tellor.io/)\n- [Band Protocol](https://bandprotocol.com/)\n- [Provable](https://provable.xyz/)\n- [Paralink](https://paralink.network/)\n- [Dos.Network](https://dos.network/)\n- [Pyth](https://pyth.network/)\n","source":"_posts/oracle.md","raw":"---\ntitle: Oracle(预言机)\n---\n\n# 预言机(Oracle)\n\n```jsx\n什么是预言机？\n```\n\n预言机是指数据馈送，它提取区块链数据源（下链）的数据并将数据存放到区块链（上链）上供智能合约使用。因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可上的。\n\n预言的意思（Oracle）是指古希腊神话中的神谕，由神或者女祭司发表的预言或指示，因此，这里将外部数据引入区块链的机制被称为 Oracle，即预言机\n\n预言机赋予了智能合约使用链下数据输入执行的能力，扩展了去中心化应用的价值，例如，去中心化预测市场依靠预言机提供的关于结果的信息，并且能够使用这些信息验证用户的预测。假设 A 下注了 20 个以太币赌谁将成为下一任美国总统，这种情况，链上的数据中是没有关于下一任总统的信息的，预测市场去中心化应用程序需要预言机来确认选举结果，并判定 A 是否有资格获得赌注\n\n区块链预言机获取验证外部信息（即存储在链下的信息）并将外部信息传送给区块链上运行的智能合约的应用程序。除了拉取链下数据用户并在以太坊进行广播之外，预言机还将信息从区块链推送到外部系统，用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。\n\n预言机充当了一座桥梁，链接区块链上的智能合约与链下数据提供者，如果没有预言机，智能合约智能访问链上的数据，预言机提供了一种使用链下数据处罚智能合约的功能机制。\n\n预言机的分类：\n\n- 数据来源（一种或多种）\n- 信任模型（中心化/去中心化）\n- 系统架构（立即读取或发布订阅）\n- 是否检索外部数据供链上合约使用（输入预言机）\n- 是否将区块量的信息发送给链下应用程序（输出预言机）\n- 在链下执行计算任务（计算预言机）\n\n## 预言机解决了什么问题\n\n智能合约不仅仅只是作为区块链特定地址运行的代码段，更广义来说，智能合约是指满足特定条件后能够执行各方之间协议的**自执行软件程序**\n\n但是问题也在于此，因为以太坊是确定性系统，确定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性和变化\n\n要实现确定性执行，区块链节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制(true/false)问题达成共识，这类问题的示例包括：\n\n- 账户所有者（由公钥识别）是否使用配对私钥签署该交易\n- 该账户是否有足够资金支付这笔交易\n- 这笔交易在该智能合约中是否有效\n\n如果区块链从外部来源（现实世界）接受信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致，以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前的以太币-美元（ETH/USDT）汇率窒执行交易。该汇率会经常变动，甚至会被弃用会黑客攻击，这意味着执行相同合约代码的节点会得出不同的结果\n\n全球会数千个节点处理交易的公共区块链，如以太坊，确定性至关重要，由于没有中心化阻止作为真实性来源，期望节点在进行相同交易后达到相同状态。节点 A 执行智能合约的代码得到结果“3”，而 B 节点运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。\n\n以上就是**区块链从外部来源获取信息的问题**\n\n预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。由于存储在链上的信息是不可更改和公共可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化。\n\n为此，预言机通常由链上运行的智能合约和一些链下组件构成。链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。这类预言机节点可以查询数据源-例如使用 API 并发送交易将请求的数据存储在智能合约的存储中。\n\n总结就是：预言机弥合了区块链和外部环境（如真实世界）的信息缺口，创建了混合智能合约，原理是基于链上合约代码和链下基础设施的结合。\n\n## 什么是预言机问题\n\n如何依赖一个实体或多个实体向区块链引入外部信息（即将信息存储在交易的数据有效负载中），智能合约很容易获取链下数据，但是会有新的问题：\n\n- 如何验证注入信息是从正确来源提取的或者未被篡改\n- 如何确保这些数据始终可用且定期更新。\n\n重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果，这是一个**信任**问题\n\n不同的预言机在解决预言机问题方面采取的方法各不相同，只需要满足以下几点的中几个即可：\n\n- **正确性**：预言机不应导致智能合约基于无效的链下数据触发状态变化。因此，预言机必须保证数据的真实性和完整性-真实性是指数据从正确来源获取，完整性是指数据在发送到链上前保持完好无缺。\n- **可用性**：预言机不应延迟或阻止智能合约执行操作或触发状态变化，该特点要求预言机提供的数据在请求时可用并且不会出现间断。\n- 激励兼容性：预言机激励链下数据提供者向智能合约提交正确的信息。包括可归因性和问责性，可归因性允许将一条外部信息与其提供者关联起来，问责性指的是数据提供者与提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。\n\n## 预言机合约\n\n预言机合约是预言机服务的链上组成部分，它侦听其他合约发出的数据请求，将数据查询转发到预言机及诶单并将返回的数据向客户端合约广播，该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。\n\n以下是合约示例\n\n```jsx\npragma solidity >=0.4.21 <0.6.0;\n\ncontract Oracle {\n  Request[] requests; //list of requests made to the contract\n  uint currentId = 0; //increasing request id\n  uint minQuorum = 2; //minimum number of responses to receive before declaring final result\n  uint totalOracleCount = 3; // Hardcoded oracle count\n\n  // defines a general api request\n  struct Request {\n    uint id;                            //request id\n    string urlToQuery;                  //API url\n    string attributeToFetch;            //json attribute (key) to retrieve in the response\n    string agreedValue;                 //value from key\n    mapping(uint => string) answers;     //answers provided by the oracles\n    mapping(address => uint) quorum;    //oracles which will query the answer (1=oracle hasn't voted, 2=oracle has voted)\n  }\n\n  //event that triggers oracle outside of the blockchain\n  event NewRequest (\n    uint id,\n    string urlToQuery,\n    string attributeToFetch\n  );\n\n  //triggered when there's a consensus on the final result\n  event UpdatedRequest (\n    uint id,\n    string urlToQuery,\n    string attributeToFetch,\n    string agreedValue\n  );\n\n  function createRequest (\n    string memory _urlToQuery,\n    string memory _attributeToFetch\n  )\n  public\n  {\n    uint length = requests.push(Request(currentId, _urlToQuery, _attributeToFetch, \"\"));\n    Request storage r = requests[length-1];\n\n    // Hardcoded oracles address\n    r.quorum[address(0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77)] = 1;\n    r.quorum[address(0xb5346CF224c02186606e5f89EACC21eC25398077)] = 1;\n    r.quorum[address(0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914)] = 1;\n\n    // launch an event to be detected by oracle outside of blockchain\n    emit NewRequest (\n      currentId,\n      _urlToQuery,\n      _attributeToFetch\n    );\n\n    // increase request id\n    currentId++;\n  }\n\n  //called by the oracle to record its answer\n  function updateRequest (\n    uint _id,\n    string memory _valueRetrieved\n  ) public {\n\n    Request storage currRequest = requests[_id];\n\n    //check if oracle is in the list of trusted oracles\n    //and if the oracle hasn't voted yet\n    if(currRequest.quorum[address(msg.sender)] == 1){\n\n      //marking that this address has voted\n      currRequest.quorum[msg.sender] = 2;\n\n      //iterate through \"array\" of answers until a position if free and save the retrieved value\n      uint tmpI = 0;\n      bool found = false;\n      while(!found) {\n        //find first empty slot\n        if(bytes(currRequest.answers[tmpI]).length == 0){\n          found = true;\n          currRequest.answers[tmpI] = _valueRetrieved;\n        }\n        tmpI++;\n      }\n\n      uint currentQuorum = 0;\n\n      //iterate through oracle list and check if enough oracles(minimum quorum)\n      //have voted the same answer has the current one\n      for(uint i = 0; i < totalOracleCount; i++){\n        bytes memory a = bytes(currRequest.answers[i]);\n        bytes memory b = bytes(_valueRetrieved);\n\n        if(keccak256(a) == keccak256(b)){\n          currentQuorum++;\n          if(currentQuorum >= minQuorum){\n            currRequest.agreedValue = _valueRetrieved;\n            emit UpdatedRequest (\n              currRequest.id,\n              currRequest.urlToQuery,\n              currRequest.attributeToFetch,\n              currRequest.agreedValue\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n\n预言机的节点的常见任务是，想 api 发送请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上，在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点。\n\n预言机类型：\n\n- 中心化预言机，由单体控制，该实体负责聚合链下信息并按照请求更新预言机合约的数据，中心化预言机效率高，因为他们依赖单一真实性来源，在专有数据集由所有者直接发布且有公认签名的情况下，中心化预言机可能是更好的选择。但是存在低正确性保障和可用性差的问题，中心化预言机的提供者如何关闭服务或者遭遇了黑客的攻击的话，智能合约会面临 Dos 攻击的风险\n- 去中心化预言机，会尝试不同的方法实现数据的正确性，其中包括使用证明来证明返回信息的真实性和完整性。\n\n## 预言机的应用\n\n- 检索金融数据\n  DeFi 应用允许 p2p 贷款，借贷和资产交易，需要获取不同的金融信息，包括汇率数据的资本市场数据，常用的如：Chainlink price Feeds、Compound Protocol 的[开放式喂价工具](https://docs.compound.finance/v2/prices/)、Uniswap 的[时间加权平均价格(TWAP)](https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles)\n- 生成可验证的随机性\n  某些区块链的应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能工作，然而，区块链的确定性执行消除了任何随机来源\n  通常方法是伪随机密码函数，例如 blockhash，但是以太坊过渡到权益证明意味着不能再依靠 blockhash 获得链上随机性。可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求，他们必须相信值确实是通过不可预测的机制产生的，并且在传输过程中未被改动。\n  计算预言机则可以解决这一问题，可以安全的生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。\n- 获取事件结果\n  预言机可以创建响应真实事件的智能合约，预言机服务可以允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息。\n- 智能合约自动化\n\n## 预言机应用\n\n- [Chainlink](https://chain.link/)\n- [Witnet](https://witnet.io/)\n- [UMA 预言机](https://uma.xyz/)\n- [Tellor](https://tellor.io/)\n- [Band Protocol](https://bandprotocol.com/)\n- [Provable](https://provable.xyz/)\n- [Paralink](https://paralink.network/)\n- [Dos.Network](https://dos.network/)\n- [Pyth](https://pyth.network/)\n","slug":"oracle","published":1,"date":"2024-03-26T07:13:35.915Z","updated":"2024-03-26T07:45:02.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrs000a3jf0gtbfcg13","content":"<h1 id=\"预言机-Oracle\"><a href=\"#预言机-Oracle\" class=\"headerlink\" title=\"预言机(Oracle)\"></a>预言机(Oracle)</h1><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是预言机？</span><br></pre></td></tr></table></figure>\n\n<p>预言机是指数据馈送，它提取区块链数据源（下链）的数据并将数据存放到区块链（上链）上供智能合约使用。因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可上的。</p>\n<p>预言的意思（Oracle）是指古希腊神话中的神谕，由神或者女祭司发表的预言或指示，因此，这里将外部数据引入区块链的机制被称为 Oracle，即预言机</p>\n<p>预言机赋予了智能合约使用链下数据输入执行的能力，扩展了去中心化应用的价值，例如，去中心化预测市场依靠预言机提供的关于结果的信息，并且能够使用这些信息验证用户的预测。假设 A 下注了 20 个以太币赌谁将成为下一任美国总统，这种情况，链上的数据中是没有关于下一任总统的信息的，预测市场去中心化应用程序需要预言机来确认选举结果，并判定 A 是否有资格获得赌注</p>\n<p>区块链预言机获取验证外部信息（即存储在链下的信息）并将外部信息传送给区块链上运行的智能合约的应用程序。除了拉取链下数据用户并在以太坊进行广播之外，预言机还将信息从区块链推送到外部系统，用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。</p>\n<p>预言机充当了一座桥梁，链接区块链上的智能合约与链下数据提供者，如果没有预言机，智能合约智能访问链上的数据，预言机提供了一种使用链下数据处罚智能合约的功能机制。</p>\n<p>预言机的分类：</p>\n<ul>\n<li>数据来源（一种或多种）</li>\n<li>信任模型（中心化&#x2F;去中心化）</li>\n<li>系统架构（立即读取或发布订阅）</li>\n<li>是否检索外部数据供链上合约使用（输入预言机）</li>\n<li>是否将区块量的信息发送给链下应用程序（输出预言机）</li>\n<li>在链下执行计算任务（计算预言机）</li>\n</ul>\n<h2 id=\"预言机解决了什么问题\"><a href=\"#预言机解决了什么问题\" class=\"headerlink\" title=\"预言机解决了什么问题\"></a>预言机解决了什么问题</h2><p>智能合约不仅仅只是作为区块链特定地址运行的代码段，更广义来说，智能合约是指满足特定条件后能够执行各方之间协议的<strong>自执行软件程序</strong></p>\n<p>但是问题也在于此，因为以太坊是确定性系统，确定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性和变化</p>\n<p>要实现确定性执行，区块链节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制(true&#x2F;false)问题达成共识，这类问题的示例包括：</p>\n<ul>\n<li>账户所有者（由公钥识别）是否使用配对私钥签署该交易</li>\n<li>该账户是否有足够资金支付这笔交易</li>\n<li>这笔交易在该智能合约中是否有效</li>\n</ul>\n<p>如果区块链从外部来源（现实世界）接受信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致，以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前的以太币-美元（ETH&#x2F;USDT）汇率窒执行交易。该汇率会经常变动，甚至会被弃用会黑客攻击，这意味着执行相同合约代码的节点会得出不同的结果</p>\n<p>全球会数千个节点处理交易的公共区块链，如以太坊，确定性至关重要，由于没有中心化阻止作为真实性来源，期望节点在进行相同交易后达到相同状态。节点 A 执行智能合约的代码得到结果“3”，而 B 节点运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。</p>\n<p>以上就是<strong>区块链从外部来源获取信息的问题</strong></p>\n<p>预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。由于存储在链上的信息是不可更改和公共可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化。</p>\n<p>为此，预言机通常由链上运行的智能合约和一些链下组件构成。链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。这类预言机节点可以查询数据源-例如使用 API 并发送交易将请求的数据存储在智能合约的存储中。</p>\n<p>总结就是：预言机弥合了区块链和外部环境（如真实世界）的信息缺口，创建了混合智能合约，原理是基于链上合约代码和链下基础设施的结合。</p>\n<h2 id=\"什么是预言机问题\"><a href=\"#什么是预言机问题\" class=\"headerlink\" title=\"什么是预言机问题\"></a>什么是预言机问题</h2><p>如何依赖一个实体或多个实体向区块链引入外部信息（即将信息存储在交易的数据有效负载中），智能合约很容易获取链下数据，但是会有新的问题：</p>\n<ul>\n<li>如何验证注入信息是从正确来源提取的或者未被篡改</li>\n<li>如何确保这些数据始终可用且定期更新。</li>\n</ul>\n<p>重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果，这是一个<strong>信任</strong>问题</p>\n<p>不同的预言机在解决预言机问题方面采取的方法各不相同，只需要满足以下几点的中几个即可：</p>\n<ul>\n<li><strong>正确性</strong>：预言机不应导致智能合约基于无效的链下数据触发状态变化。因此，预言机必须保证数据的真实性和完整性-真实性是指数据从正确来源获取，完整性是指数据在发送到链上前保持完好无缺。</li>\n<li><strong>可用性</strong>：预言机不应延迟或阻止智能合约执行操作或触发状态变化，该特点要求预言机提供的数据在请求时可用并且不会出现间断。</li>\n<li>激励兼容性：预言机激励链下数据提供者向智能合约提交正确的信息。包括可归因性和问责性，可归因性允许将一条外部信息与其提供者关联起来，问责性指的是数据提供者与提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。</li>\n</ul>\n<h2 id=\"预言机合约\"><a href=\"#预言机合约\" class=\"headerlink\" title=\"预言机合约\"></a>预言机合约</h2><p>预言机合约是预言机服务的链上组成部分，它侦听其他合约发出的数据请求，将数据查询转发到预言机及诶单并将返回的数据向客户端合约广播，该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。</p>\n<p>以下是合约示例</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity &gt;=<span class=\"number\">0.4</span><span class=\"number\">.21</span> &lt;<span class=\"number\">0.6</span><span class=\"number\">.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">contract <span class=\"title class_\">Oracle</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Request</span>[] requests; <span class=\"comment\">//list of requests made to the contract</span></span><br><span class=\"line\">  uint currentId = <span class=\"number\">0</span>; <span class=\"comment\">//increasing request id</span></span><br><span class=\"line\">  uint minQuorum = <span class=\"number\">2</span>; <span class=\"comment\">//minimum number of responses to receive before declaring final result</span></span><br><span class=\"line\">  uint totalOracleCount = <span class=\"number\">3</span>; <span class=\"comment\">// Hardcoded oracle count</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// defines a general api request</span></span><br><span class=\"line\">  struct <span class=\"title class_\">Request</span> &#123;</span><br><span class=\"line\">    uint id;                            <span class=\"comment\">//request id</span></span><br><span class=\"line\">    string urlToQuery;                  <span class=\"comment\">//API url</span></span><br><span class=\"line\">    string attributeToFetch;            <span class=\"comment\">//json attribute (key) to retrieve in the response</span></span><br><span class=\"line\">    string agreedValue;                 <span class=\"comment\">//value from key</span></span><br><span class=\"line\">    <span class=\"title function_\">mapping</span>(<span class=\"function\"><span class=\"params\">uint</span> =&gt;</span> string) answers;     <span class=\"comment\">//answers provided by the oracles</span></span><br><span class=\"line\">    <span class=\"title function_\">mapping</span>(<span class=\"function\"><span class=\"params\">address</span> =&gt;</span> uint) quorum;    <span class=\"comment\">//oracles which will query the answer (1=oracle hasn&#x27;t voted, 2=oracle has voted)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//event that triggers oracle outside of the blockchain</span></span><br><span class=\"line\">  event <span class=\"title class_\">NewRequest</span> (</span><br><span class=\"line\">    uint id,</span><br><span class=\"line\">    string urlToQuery,</span><br><span class=\"line\">    string attributeToFetch</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//triggered when there&#x27;s a consensus on the final result</span></span><br><span class=\"line\">  event <span class=\"title class_\">UpdatedRequest</span> (</span><br><span class=\"line\">    uint id,</span><br><span class=\"line\">    string urlToQuery,</span><br><span class=\"line\">    string attributeToFetch,</span><br><span class=\"line\">    string agreedValue</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">createRequest</span> (</span><br><span class=\"line\">    string memory _urlToQuery,</span><br><span class=\"line\">    string memory _attributeToFetch</span><br><span class=\"line\">  )</span><br><span class=\"line\">  public</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    uint length = requests.<span class=\"title function_\">push</span>(<span class=\"title class_\">Request</span>(currentId, _urlToQuery, _attributeToFetch, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    <span class=\"title class_\">Request</span> storage r = requests[length-<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hardcoded oracles address</span></span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0xb5346CF224c02186606e5f89EACC21eC25398077</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// launch an event to be detected by oracle outside of blockchain</span></span><br><span class=\"line\">    emit <span class=\"title class_\">NewRequest</span> (</span><br><span class=\"line\">      currentId,</span><br><span class=\"line\">      _urlToQuery,</span><br><span class=\"line\">      _attributeToFetch</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increase request id</span></span><br><span class=\"line\">    currentId++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//called by the oracle to record its answer</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">updateRequest</span> (</span><br><span class=\"line\">    uint _id,</span><br><span class=\"line\">    string memory _valueRetrieved</span><br><span class=\"line\">  ) public &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Request</span> storage currRequest = requests[_id];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//check if oracle is in the list of trusted oracles</span></span><br><span class=\"line\">    <span class=\"comment\">//and if the oracle hasn&#x27;t voted yet</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(currRequest.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(msg.<span class=\"property\">sender</span>)] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//marking that this address has voted</span></span><br><span class=\"line\">      currRequest.<span class=\"property\">quorum</span>[msg.<span class=\"property\">sender</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//iterate through &quot;array&quot; of answers until a position if free and save the retrieved value</span></span><br><span class=\"line\">      uint tmpI = <span class=\"number\">0</span>;</span><br><span class=\"line\">      bool found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(!found) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//find first empty slot</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"title function_\">bytes</span>(currRequest.<span class=\"property\">answers</span>[tmpI]).<span class=\"property\">length</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">          found = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          currRequest.<span class=\"property\">answers</span>[tmpI] = _valueRetrieved;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmpI++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      uint currentQuorum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//iterate through oracle list and check if enough oracles(minimum quorum)</span></span><br><span class=\"line\">      <span class=\"comment\">//have voted the same answer has the current one</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(uint i = <span class=\"number\">0</span>; i &lt; totalOracleCount; i++)&#123;</span><br><span class=\"line\">        bytes memory a = <span class=\"title function_\">bytes</span>(currRequest.<span class=\"property\">answers</span>[i]);</span><br><span class=\"line\">        bytes memory b = <span class=\"title function_\">bytes</span>(_valueRetrieved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"title function_\">keccak256</span>(a) == <span class=\"title function_\">keccak256</span>(b))&#123;</span><br><span class=\"line\">          currentQuorum++;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(currentQuorum &gt;= minQuorum)&#123;</span><br><span class=\"line\">            currRequest.<span class=\"property\">agreedValue</span> = _valueRetrieved;</span><br><span class=\"line\">            emit <span class=\"title class_\">UpdatedRequest</span> (</span><br><span class=\"line\">              currRequest.<span class=\"property\">id</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">urlToQuery</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">attributeToFetch</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">agreedValue</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>预言机的节点的常见任务是，想 api 发送请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上，在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点。</p>\n<p>预言机类型：</p>\n<ul>\n<li>中心化预言机，由单体控制，该实体负责聚合链下信息并按照请求更新预言机合约的数据，中心化预言机效率高，因为他们依赖单一真实性来源，在专有数据集由所有者直接发布且有公认签名的情况下，中心化预言机可能是更好的选择。但是存在低正确性保障和可用性差的问题，中心化预言机的提供者如何关闭服务或者遭遇了黑客的攻击的话，智能合约会面临 Dos 攻击的风险</li>\n<li>去中心化预言机，会尝试不同的方法实现数据的正确性，其中包括使用证明来证明返回信息的真实性和完整性。</li>\n</ul>\n<h2 id=\"预言机的应用\"><a href=\"#预言机的应用\" class=\"headerlink\" title=\"预言机的应用\"></a>预言机的应用</h2><ul>\n<li>检索金融数据<br>DeFi 应用允许 p2p 贷款，借贷和资产交易，需要获取不同的金融信息，包括汇率数据的资本市场数据，常用的如：Chainlink price Feeds、Compound Protocol 的<a class=\"link\"   href=\"https://docs.compound.finance/v2/prices/\" >开放式喂价工具<i class=\"fas fa-external-link-alt\"></i></a>、Uniswap 的<a class=\"link\"   href=\"https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles\" >时间加权平均价格(TWAP)<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>生成可验证的随机性<br>某些区块链的应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能工作，然而，区块链的确定性执行消除了任何随机来源<br>通常方法是伪随机密码函数，例如 blockhash，但是以太坊过渡到权益证明意味着不能再依靠 blockhash 获得链上随机性。可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求，他们必须相信值确实是通过不可预测的机制产生的，并且在传输过程中未被改动。<br>计算预言机则可以解决这一问题，可以安全的生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。</li>\n<li>获取事件结果<br>预言机可以创建响应真实事件的智能合约，预言机服务可以允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息。</li>\n<li>智能合约自动化</li>\n</ul>\n<h2 id=\"预言机应用\"><a href=\"#预言机应用\" class=\"headerlink\" title=\"预言机应用\"></a>预言机应用</h2><ul>\n<li><a class=\"link\"   href=\"https://chain.link/\" >Chainlink<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://witnet.io/\" >Witnet<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://uma.xyz/\" >UMA 预言机<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://tellor.io/\" >Tellor<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://bandprotocol.com/\" >Band Protocol<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://provable.xyz/\" >Provable<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://paralink.network/\" >Paralink<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://dos.network/\" >Dos.Network<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://pyth.network/\" >Pyth<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"预言机-Oracle\"><a href=\"#预言机-Oracle\" class=\"headerlink\" title=\"预言机(Oracle)\"></a>预言机(Oracle)</h1><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">什么是预言机？</span><br></pre></td></tr></table></figure>\n\n<p>预言机是指数据馈送，它提取区块链数据源（下链）的数据并将数据存放到区块链（上链）上供智能合约使用。因为运行在以太坊上的智能合约无法访问存储在区块链网络之外的信息，预言机是必不可上的。</p>\n<p>预言的意思（Oracle）是指古希腊神话中的神谕，由神或者女祭司发表的预言或指示，因此，这里将外部数据引入区块链的机制被称为 Oracle，即预言机</p>\n<p>预言机赋予了智能合约使用链下数据输入执行的能力，扩展了去中心化应用的价值，例如，去中心化预测市场依靠预言机提供的关于结果的信息，并且能够使用这些信息验证用户的预测。假设 A 下注了 20 个以太币赌谁将成为下一任美国总统，这种情况，链上的数据中是没有关于下一任总统的信息的，预测市场去中心化应用程序需要预言机来确认选举结果，并判定 A 是否有资格获得赌注</p>\n<p>区块链预言机获取验证外部信息（即存储在链下的信息）并将外部信息传送给区块链上运行的智能合约的应用程序。除了拉取链下数据用户并在以太坊进行广播之外，预言机还将信息从区块链推送到外部系统，用户通过以太坊交易发送费用后解锁智能锁的预言机就是一个推送信息的示例。</p>\n<p>预言机充当了一座桥梁，链接区块链上的智能合约与链下数据提供者，如果没有预言机，智能合约智能访问链上的数据，预言机提供了一种使用链下数据处罚智能合约的功能机制。</p>\n<p>预言机的分类：</p>\n<ul>\n<li>数据来源（一种或多种）</li>\n<li>信任模型（中心化&#x2F;去中心化）</li>\n<li>系统架构（立即读取或发布订阅）</li>\n<li>是否检索外部数据供链上合约使用（输入预言机）</li>\n<li>是否将区块量的信息发送给链下应用程序（输出预言机）</li>\n<li>在链下执行计算任务（计算预言机）</li>\n</ul>\n<h2 id=\"预言机解决了什么问题\"><a href=\"#预言机解决了什么问题\" class=\"headerlink\" title=\"预言机解决了什么问题\"></a>预言机解决了什么问题</h2><p>智能合约不仅仅只是作为区块链特定地址运行的代码段，更广义来说，智能合约是指满足特定条件后能够执行各方之间协议的<strong>自执行软件程序</strong></p>\n<p>但是问题也在于此，因为以太坊是确定性系统，确定性系统是指在给定初始状态和特定输入时总是产生相同结果的系统，即在使用输入计算输出的过程中不存在随机性和变化</p>\n<p>要实现确定性执行，区块链节点限制为通过仅使用存储在区块链本身中的数据就简单的二进制(true&#x2F;false)问题达成共识，这类问题的示例包括：</p>\n<ul>\n<li>账户所有者（由公钥识别）是否使用配对私钥签署该交易</li>\n<li>该账户是否有足够资金支付这笔交易</li>\n<li>这笔交易在该智能合约中是否有效</li>\n</ul>\n<p>如果区块链从外部来源（现实世界）接受信息，确定性将不可能实现，阻止节点就区块链状态变化的有效性达成一致，以一个智能合约为例，该合约根据从一个传统价格应用程序接口获得的当前的以太币-美元（ETH&#x2F;USDT）汇率窒执行交易。该汇率会经常变动，甚至会被弃用会黑客攻击，这意味着执行相同合约代码的节点会得出不同的结果</p>\n<p>全球会数千个节点处理交易的公共区块链，如以太坊，确定性至关重要，由于没有中心化阻止作为真实性来源，期望节点在进行相同交易后达到相同状态。节点 A 执行智能合约的代码得到结果“3”，而 B 节点运行相同交易后得到“7”，这将打破共识并消除以太坊作为去中心化计算平台的价值。</p>\n<p>以上就是<strong>区块链从外部来源获取信息的问题</strong></p>\n<p>预言机解决了这一问题，它从链下来源获取信息并存储在区块链上供智能合约使用。由于存储在链上的信息是不可更改和公共可用的，以太坊节点可以安全地使用预言机导入的链下数据计算状态变化。</p>\n<p>为此，预言机通常由链上运行的智能合约和一些链下组件构成。链上合约接收其他智能合约的数据请求，并将这些请求传送给链下组件（称为预言机节点）。这类预言机节点可以查询数据源-例如使用 API 并发送交易将请求的数据存储在智能合约的存储中。</p>\n<p>总结就是：预言机弥合了区块链和外部环境（如真实世界）的信息缺口，创建了混合智能合约，原理是基于链上合约代码和链下基础设施的结合。</p>\n<h2 id=\"什么是预言机问题\"><a href=\"#什么是预言机问题\" class=\"headerlink\" title=\"什么是预言机问题\"></a>什么是预言机问题</h2><p>如何依赖一个实体或多个实体向区块链引入外部信息（即将信息存储在交易的数据有效负载中），智能合约很容易获取链下数据，但是会有新的问题：</p>\n<ul>\n<li>如何验证注入信息是从正确来源提取的或者未被篡改</li>\n<li>如何确保这些数据始终可用且定期更新。</li>\n</ul>\n<p>重要的是确保来自预言机的数据是正确的，否则智能合约执行会产生错误结果，这是一个<strong>信任</strong>问题</p>\n<p>不同的预言机在解决预言机问题方面采取的方法各不相同，只需要满足以下几点的中几个即可：</p>\n<ul>\n<li><strong>正确性</strong>：预言机不应导致智能合约基于无效的链下数据触发状态变化。因此，预言机必须保证数据的真实性和完整性-真实性是指数据从正确来源获取，完整性是指数据在发送到链上前保持完好无缺。</li>\n<li><strong>可用性</strong>：预言机不应延迟或阻止智能合约执行操作或触发状态变化，该特点要求预言机提供的数据在请求时可用并且不会出现间断。</li>\n<li>激励兼容性：预言机激励链下数据提供者向智能合约提交正确的信息。包括可归因性和问责性，可归因性允许将一条外部信息与其提供者关联起来，问责性指的是数据提供者与提供的信息绑定，这样就可以根据所提供信息的质量对他们进行奖励或惩罚。</li>\n</ul>\n<h2 id=\"预言机合约\"><a href=\"#预言机合约\" class=\"headerlink\" title=\"预言机合约\"></a>预言机合约</h2><p>预言机合约是预言机服务的链上组成部分，它侦听其他合约发出的数据请求，将数据查询转发到预言机及诶单并将返回的数据向客户端合约广播，该合约还可以对返回的数据点进行一些计算，以产生聚合值并发送给请求合约。</p>\n<p>以下是合约示例</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pragma solidity &gt;=<span class=\"number\">0.4</span><span class=\"number\">.21</span> &lt;<span class=\"number\">0.6</span><span class=\"number\">.0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">contract <span class=\"title class_\">Oracle</span> &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Request</span>[] requests; <span class=\"comment\">//list of requests made to the contract</span></span><br><span class=\"line\">  uint currentId = <span class=\"number\">0</span>; <span class=\"comment\">//increasing request id</span></span><br><span class=\"line\">  uint minQuorum = <span class=\"number\">2</span>; <span class=\"comment\">//minimum number of responses to receive before declaring final result</span></span><br><span class=\"line\">  uint totalOracleCount = <span class=\"number\">3</span>; <span class=\"comment\">// Hardcoded oracle count</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// defines a general api request</span></span><br><span class=\"line\">  struct <span class=\"title class_\">Request</span> &#123;</span><br><span class=\"line\">    uint id;                            <span class=\"comment\">//request id</span></span><br><span class=\"line\">    string urlToQuery;                  <span class=\"comment\">//API url</span></span><br><span class=\"line\">    string attributeToFetch;            <span class=\"comment\">//json attribute (key) to retrieve in the response</span></span><br><span class=\"line\">    string agreedValue;                 <span class=\"comment\">//value from key</span></span><br><span class=\"line\">    <span class=\"title function_\">mapping</span>(<span class=\"function\"><span class=\"params\">uint</span> =&gt;</span> string) answers;     <span class=\"comment\">//answers provided by the oracles</span></span><br><span class=\"line\">    <span class=\"title function_\">mapping</span>(<span class=\"function\"><span class=\"params\">address</span> =&gt;</span> uint) quorum;    <span class=\"comment\">//oracles which will query the answer (1=oracle hasn&#x27;t voted, 2=oracle has voted)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//event that triggers oracle outside of the blockchain</span></span><br><span class=\"line\">  event <span class=\"title class_\">NewRequest</span> (</span><br><span class=\"line\">    uint id,</span><br><span class=\"line\">    string urlToQuery,</span><br><span class=\"line\">    string attributeToFetch</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//triggered when there&#x27;s a consensus on the final result</span></span><br><span class=\"line\">  event <span class=\"title class_\">UpdatedRequest</span> (</span><br><span class=\"line\">    uint id,</span><br><span class=\"line\">    string urlToQuery,</span><br><span class=\"line\">    string attributeToFetch,</span><br><span class=\"line\">    string agreedValue</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">createRequest</span> (</span><br><span class=\"line\">    string memory _urlToQuery,</span><br><span class=\"line\">    string memory _attributeToFetch</span><br><span class=\"line\">  )</span><br><span class=\"line\">  public</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    uint length = requests.<span class=\"title function_\">push</span>(<span class=\"title class_\">Request</span>(currentId, _urlToQuery, _attributeToFetch, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    <span class=\"title class_\">Request</span> storage r = requests[length-<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hardcoded oracles address</span></span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0x6c2339b46F41a06f09CA0051ddAD54D1e582bA77</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0xb5346CF224c02186606e5f89EACC21eC25398077</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    r.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(<span class=\"number\">0xa2997F1CA363D11a0a35bB1Ac0Ff7849bc13e914</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// launch an event to be detected by oracle outside of blockchain</span></span><br><span class=\"line\">    emit <span class=\"title class_\">NewRequest</span> (</span><br><span class=\"line\">      currentId,</span><br><span class=\"line\">      _urlToQuery,</span><br><span class=\"line\">      _attributeToFetch</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// increase request id</span></span><br><span class=\"line\">    currentId++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//called by the oracle to record its answer</span></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">updateRequest</span> (</span><br><span class=\"line\">    uint _id,</span><br><span class=\"line\">    string memory _valueRetrieved</span><br><span class=\"line\">  ) public &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title class_\">Request</span> storage currRequest = requests[_id];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//check if oracle is in the list of trusted oracles</span></span><br><span class=\"line\">    <span class=\"comment\">//and if the oracle hasn&#x27;t voted yet</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(currRequest.<span class=\"property\">quorum</span>[<span class=\"title function_\">address</span>(msg.<span class=\"property\">sender</span>)] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//marking that this address has voted</span></span><br><span class=\"line\">      currRequest.<span class=\"property\">quorum</span>[msg.<span class=\"property\">sender</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//iterate through &quot;array&quot; of answers until a position if free and save the retrieved value</span></span><br><span class=\"line\">      uint tmpI = <span class=\"number\">0</span>;</span><br><span class=\"line\">      bool found = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(!found) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//find first empty slot</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"title function_\">bytes</span>(currRequest.<span class=\"property\">answers</span>[tmpI]).<span class=\"property\">length</span> == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">          found = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          currRequest.<span class=\"property\">answers</span>[tmpI] = _valueRetrieved;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tmpI++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      uint currentQuorum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//iterate through oracle list and check if enough oracles(minimum quorum)</span></span><br><span class=\"line\">      <span class=\"comment\">//have voted the same answer has the current one</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(uint i = <span class=\"number\">0</span>; i &lt; totalOracleCount; i++)&#123;</span><br><span class=\"line\">        bytes memory a = <span class=\"title function_\">bytes</span>(currRequest.<span class=\"property\">answers</span>[i]);</span><br><span class=\"line\">        bytes memory b = <span class=\"title function_\">bytes</span>(_valueRetrieved);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"title function_\">keccak256</span>(a) == <span class=\"title function_\">keccak256</span>(b))&#123;</span><br><span class=\"line\">          currentQuorum++;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(currentQuorum &gt;= minQuorum)&#123;</span><br><span class=\"line\">            currRequest.<span class=\"property\">agreedValue</span> = _valueRetrieved;</span><br><span class=\"line\">            emit <span class=\"title class_\">UpdatedRequest</span> (</span><br><span class=\"line\">              currRequest.<span class=\"property\">id</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">urlToQuery</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">attributeToFetch</span>,</span><br><span class=\"line\">              currRequest.<span class=\"property\">agreedValue</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>预言机的节点的常见任务是，想 api 发送请求，解析响应以提取相关数据，设置为区块链可读的输出格式，并通过将输入包含在预言机合约的交易中将其发送到链上，在利用“真实性证明”证明所提交信息的有效性和完整性时，可能也会用到预言机节点。</p>\n<p>预言机类型：</p>\n<ul>\n<li>中心化预言机，由单体控制，该实体负责聚合链下信息并按照请求更新预言机合约的数据，中心化预言机效率高，因为他们依赖单一真实性来源，在专有数据集由所有者直接发布且有公认签名的情况下，中心化预言机可能是更好的选择。但是存在低正确性保障和可用性差的问题，中心化预言机的提供者如何关闭服务或者遭遇了黑客的攻击的话，智能合约会面临 Dos 攻击的风险</li>\n<li>去中心化预言机，会尝试不同的方法实现数据的正确性，其中包括使用证明来证明返回信息的真实性和完整性。</li>\n</ul>\n<h2 id=\"预言机的应用\"><a href=\"#预言机的应用\" class=\"headerlink\" title=\"预言机的应用\"></a>预言机的应用</h2><ul>\n<li>检索金融数据<br>DeFi 应用允许 p2p 贷款，借贷和资产交易，需要获取不同的金融信息，包括汇率数据的资本市场数据，常用的如：Chainlink price Feeds、Compound Protocol 的<a class=\"link\"   href=\"https://docs.compound.finance/v2/prices/\" >开放式喂价工具<i class=\"fas fa-external-link-alt\"></i></a>、Uniswap 的<a class=\"link\"   href=\"https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles\" >时间加权平均价格(TWAP)<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li>生成可验证的随机性<br>某些区块链的应用程序（如基于区块链的游戏或彩票方案），需要高度的不可预测性和随机性才能工作，然而，区块链的确定性执行消除了任何随机来源<br>通常方法是伪随机密码函数，例如 blockhash，但是以太坊过渡到权益证明意味着不能再依靠 blockhash 获得链上随机性。可以在链下生成随机值并发送到链上，但这样做对用户有很高的信任要求，他们必须相信值确实是通过不可预测的机制产生的，并且在传输过程中未被改动。<br>计算预言机则可以解决这一问题，可以安全的生成链下随机结果并连同证实该过程不可预测性的加密证明一起在链上广播。</li>\n<li>获取事件结果<br>预言机可以创建响应真实事件的智能合约，预言机服务可以允许合约通过链下组件连接到外部应用程序接口并使用来自这些数据源的信息。</li>\n<li>智能合约自动化</li>\n</ul>\n<h2 id=\"预言机应用\"><a href=\"#预言机应用\" class=\"headerlink\" title=\"预言机应用\"></a>预言机应用</h2><ul>\n<li><a class=\"link\"   href=\"https://chain.link/\" >Chainlink<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://witnet.io/\" >Witnet<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://uma.xyz/\" >UMA 预言机<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://tellor.io/\" >Tellor<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://bandprotocol.com/\" >Band Protocol<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://provable.xyz/\" >Provable<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://paralink.network/\" >Paralink<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://dos.network/\" >Dos.Network<i class=\"fas fa-external-link-alt\"></i></a></li>\n<li><a class=\"link\"   href=\"https://pyth.network/\" >Pyth<i class=\"fas fa-external-link-alt\"></i></a></li>\n</ul>\n"},{"title":"Gitlab-Runners 配置","_content":"\n# gitlab-runners 流程配置\n\n项目部署的流程如下:\n\n- 将项目打包(build)\n- 启动 web 服务器（如 nginx）\n- 将打包后的文件上传到 web 服务器的指定目录下\n  例如：scp -r ./buildDir/\\* 目标服务器名称@目标服务器 ip:目标服务器下 nginx 的 root 配置目录，在当前目录下执行\n- 重启 nginx（或者其他 web 服务器）\n\ngitlab-CICD 就是要将以上的流程自动化，推送项目代码之后就能自动执行这些流程步骤。\n\n**使用 gitlab-runner 作为执行构建任务的执行器**\n\n首先安装 gitlab-runner\n\n1. bash 安装。2. docker 安装。3. 官网安装包下载\n\n> bash 安装\n\n```bash\n# bash 安装\nsudo apt-get update\nsudo apt-get install gitlab-runner\n```\n\n> docker 安装\n\n```bash\n# docker 安装\n# 拉取镜像\ndocker pull gitlab/gitlab-runner\n# 启动容器\ndocker run -d --name gitlab-runner --restart always \\\n  -v /opt/gitlab-runner/config:/etc/gitlab-runner \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  gitlab/gitlab-runner:latest\n# 进入容器\ndocker exec -it gitlab-runner bash\n```\n\n> 安装包安装\n\nhttps://docs.gitlab.com/runner/install/linux-repository.html\n\n```bash\n# 版本较低\nsudo wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64\n\n# 添加执行权限\nsudo chmod +x /usr/local/bin/gitlab-runner\n# 创建gitlab runner用户\nsudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash\n```\n\n> 注册 runner(可注册多个不同 token 的 runners)\n\n```bash\n注册gitlab runner\n# 在容器内或者服务器内执行\nsudo gitlab-runner register\n# 注册过程需要提供一些信息\n\t- gitlab 实例的url\n\t- 注册token，可以在gitlab的runner设置页面中获取\n\t- runner的描述\n\t- runner的标签(tags)\n\t- 是否允许runner在没有tag的作业上运行\n\n```\n\n> 配置 gitlab-runner，在/etc/gitlab-runner/config.toml 文件中进行,主要配置一些并发作业数，日志级别等\n\n> 启动 runner\n\n```bash\nsudo gitlab-runner start\nsudo gitlab-runner restart\n```\n\n出现以下提示说明已经成功了\n\n```bash\nRuntime platform  arch=amd64 os=linux pid=55297 revision=656c1943 version=16.9.0\n```\n\n> 验证 runner 配置\n\n```bash\nsudo gitlab-runner verify\n```\n\n> runner 设置完成之后，进入到 gitlab，点击查看 CICD 部分，可以看到注册好的 runner，然后在项目中添加配置文件.gitlab-ci.yml\n\n```yaml\nstages: # List of stages for jobs, and their order of execution\n  - install\n  - build\n  - deploy\n\nvariables:\n  NPM_REGISTRY: https://registry.npm.taobao.org\n\ncache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - node_modules/\n\ninstall-job:\n  stage: install\n  # image: node:latest\n  script:\n    - echo \"starting install packages\"\n    # - npm install\n    - echo \"Complete installed packages\"\n  only:\n    - main # 仅在main分支部署\n\nbuild-job: # This job runs in the build stage, which runs first.\n  stage: build\n  image: node:latest\n  dependencies:\n    - install-job # 确保在 build 之前运行 install 作业\n  script:\n    - echo \"Start Building the code...\"\n    - npm install\n    - npm run build\n    - echo \"Building Code complete.\"\n  artifacts:\n    paths:\n      - out/\n  only:\n    - main # 仅在main分支部署\n\ndeploy-job: # This job runs in the deploy stage.\n  stage: deploy # It only runs when *both* jobs in the test stage complete successfully.\n  image: alpine:latest\n  dependencies:\n    - build-job\n  before_script:\n    - sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories\n    - apk update\n    - apk add --no-cache openssh-client\n    - mkdir -p ~/.ssh\n    - chmod 700 ~/.ssh\n    - echo \"${SSH_PRIVATE_KEY}\" > ~/.ssh/id_rsa\n    - chmod 600 ~/.ssh/id_rsa\n    - ls out/\n  script:\n    - echo \"Deploying application...\"\n    - scp -r -o \"StrictHostKeyChecking=no\" ./out/* root@10.131.130.113:/home/wiki/\n    - echo \"Files copied, restarting Nginx...\"\n    - ssh -o \"StrictHostKeyChecking=no\" $SSH_ROOT@$SSH_HOST \"sudo nginx -s reload\"\n    - echo \"Application successfully deployed.\"\n  only:\n    - main # 仅在main分支部署\n```\n\n- 配置完成之后，通过 git push origin main 就会触发构建任务\n  install → build → deploy\n\ndeploy 阶段有 scp 和 nginx restart 操作\n\nscp 首先要在 alpine 镜像构建容器的时候先进行 ssh 密钥对认证\n\n- 在容器内部新建.ssh 目录，\n- 将 gitlab 的秘密变量私钥 SSH_PRIVATE_KEY 复制到.ssh/id_rsa 文件，\n- 在部署服务器中的.ssh/authrization_key，添加对应的公钥，目的是为了 ssh 免密码登录\n\n然后进行 scp 复制构建产物到服务器的对应目录\n\n重启 web 服务器\n\ngitlab-runner cicd 流程结束，代码部署成功\n\n```bash\n# nginx.conf示例\nserver {\n        listen  8000;\n        server_name     localhost;\n        charset utf-8;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        add_header Content-Security-Policy \" object-src 'none'; script-'self' 'unsafe-inline' \";\n        add_header  X-Frame-Options SAMEORIGIN;\n        add_header X-Content-Type-Options nosniff;\n        location / {\n          root  /home/wiki; # /home/wiki 就是前端资源部署的位置\n          try_files $uri $uri/ /index.html;\n          index index.html index.htm;\n        }\n    }\n```\n","source":"_posts/runners.md","raw":"---\ntitle: Gitlab-Runners 配置\n---\n\n# gitlab-runners 流程配置\n\n项目部署的流程如下:\n\n- 将项目打包(build)\n- 启动 web 服务器（如 nginx）\n- 将打包后的文件上传到 web 服务器的指定目录下\n  例如：scp -r ./buildDir/\\* 目标服务器名称@目标服务器 ip:目标服务器下 nginx 的 root 配置目录，在当前目录下执行\n- 重启 nginx（或者其他 web 服务器）\n\ngitlab-CICD 就是要将以上的流程自动化，推送项目代码之后就能自动执行这些流程步骤。\n\n**使用 gitlab-runner 作为执行构建任务的执行器**\n\n首先安装 gitlab-runner\n\n1. bash 安装。2. docker 安装。3. 官网安装包下载\n\n> bash 安装\n\n```bash\n# bash 安装\nsudo apt-get update\nsudo apt-get install gitlab-runner\n```\n\n> docker 安装\n\n```bash\n# docker 安装\n# 拉取镜像\ndocker pull gitlab/gitlab-runner\n# 启动容器\ndocker run -d --name gitlab-runner --restart always \\\n  -v /opt/gitlab-runner/config:/etc/gitlab-runner \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  gitlab/gitlab-runner:latest\n# 进入容器\ndocker exec -it gitlab-runner bash\n```\n\n> 安装包安装\n\nhttps://docs.gitlab.com/runner/install/linux-repository.html\n\n```bash\n# 版本较低\nsudo wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64\n\n# 添加执行权限\nsudo chmod +x /usr/local/bin/gitlab-runner\n# 创建gitlab runner用户\nsudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash\n```\n\n> 注册 runner(可注册多个不同 token 的 runners)\n\n```bash\n注册gitlab runner\n# 在容器内或者服务器内执行\nsudo gitlab-runner register\n# 注册过程需要提供一些信息\n\t- gitlab 实例的url\n\t- 注册token，可以在gitlab的runner设置页面中获取\n\t- runner的描述\n\t- runner的标签(tags)\n\t- 是否允许runner在没有tag的作业上运行\n\n```\n\n> 配置 gitlab-runner，在/etc/gitlab-runner/config.toml 文件中进行,主要配置一些并发作业数，日志级别等\n\n> 启动 runner\n\n```bash\nsudo gitlab-runner start\nsudo gitlab-runner restart\n```\n\n出现以下提示说明已经成功了\n\n```bash\nRuntime platform  arch=amd64 os=linux pid=55297 revision=656c1943 version=16.9.0\n```\n\n> 验证 runner 配置\n\n```bash\nsudo gitlab-runner verify\n```\n\n> runner 设置完成之后，进入到 gitlab，点击查看 CICD 部分，可以看到注册好的 runner，然后在项目中添加配置文件.gitlab-ci.yml\n\n```yaml\nstages: # List of stages for jobs, and their order of execution\n  - install\n  - build\n  - deploy\n\nvariables:\n  NPM_REGISTRY: https://registry.npm.taobao.org\n\ncache:\n  key: ${CI_COMMIT_REF_SLUG}\n  paths:\n    - node_modules/\n\ninstall-job:\n  stage: install\n  # image: node:latest\n  script:\n    - echo \"starting install packages\"\n    # - npm install\n    - echo \"Complete installed packages\"\n  only:\n    - main # 仅在main分支部署\n\nbuild-job: # This job runs in the build stage, which runs first.\n  stage: build\n  image: node:latest\n  dependencies:\n    - install-job # 确保在 build 之前运行 install 作业\n  script:\n    - echo \"Start Building the code...\"\n    - npm install\n    - npm run build\n    - echo \"Building Code complete.\"\n  artifacts:\n    paths:\n      - out/\n  only:\n    - main # 仅在main分支部署\n\ndeploy-job: # This job runs in the deploy stage.\n  stage: deploy # It only runs when *both* jobs in the test stage complete successfully.\n  image: alpine:latest\n  dependencies:\n    - build-job\n  before_script:\n    - sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories\n    - apk update\n    - apk add --no-cache openssh-client\n    - mkdir -p ~/.ssh\n    - chmod 700 ~/.ssh\n    - echo \"${SSH_PRIVATE_KEY}\" > ~/.ssh/id_rsa\n    - chmod 600 ~/.ssh/id_rsa\n    - ls out/\n  script:\n    - echo \"Deploying application...\"\n    - scp -r -o \"StrictHostKeyChecking=no\" ./out/* root@10.131.130.113:/home/wiki/\n    - echo \"Files copied, restarting Nginx...\"\n    - ssh -o \"StrictHostKeyChecking=no\" $SSH_ROOT@$SSH_HOST \"sudo nginx -s reload\"\n    - echo \"Application successfully deployed.\"\n  only:\n    - main # 仅在main分支部署\n```\n\n- 配置完成之后，通过 git push origin main 就会触发构建任务\n  install → build → deploy\n\ndeploy 阶段有 scp 和 nginx restart 操作\n\nscp 首先要在 alpine 镜像构建容器的时候先进行 ssh 密钥对认证\n\n- 在容器内部新建.ssh 目录，\n- 将 gitlab 的秘密变量私钥 SSH_PRIVATE_KEY 复制到.ssh/id_rsa 文件，\n- 在部署服务器中的.ssh/authrization_key，添加对应的公钥，目的是为了 ssh 免密码登录\n\n然后进行 scp 复制构建产物到服务器的对应目录\n\n重启 web 服务器\n\ngitlab-runner cicd 流程结束，代码部署成功\n\n```bash\n# nginx.conf示例\nserver {\n        listen  8000;\n        server_name     localhost;\n        charset utf-8;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        add_header Content-Security-Policy \" object-src 'none'; script-'self' 'unsafe-inline' \";\n        add_header  X-Frame-Options SAMEORIGIN;\n        add_header X-Content-Type-Options nosniff;\n        location / {\n          root  /home/wiki; # /home/wiki 就是前端资源部署的位置\n          try_files $uri $uri/ /index.html;\n          index index.html index.htm;\n        }\n    }\n```\n","slug":"runners","published":1,"date":"2024-03-26T07:49:43.176Z","updated":"2024-03-26T07:51:54.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrt000b3jf0d4i01tz9","content":"<h1 id=\"gitlab-runners-流程配置\"><a href=\"#gitlab-runners-流程配置\" class=\"headerlink\" title=\"gitlab-runners 流程配置\"></a>gitlab-runners 流程配置</h1><p>项目部署的流程如下:</p>\n<ul>\n<li>将项目打包(build)</li>\n<li>启动 web 服务器（如 nginx）</li>\n<li>将打包后的文件上传到 web 服务器的指定目录下<br>例如：scp -r .&#x2F;buildDir&#x2F;* 目标服务器名称@目标服务器 ip:目标服务器下 nginx 的 root 配置目录，在当前目录下执行</li>\n<li>重启 nginx（或者其他 web 服务器）</li>\n</ul>\n<p>gitlab-CICD 就是要将以上的流程自动化，推送项目代码之后就能自动执行这些流程步骤。</p>\n<p><strong>使用 gitlab-runner 作为执行构建任务的执行器</strong></p>\n<p>首先安装 gitlab-runner</p>\n<ol>\n<li>bash 安装。2. docker 安装。3. 官网安装包下载</li>\n</ol>\n<blockquote>\n<p>bash 安装</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bash 安装</span></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gitlab-runner</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>docker 安装</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker 安装</span></span><br><span class=\"line\"><span class=\"comment\"># 拉取镜像</span></span><br><span class=\"line\">docker pull gitlab/gitlab-runner</span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker run -d --name gitlab-runner --restart always \\</span><br><span class=\"line\">  -v /opt/gitlab-runner/config:/etc/gitlab-runner \\</span><br><span class=\"line\">  -v /var/run/docker.sock:/var/run/docker.sock \\</span><br><span class=\"line\">  gitlab/gitlab-runner:latest</span><br><span class=\"line\"><span class=\"comment\"># 进入容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it gitlab-runner bash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>安装包安装</p>\n</blockquote>\n<p><a class=\"link\"   href=\"https://docs.gitlab.com/runner/install/linux-repository.html\" >https://docs.gitlab.com/runner/install/linux-repository.html<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 版本较低</span></span><br><span class=\"line\">sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加执行权限</span></span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> +x /usr/local/bin/gitlab-runner</span><br><span class=\"line\"><span class=\"comment\"># 创建gitlab runner用户</span></span><br><span class=\"line\">sudo useradd --comment <span class=\"string\">&#x27;GitLab Runner&#x27;</span> --create-home gitlab-runner --shell /bin/bash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注册 runner(可注册多个不同 token 的 runners)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册gitlab runner</span><br><span class=\"line\"><span class=\"comment\"># 在容器内或者服务器内执行</span></span><br><span class=\"line\">sudo gitlab-runner register</span><br><span class=\"line\"><span class=\"comment\"># 注册过程需要提供一些信息</span></span><br><span class=\"line\">\t- gitlab 实例的url</span><br><span class=\"line\">\t- 注册token，可以在gitlab的runner设置页面中获取</span><br><span class=\"line\">\t- runner的描述</span><br><span class=\"line\">\t- runner的标签(tags)</span><br><span class=\"line\">\t- 是否允许runner在没有tag的作业上运行</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>配置 gitlab-runner，在&#x2F;etc&#x2F;gitlab-runner&#x2F;config.toml 文件中进行,主要配置一些并发作业数，日志级别等</p>\n</blockquote>\n<blockquote>\n<p>启动 runner</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner start</span><br><span class=\"line\">sudo gitlab-runner restart</span><br></pre></td></tr></table></figure>\n\n<p>出现以下提示说明已经成功了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime platform  <span class=\"built_in\">arch</span>=amd64 os=linux pid=55297 revision=656c1943 version=16.9.0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>验证 runner 配置</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner verify</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>runner 设置完成之后，进入到 gitlab，点击查看 CICD 部分，可以看到注册好的 runner，然后在项目中添加配置文件.gitlab-ci.yml</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">stages:</span> <span class=\"comment\"># List of stages for jobs, and their order of execution</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">variables:</span></span><br><span class=\"line\">  <span class=\"attr\">NPM_REGISTRY:</span> <span class=\"string\">https://registry.npm.taobao.org</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\">  <span class=\"attr\">key:</span> <span class=\"string\">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">node_modules/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">install-job:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"comment\"># image: node:latest</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;starting install packages&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># - npm install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Complete installed packages&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build-job:</span> <span class=\"comment\"># This job runs in the build stage, which runs first.</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:latest</span></span><br><span class=\"line\">  <span class=\"attr\">dependencies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">install-job</span> <span class=\"comment\"># 确保在 build 之前运行 install 作业</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Start Building the code...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Building Code complete.&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">out/</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy-job:</span> <span class=\"comment\"># This job runs in the deploy stage.</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span> <span class=\"comment\"># It only runs when *both* jobs in the test stage complete successfully.</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine:latest</span></span><br><span class=\"line\">  <span class=\"attr\">dependencies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">build-job</span></span><br><span class=\"line\">  <span class=\"attr\">before_script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">sed</span> <span class=\"string\">-i</span> <span class=\"string\">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> <span class=\"string\">/etc/apk/repositories</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">update</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">mkdir</span> <span class=\"string\">-p</span> <span class=\"string\">~/.ssh</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">700</span> <span class=\"string\">~/.ssh</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;$&#123;SSH_PRIVATE_KEY&#125;&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ls</span> <span class=\"string\">out/</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Deploying application...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">scp</span> <span class=\"string\">-r</span> <span class=\"string\">-o</span> <span class=\"string\">&quot;StrictHostKeyChecking=no&quot;</span> <span class=\"string\">./out/*</span> <span class=\"string\">root@10.131.130.113:/home/wiki/</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Files copied, restarting Nginx...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-o</span> <span class=\"string\">&quot;StrictHostKeyChecking=no&quot;</span> <span class=\"string\">$SSH_ROOT@$SSH_HOST</span> <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Application successfully deployed.&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置完成之后，通过 git push origin main 就会触发构建任务<br>install → build → deploy</li>\n</ul>\n<p>deploy 阶段有 scp 和 nginx restart 操作</p>\n<p>scp 首先要在 alpine 镜像构建容器的时候先进行 ssh 密钥对认证</p>\n<ul>\n<li>在容器内部新建.ssh 目录，</li>\n<li>将 gitlab 的秘密变量私钥 SSH_PRIVATE_KEY 复制到.ssh&#x2F;id_rsa 文件，</li>\n<li>在部署服务器中的.ssh&#x2F;authrization_key，添加对应的公钥，目的是为了 ssh 免密码登录</li>\n</ul>\n<p>然后进行 scp 复制构建产物到服务器的对应目录</p>\n<p>重启 web 服务器</p>\n<p>gitlab-runner cicd 流程结束，代码部署成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nginx.conf示例</span></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen  8000;</span><br><span class=\"line\">        server_name     localhost;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        <span class=\"comment\">#charset koi8-r;</span></span><br><span class=\"line\">        <span class=\"comment\">#access_log  logs/host.access.log  main;</span></span><br><span class=\"line\">        add_header Content-Security-Policy <span class=\"string\">&quot; object-src &#x27;none&#x27;; script-&#x27;self&#x27; &#x27;unsafe-inline&#x27; &quot;</span>;</span><br><span class=\"line\">        add_header  X-Frame-Options SAMEORIGIN;</span><br><span class=\"line\">        add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">          root  /home/wiki; <span class=\"comment\"># /home/wiki 就是前端资源部署的位置</span></span><br><span class=\"line\">          try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">          index index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"gitlab-runners-流程配置\"><a href=\"#gitlab-runners-流程配置\" class=\"headerlink\" title=\"gitlab-runners 流程配置\"></a>gitlab-runners 流程配置</h1><p>项目部署的流程如下:</p>\n<ul>\n<li>将项目打包(build)</li>\n<li>启动 web 服务器（如 nginx）</li>\n<li>将打包后的文件上传到 web 服务器的指定目录下<br>例如：scp -r .&#x2F;buildDir&#x2F;* 目标服务器名称@目标服务器 ip:目标服务器下 nginx 的 root 配置目录，在当前目录下执行</li>\n<li>重启 nginx（或者其他 web 服务器）</li>\n</ul>\n<p>gitlab-CICD 就是要将以上的流程自动化，推送项目代码之后就能自动执行这些流程步骤。</p>\n<p><strong>使用 gitlab-runner 作为执行构建任务的执行器</strong></p>\n<p>首先安装 gitlab-runner</p>\n<ol>\n<li>bash 安装。2. docker 安装。3. 官网安装包下载</li>\n</ol>\n<blockquote>\n<p>bash 安装</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># bash 安装</span></span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install gitlab-runner</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>docker 安装</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker 安装</span></span><br><span class=\"line\"><span class=\"comment\"># 拉取镜像</span></span><br><span class=\"line\">docker pull gitlab/gitlab-runner</span><br><span class=\"line\"><span class=\"comment\"># 启动容器</span></span><br><span class=\"line\">docker run -d --name gitlab-runner --restart always \\</span><br><span class=\"line\">  -v /opt/gitlab-runner/config:/etc/gitlab-runner \\</span><br><span class=\"line\">  -v /var/run/docker.sock:/var/run/docker.sock \\</span><br><span class=\"line\">  gitlab/gitlab-runner:latest</span><br><span class=\"line\"><span class=\"comment\"># 进入容器</span></span><br><span class=\"line\">docker <span class=\"built_in\">exec</span> -it gitlab-runner bash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>安装包安装</p>\n</blockquote>\n<p><a class=\"link\"   href=\"https://docs.gitlab.com/runner/install/linux-repository.html\" >https://docs.gitlab.com/runner/install/linux-repository.html<i class=\"fas fa-external-link-alt\"></i></a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 版本较低</span></span><br><span class=\"line\">sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加执行权限</span></span><br><span class=\"line\">sudo <span class=\"built_in\">chmod</span> +x /usr/local/bin/gitlab-runner</span><br><span class=\"line\"><span class=\"comment\"># 创建gitlab runner用户</span></span><br><span class=\"line\">sudo useradd --comment <span class=\"string\">&#x27;GitLab Runner&#x27;</span> --create-home gitlab-runner --shell /bin/bash</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注册 runner(可注册多个不同 token 的 runners)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注册gitlab runner</span><br><span class=\"line\"><span class=\"comment\"># 在容器内或者服务器内执行</span></span><br><span class=\"line\">sudo gitlab-runner register</span><br><span class=\"line\"><span class=\"comment\"># 注册过程需要提供一些信息</span></span><br><span class=\"line\">\t- gitlab 实例的url</span><br><span class=\"line\">\t- 注册token，可以在gitlab的runner设置页面中获取</span><br><span class=\"line\">\t- runner的描述</span><br><span class=\"line\">\t- runner的标签(tags)</span><br><span class=\"line\">\t- 是否允许runner在没有tag的作业上运行</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>配置 gitlab-runner，在&#x2F;etc&#x2F;gitlab-runner&#x2F;config.toml 文件中进行,主要配置一些并发作业数，日志级别等</p>\n</blockquote>\n<blockquote>\n<p>启动 runner</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner start</span><br><span class=\"line\">sudo gitlab-runner restart</span><br></pre></td></tr></table></figure>\n\n<p>出现以下提示说明已经成功了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime platform  <span class=\"built_in\">arch</span>=amd64 os=linux pid=55297 revision=656c1943 version=16.9.0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>验证 runner 配置</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gitlab-runner verify</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>runner 设置完成之后，进入到 gitlab，点击查看 CICD 部分，可以看到注册好的 runner，然后在项目中添加配置文件.gitlab-ci.yml</p>\n</blockquote>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">stages:</span> <span class=\"comment\"># List of stages for jobs, and their order of execution</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">variables:</span></span><br><span class=\"line\">  <span class=\"attr\">NPM_REGISTRY:</span> <span class=\"string\">https://registry.npm.taobao.org</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">cache:</span></span><br><span class=\"line\">  <span class=\"attr\">key:</span> <span class=\"string\">$&#123;CI_COMMIT_REF_SLUG&#125;</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">node_modules/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">install-job:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">install</span></span><br><span class=\"line\">  <span class=\"comment\"># image: node:latest</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;starting install packages&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># - npm install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Complete installed packages&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build-job:</span> <span class=\"comment\"># This job runs in the build stage, which runs first.</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:latest</span></span><br><span class=\"line\">  <span class=\"attr\">dependencies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">install-job</span> <span class=\"comment\"># 确保在 build 之前运行 install 作业</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Start Building the code...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Building Code complete.&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">out/</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy-job:</span> <span class=\"comment\"># This job runs in the deploy stage.</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span> <span class=\"comment\"># It only runs when *both* jobs in the test stage complete successfully.</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine:latest</span></span><br><span class=\"line\">  <span class=\"attr\">dependencies:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">build-job</span></span><br><span class=\"line\">  <span class=\"attr\">before_script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">sed</span> <span class=\"string\">-i</span> <span class=\"string\">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> <span class=\"string\">/etc/apk/repositories</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">update</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">mkdir</span> <span class=\"string\">-p</span> <span class=\"string\">~/.ssh</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">700</span> <span class=\"string\">~/.ssh</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;$&#123;SSH_PRIVATE_KEY&#125;&quot;</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ls</span> <span class=\"string\">out/</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Deploying application...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">scp</span> <span class=\"string\">-r</span> <span class=\"string\">-o</span> <span class=\"string\">&quot;StrictHostKeyChecking=no&quot;</span> <span class=\"string\">./out/*</span> <span class=\"string\">root@10.131.130.113:/home/wiki/</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Files copied, restarting Nginx...&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-o</span> <span class=\"string\">&quot;StrictHostKeyChecking=no&quot;</span> <span class=\"string\">$SSH_ROOT@$SSH_HOST</span> <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">echo</span> <span class=\"string\">&quot;Application successfully deployed.&quot;</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">main</span> <span class=\"comment\"># 仅在main分支部署</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置完成之后，通过 git push origin main 就会触发构建任务<br>install → build → deploy</li>\n</ul>\n<p>deploy 阶段有 scp 和 nginx restart 操作</p>\n<p>scp 首先要在 alpine 镜像构建容器的时候先进行 ssh 密钥对认证</p>\n<ul>\n<li>在容器内部新建.ssh 目录，</li>\n<li>将 gitlab 的秘密变量私钥 SSH_PRIVATE_KEY 复制到.ssh&#x2F;id_rsa 文件，</li>\n<li>在部署服务器中的.ssh&#x2F;authrization_key，添加对应的公钥，目的是为了 ssh 免密码登录</li>\n</ul>\n<p>然后进行 scp 复制构建产物到服务器的对应目录</p>\n<p>重启 web 服务器</p>\n<p>gitlab-runner cicd 流程结束，代码部署成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># nginx.conf示例</span></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen  8000;</span><br><span class=\"line\">        server_name     localhost;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        <span class=\"comment\">#charset koi8-r;</span></span><br><span class=\"line\">        <span class=\"comment\">#access_log  logs/host.access.log  main;</span></span><br><span class=\"line\">        add_header Content-Security-Policy <span class=\"string\">&quot; object-src &#x27;none&#x27;; script-&#x27;self&#x27; &#x27;unsafe-inline&#x27; &quot;</span>;</span><br><span class=\"line\">        add_header  X-Frame-Options SAMEORIGIN;</span><br><span class=\"line\">        add_header X-Content-Type-Options nosniff;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">          root  /home/wiki; <span class=\"comment\"># /home/wiki 就是前端资源部署的位置</span></span><br><span class=\"line\">          try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">          index index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"SmartContract(智能合约)","_content":"\n<aside>\n💡 智能合约是部署在链上的，具有公开透明，不可篡改的特性\n</aside>\n\n智能合约是一种运行在以太坊链上的程序，它是位于以太坊区块链上的一个特定地址的一系列代码（函数）和数据（状态）。智能合约也是一个以太坊账户，我们称之为合约账户，这意味着它有余额，可以通过网络进行交易，但是，它无法被人为操控，他们是被部署在去中心化节点上作为网络节点作为程序运行着。个人用户可以通过提交交易执行智能合约的某个函数来与智能合约进行交互。智能合约是一个按照特定规则编写的代码文件，并通过代码自动强制执行。\n\n# 特色\n\n无需许可，任何人都编写智能合约并将其部署到区块链网络上，你只需要学习如何用智能合约编码规则，并且有足够的 ETH 来部署你的合约，在技术上，部署智能合约是一项交易，所以需要支付 Gas Fee，就像为以太坊转账一样，需要消耗 Gas 一样。但是，部署合约需要消耗更多的 Gas\n\n# 语言\n\n- [Solidity](https://ethereum.org/zh/developers/docs/smart-contracts/languages/)：类 JavaScript 语言\n- [Vyper](https://ethereum.org/zh/developers/docs/smart-contracts/languages/)：类 Python 语言\n\n# 局限性\n\n智能合约本身无法获取关于“真实世界”的事件信息，因为他们无法发送 HTTP 请求，这样设计是因为依赖于外部信息可能会危及共识，这对安全性和去中心化而言非常重要。\n\n而需要获取外部信息，可以通过[预言机](https://www.notion.so/Oracle-3789d59c7aaa4e47aada5cc879cc1657?pvs=21)实现\n\n智能合约可以简单理解为可执行的公开透明的程序，被开发者部署到以太坊区块链上，与外界完全隔离并运行与以太坊虚拟机（EVM），这样就脱离了认为干预，完全只按照代码设定的规则运行\n\n区块链技术的出现不仅解决了该概念里最重要的合约对货币的百分之百的控制权，并且可编程的优势又让他秒杀了一切传统合约，而区块链的去中心化、不可篡改、过程透明可追踪等优点，更是令智能合约如虎添翼，一飞冲天。\n\n智能合约是纯正且原生的区块链技术，它符合我们对于区块链价值观的所有期望\n","source":"_posts/smartContract.md","raw":"---\ntitle: SmartContract(智能合约)\n---\n\n<aside>\n💡 智能合约是部署在链上的，具有公开透明，不可篡改的特性\n</aside>\n\n智能合约是一种运行在以太坊链上的程序，它是位于以太坊区块链上的一个特定地址的一系列代码（函数）和数据（状态）。智能合约也是一个以太坊账户，我们称之为合约账户，这意味着它有余额，可以通过网络进行交易，但是，它无法被人为操控，他们是被部署在去中心化节点上作为网络节点作为程序运行着。个人用户可以通过提交交易执行智能合约的某个函数来与智能合约进行交互。智能合约是一个按照特定规则编写的代码文件，并通过代码自动强制执行。\n\n# 特色\n\n无需许可，任何人都编写智能合约并将其部署到区块链网络上，你只需要学习如何用智能合约编码规则，并且有足够的 ETH 来部署你的合约，在技术上，部署智能合约是一项交易，所以需要支付 Gas Fee，就像为以太坊转账一样，需要消耗 Gas 一样。但是，部署合约需要消耗更多的 Gas\n\n# 语言\n\n- [Solidity](https://ethereum.org/zh/developers/docs/smart-contracts/languages/)：类 JavaScript 语言\n- [Vyper](https://ethereum.org/zh/developers/docs/smart-contracts/languages/)：类 Python 语言\n\n# 局限性\n\n智能合约本身无法获取关于“真实世界”的事件信息，因为他们无法发送 HTTP 请求，这样设计是因为依赖于外部信息可能会危及共识，这对安全性和去中心化而言非常重要。\n\n而需要获取外部信息，可以通过[预言机](https://www.notion.so/Oracle-3789d59c7aaa4e47aada5cc879cc1657?pvs=21)实现\n\n智能合约可以简单理解为可执行的公开透明的程序，被开发者部署到以太坊区块链上，与外界完全隔离并运行与以太坊虚拟机（EVM），这样就脱离了认为干预，完全只按照代码设定的规则运行\n\n区块链技术的出现不仅解决了该概念里最重要的合约对货币的百分之百的控制权，并且可编程的优势又让他秒杀了一切传统合约，而区块链的去中心化、不可篡改、过程透明可追踪等优点，更是令智能合约如虎添翼，一飞冲天。\n\n智能合约是纯正且原生的区块链技术，它符合我们对于区块链价值观的所有期望\n","slug":"smartContract","published":1,"date":"2024-03-26T07:47:20.055Z","updated":"2024-03-26T07:48:19.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrt000c3jf08h2uhzwt","content":"<aside>\n💡 智能合约是部署在链上的，具有公开透明，不可篡改的特性\n</aside>\n\n<p>智能合约是一种运行在以太坊链上的程序，它是位于以太坊区块链上的一个特定地址的一系列代码（函数）和数据（状态）。智能合约也是一个以太坊账户，我们称之为合约账户，这意味着它有余额，可以通过网络进行交易，但是，它无法被人为操控，他们是被部署在去中心化节点上作为网络节点作为程序运行着。个人用户可以通过提交交易执行智能合约的某个函数来与智能合约进行交互。智能合约是一个按照特定规则编写的代码文件，并通过代码自动强制执行。</p>\n<h1 id=\"特色\"><a href=\"#特色\" class=\"headerlink\" title=\"特色\"></a>特色</h1><p>无需许可，任何人都编写智能合约并将其部署到区块链网络上，你只需要学习如何用智能合约编码规则，并且有足够的 ETH 来部署你的合约，在技术上，部署智能合约是一项交易，所以需要支付 Gas Fee，就像为以太坊转账一样，需要消耗 Gas 一样。但是，部署合约需要消耗更多的 Gas</p>\n<h1 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h1><ul>\n<li><a class=\"link\"   href=\"https://ethereum.org/zh/developers/docs/smart-contracts/languages/\" >Solidity<i class=\"fas fa-external-link-alt\"></i></a>：类 JavaScript 语言</li>\n<li><a class=\"link\"   href=\"https://ethereum.org/zh/developers/docs/smart-contracts/languages/\" >Vyper<i class=\"fas fa-external-link-alt\"></i></a>：类 Python 语言</li>\n</ul>\n<h1 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h1><p>智能合约本身无法获取关于“真实世界”的事件信息，因为他们无法发送 HTTP 请求，这样设计是因为依赖于外部信息可能会危及共识，这对安全性和去中心化而言非常重要。</p>\n<p>而需要获取外部信息，可以通过<a class=\"link\"   href=\"https://www.notion.so/Oracle-3789d59c7aaa4e47aada5cc879cc1657?pvs=21\" >预言机<i class=\"fas fa-external-link-alt\"></i></a>实现</p>\n<p>智能合约可以简单理解为可执行的公开透明的程序，被开发者部署到以太坊区块链上，与外界完全隔离并运行与以太坊虚拟机（EVM），这样就脱离了认为干预，完全只按照代码设定的规则运行</p>\n<p>区块链技术的出现不仅解决了该概念里最重要的合约对货币的百分之百的控制权，并且可编程的优势又让他秒杀了一切传统合约，而区块链的去中心化、不可篡改、过程透明可追踪等优点，更是令智能合约如虎添翼，一飞冲天。</p>\n<p>智能合约是纯正且原生的区块链技术，它符合我们对于区块链价值观的所有期望</p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<aside>\n💡 智能合约是部署在链上的，具有公开透明，不可篡改的特性\n</aside>\n\n<p>智能合约是一种运行在以太坊链上的程序，它是位于以太坊区块链上的一个特定地址的一系列代码（函数）和数据（状态）。智能合约也是一个以太坊账户，我们称之为合约账户，这意味着它有余额，可以通过网络进行交易，但是，它无法被人为操控，他们是被部署在去中心化节点上作为网络节点作为程序运行着。个人用户可以通过提交交易执行智能合约的某个函数来与智能合约进行交互。智能合约是一个按照特定规则编写的代码文件，并通过代码自动强制执行。</p>\n<h1 id=\"特色\"><a href=\"#特色\" class=\"headerlink\" title=\"特色\"></a>特色</h1><p>无需许可，任何人都编写智能合约并将其部署到区块链网络上，你只需要学习如何用智能合约编码规则，并且有足够的 ETH 来部署你的合约，在技术上，部署智能合约是一项交易，所以需要支付 Gas Fee，就像为以太坊转账一样，需要消耗 Gas 一样。但是，部署合约需要消耗更多的 Gas</p>\n<h1 id=\"语言\"><a href=\"#语言\" class=\"headerlink\" title=\"语言\"></a>语言</h1><ul>\n<li><a class=\"link\"   href=\"https://ethereum.org/zh/developers/docs/smart-contracts/languages/\" >Solidity<i class=\"fas fa-external-link-alt\"></i></a>：类 JavaScript 语言</li>\n<li><a class=\"link\"   href=\"https://ethereum.org/zh/developers/docs/smart-contracts/languages/\" >Vyper<i class=\"fas fa-external-link-alt\"></i></a>：类 Python 语言</li>\n</ul>\n<h1 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h1><p>智能合约本身无法获取关于“真实世界”的事件信息，因为他们无法发送 HTTP 请求，这样设计是因为依赖于外部信息可能会危及共识，这对安全性和去中心化而言非常重要。</p>\n<p>而需要获取外部信息，可以通过<a class=\"link\"   href=\"https://www.notion.so/Oracle-3789d59c7aaa4e47aada5cc879cc1657?pvs=21\" >预言机<i class=\"fas fa-external-link-alt\"></i></a>实现</p>\n<p>智能合约可以简单理解为可执行的公开透明的程序，被开发者部署到以太坊区块链上，与外界完全隔离并运行与以太坊虚拟机（EVM），这样就脱离了认为干预，完全只按照代码设定的规则运行</p>\n<p>区块链技术的出现不仅解决了该概念里最重要的合约对货币的百分之百的控制权，并且可编程的优势又让他秒杀了一切传统合约，而区块链的去中心化、不可篡改、过程透明可追踪等优点，更是令智能合约如虎添翼，一飞冲天。</p>\n<p>智能合约是纯正且原生的区块链技术，它符合我们对于区块链价值观的所有期望</p>\n"},{"title":"Token(通证)","_content":"\nWeb3 中的 Token 的作用：\n\n- 代币：ERC20 类型的通证基本都属于这种类型，可用于众筹，债券发行，商品与服务的买卖，其总市值代表一个项目的总资产合总价值\n- 金融工具与金融衍生品\n- 所有权令牌：ERC721 代币属于这种类型\n- 激励工具：如比特币\n- 安全保障手段：如比特币、ETH\n- 投票权：如 EOS\n- 股权证书\n- 门票或通行证\n- 自治组织(DAO)的治理工具\n\n什么是同质化和非同质化通证呢\n\n同质化：具有相同的某种特质或某个种类，那么就会认为是同质化的，每个个体之间没有差别，每个个体之间的价值完全相同，可以互相交换，如代币之间就属于同质化通证\n\n非同质化：不同物品之间具有独特、不可替代、不可互换这些特性的话，就满足了非同质化通证的特点，如艺术作品、人、游戏角色、房产等\n\n## 以太坊不同通证的标准\n\n| ERC20        | 可替换资产的原始代币合约                                                |\n| ------------ | ----------------------------------------------------------------------- |\n| ERC-165      | 创建标准方法以发布和检测只能合约的借口                                  |\n| ERC-173      | 合同所有权的标准接口                                                    |\n| ERC-223      | 向后兼容 ERC-20，保护投资者以防意外的转账                               |\n| ERC-721      | 非同质化代币(NFTs)标准，可作为产权进行交易                              |\n| ERC-725      | 密钥管理和执行的代理合同，简历区块链身份                                |\n| ERC-777      | 基于操作者的代币标准，具有高度可定制性                                  |\n| ERC-809      | 非同质化的租赁标准，用户可使用一系列指令来出租 NFTs                     |\n| ERC-827      | 允许转让通证并允许持有人允许第三方使用通证                              |\n| ERC-864      | NFTs 共有产权，旨在 NFT 合约中分享 NFT 的所有权                         |\n| ERC-865      | 此项标准允许用户委托第三方帮忙转账，并以代币形式支付 Gas 费用           |\n| ERC-918      | 可开采性代币，允许加入挖矿算法                                          |\n| ERC-874      | 加权的不可替代代币，便于了解到独特的资产拥有的价值                      |\n| ERC-888      | 多维代币标准，使用标识符代表余额和数据                                  |\n| ERC-998      | 可拆解非同质化代币，可包含多个 ERC-721 和 ERC-20 的形式                 |\n| ERC-1067     | 可升级代币合约的标准，提供代币在合约在内的多种用途的事件锁仓功能        |\n| ERC-1132     | 代币锁定能力的标准，提供代币在合约多种用途的事件锁仓功能                |\n| ERC-1155     | 多代币标准，可追踪多个代币余额和所有权的合约，及定义多个物品            |\n| ERC-1178     | 多级别代币的标准，为多个级别的代币的合约提供标准接口                    |\n| ERC-1190     | 非同质化版税代币标准，可向创造者以及/或者所有者支付版税                 |\n| ERC-1203     | 多层级代币标准，提供多层级代币合约的标准接口                            |\n| ERC-1238     | 不可转账代币标准，代表徽章的不可转账代币                                |\n| ERC-1400     | 证券通证标准，部分可互换代币，该 EIP 标准具有能力进行强制转移           |\n| ERC-1404     | 为证券通证、通证化证券以及其他携带复杂要求的其他通证儿准备              |\n| ERC-2612     | 该标准可以取消 ERC-20 的 approve + transform，同时海允许无 Gas 通证转账 |\n| Minime Token | 带更多功能的 ERC-20 代币（易克隆），获得余额转账历史及代币控制          |\n","source":"_posts/token.md","raw":"---\ntitle: Token(通证)\n---\n\nWeb3 中的 Token 的作用：\n\n- 代币：ERC20 类型的通证基本都属于这种类型，可用于众筹，债券发行，商品与服务的买卖，其总市值代表一个项目的总资产合总价值\n- 金融工具与金融衍生品\n- 所有权令牌：ERC721 代币属于这种类型\n- 激励工具：如比特币\n- 安全保障手段：如比特币、ETH\n- 投票权：如 EOS\n- 股权证书\n- 门票或通行证\n- 自治组织(DAO)的治理工具\n\n什么是同质化和非同质化通证呢\n\n同质化：具有相同的某种特质或某个种类，那么就会认为是同质化的，每个个体之间没有差别，每个个体之间的价值完全相同，可以互相交换，如代币之间就属于同质化通证\n\n非同质化：不同物品之间具有独特、不可替代、不可互换这些特性的话，就满足了非同质化通证的特点，如艺术作品、人、游戏角色、房产等\n\n## 以太坊不同通证的标准\n\n| ERC20        | 可替换资产的原始代币合约                                                |\n| ------------ | ----------------------------------------------------------------------- |\n| ERC-165      | 创建标准方法以发布和检测只能合约的借口                                  |\n| ERC-173      | 合同所有权的标准接口                                                    |\n| ERC-223      | 向后兼容 ERC-20，保护投资者以防意外的转账                               |\n| ERC-721      | 非同质化代币(NFTs)标准，可作为产权进行交易                              |\n| ERC-725      | 密钥管理和执行的代理合同，简历区块链身份                                |\n| ERC-777      | 基于操作者的代币标准，具有高度可定制性                                  |\n| ERC-809      | 非同质化的租赁标准，用户可使用一系列指令来出租 NFTs                     |\n| ERC-827      | 允许转让通证并允许持有人允许第三方使用通证                              |\n| ERC-864      | NFTs 共有产权，旨在 NFT 合约中分享 NFT 的所有权                         |\n| ERC-865      | 此项标准允许用户委托第三方帮忙转账，并以代币形式支付 Gas 费用           |\n| ERC-918      | 可开采性代币，允许加入挖矿算法                                          |\n| ERC-874      | 加权的不可替代代币，便于了解到独特的资产拥有的价值                      |\n| ERC-888      | 多维代币标准，使用标识符代表余额和数据                                  |\n| ERC-998      | 可拆解非同质化代币，可包含多个 ERC-721 和 ERC-20 的形式                 |\n| ERC-1067     | 可升级代币合约的标准，提供代币在合约在内的多种用途的事件锁仓功能        |\n| ERC-1132     | 代币锁定能力的标准，提供代币在合约多种用途的事件锁仓功能                |\n| ERC-1155     | 多代币标准，可追踪多个代币余额和所有权的合约，及定义多个物品            |\n| ERC-1178     | 多级别代币的标准，为多个级别的代币的合约提供标准接口                    |\n| ERC-1190     | 非同质化版税代币标准，可向创造者以及/或者所有者支付版税                 |\n| ERC-1203     | 多层级代币标准，提供多层级代币合约的标准接口                            |\n| ERC-1238     | 不可转账代币标准，代表徽章的不可转账代币                                |\n| ERC-1400     | 证券通证标准，部分可互换代币，该 EIP 标准具有能力进行强制转移           |\n| ERC-1404     | 为证券通证、通证化证券以及其他携带复杂要求的其他通证儿准备              |\n| ERC-2612     | 该标准可以取消 ERC-20 的 approve + transform，同时海允许无 Gas 通证转账 |\n| Minime Token | 带更多功能的 ERC-20 代币（易克隆），获得余额转账历史及代币控制          |\n","slug":"token","published":1,"date":"2024-03-26T07:45:52.283Z","updated":"2024-03-26T07:46:24.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrt000d3jf0d6hu8kky","content":"<p>Web3 中的 Token 的作用：</p>\n<ul>\n<li>代币：ERC20 类型的通证基本都属于这种类型，可用于众筹，债券发行，商品与服务的买卖，其总市值代表一个项目的总资产合总价值</li>\n<li>金融工具与金融衍生品</li>\n<li>所有权令牌：ERC721 代币属于这种类型</li>\n<li>激励工具：如比特币</li>\n<li>安全保障手段：如比特币、ETH</li>\n<li>投票权：如 EOS</li>\n<li>股权证书</li>\n<li>门票或通行证</li>\n<li>自治组织(DAO)的治理工具</li>\n</ul>\n<p>什么是同质化和非同质化通证呢</p>\n<p>同质化：具有相同的某种特质或某个种类，那么就会认为是同质化的，每个个体之间没有差别，每个个体之间的价值完全相同，可以互相交换，如代币之间就属于同质化通证</p>\n<p>非同质化：不同物品之间具有独特、不可替代、不可互换这些特性的话，就满足了非同质化通证的特点，如艺术作品、人、游戏角色、房产等</p>\n<h2 id=\"以太坊不同通证的标准\"><a href=\"#以太坊不同通证的标准\" class=\"headerlink\" title=\"以太坊不同通证的标准\"></a>以太坊不同通证的标准</h2><table>\n<thead>\n<tr>\n<th>ERC20</th>\n<th>可替换资产的原始代币合约</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ERC-165</td>\n<td>创建标准方法以发布和检测只能合约的借口</td>\n</tr>\n<tr>\n<td>ERC-173</td>\n<td>合同所有权的标准接口</td>\n</tr>\n<tr>\n<td>ERC-223</td>\n<td>向后兼容 ERC-20，保护投资者以防意外的转账</td>\n</tr>\n<tr>\n<td>ERC-721</td>\n<td>非同质化代币(NFTs)标准，可作为产权进行交易</td>\n</tr>\n<tr>\n<td>ERC-725</td>\n<td>密钥管理和执行的代理合同，简历区块链身份</td>\n</tr>\n<tr>\n<td>ERC-777</td>\n<td>基于操作者的代币标准，具有高度可定制性</td>\n</tr>\n<tr>\n<td>ERC-809</td>\n<td>非同质化的租赁标准，用户可使用一系列指令来出租 NFTs</td>\n</tr>\n<tr>\n<td>ERC-827</td>\n<td>允许转让通证并允许持有人允许第三方使用通证</td>\n</tr>\n<tr>\n<td>ERC-864</td>\n<td>NFTs 共有产权，旨在 NFT 合约中分享 NFT 的所有权</td>\n</tr>\n<tr>\n<td>ERC-865</td>\n<td>此项标准允许用户委托第三方帮忙转账，并以代币形式支付 Gas 费用</td>\n</tr>\n<tr>\n<td>ERC-918</td>\n<td>可开采性代币，允许加入挖矿算法</td>\n</tr>\n<tr>\n<td>ERC-874</td>\n<td>加权的不可替代代币，便于了解到独特的资产拥有的价值</td>\n</tr>\n<tr>\n<td>ERC-888</td>\n<td>多维代币标准，使用标识符代表余额和数据</td>\n</tr>\n<tr>\n<td>ERC-998</td>\n<td>可拆解非同质化代币，可包含多个 ERC-721 和 ERC-20 的形式</td>\n</tr>\n<tr>\n<td>ERC-1067</td>\n<td>可升级代币合约的标准，提供代币在合约在内的多种用途的事件锁仓功能</td>\n</tr>\n<tr>\n<td>ERC-1132</td>\n<td>代币锁定能力的标准，提供代币在合约多种用途的事件锁仓功能</td>\n</tr>\n<tr>\n<td>ERC-1155</td>\n<td>多代币标准，可追踪多个代币余额和所有权的合约，及定义多个物品</td>\n</tr>\n<tr>\n<td>ERC-1178</td>\n<td>多级别代币的标准，为多个级别的代币的合约提供标准接口</td>\n</tr>\n<tr>\n<td>ERC-1190</td>\n<td>非同质化版税代币标准，可向创造者以及&#x2F;或者所有者支付版税</td>\n</tr>\n<tr>\n<td>ERC-1203</td>\n<td>多层级代币标准，提供多层级代币合约的标准接口</td>\n</tr>\n<tr>\n<td>ERC-1238</td>\n<td>不可转账代币标准，代表徽章的不可转账代币</td>\n</tr>\n<tr>\n<td>ERC-1400</td>\n<td>证券通证标准，部分可互换代币，该 EIP 标准具有能力进行强制转移</td>\n</tr>\n<tr>\n<td>ERC-1404</td>\n<td>为证券通证、通证化证券以及其他携带复杂要求的其他通证儿准备</td>\n</tr>\n<tr>\n<td>ERC-2612</td>\n<td>该标准可以取消 ERC-20 的 approve + transform，同时海允许无 Gas 通证转账</td>\n</tr>\n<tr>\n<td>Minime Token</td>\n<td>带更多功能的 ERC-20 代币（易克隆），获得余额转账历史及代币控制</td>\n</tr>\n</tbody></table>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<p>Web3 中的 Token 的作用：</p>\n<ul>\n<li>代币：ERC20 类型的通证基本都属于这种类型，可用于众筹，债券发行，商品与服务的买卖，其总市值代表一个项目的总资产合总价值</li>\n<li>金融工具与金融衍生品</li>\n<li>所有权令牌：ERC721 代币属于这种类型</li>\n<li>激励工具：如比特币</li>\n<li>安全保障手段：如比特币、ETH</li>\n<li>投票权：如 EOS</li>\n<li>股权证书</li>\n<li>门票或通行证</li>\n<li>自治组织(DAO)的治理工具</li>\n</ul>\n<p>什么是同质化和非同质化通证呢</p>\n<p>同质化：具有相同的某种特质或某个种类，那么就会认为是同质化的，每个个体之间没有差别，每个个体之间的价值完全相同，可以互相交换，如代币之间就属于同质化通证</p>\n<p>非同质化：不同物品之间具有独特、不可替代、不可互换这些特性的话，就满足了非同质化通证的特点，如艺术作品、人、游戏角色、房产等</p>\n<h2 id=\"以太坊不同通证的标准\"><a href=\"#以太坊不同通证的标准\" class=\"headerlink\" title=\"以太坊不同通证的标准\"></a>以太坊不同通证的标准</h2><table>\n<thead>\n<tr>\n<th>ERC20</th>\n<th>可替换资产的原始代币合约</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ERC-165</td>\n<td>创建标准方法以发布和检测只能合约的借口</td>\n</tr>\n<tr>\n<td>ERC-173</td>\n<td>合同所有权的标准接口</td>\n</tr>\n<tr>\n<td>ERC-223</td>\n<td>向后兼容 ERC-20，保护投资者以防意外的转账</td>\n</tr>\n<tr>\n<td>ERC-721</td>\n<td>非同质化代币(NFTs)标准，可作为产权进行交易</td>\n</tr>\n<tr>\n<td>ERC-725</td>\n<td>密钥管理和执行的代理合同，简历区块链身份</td>\n</tr>\n<tr>\n<td>ERC-777</td>\n<td>基于操作者的代币标准，具有高度可定制性</td>\n</tr>\n<tr>\n<td>ERC-809</td>\n<td>非同质化的租赁标准，用户可使用一系列指令来出租 NFTs</td>\n</tr>\n<tr>\n<td>ERC-827</td>\n<td>允许转让通证并允许持有人允许第三方使用通证</td>\n</tr>\n<tr>\n<td>ERC-864</td>\n<td>NFTs 共有产权，旨在 NFT 合约中分享 NFT 的所有权</td>\n</tr>\n<tr>\n<td>ERC-865</td>\n<td>此项标准允许用户委托第三方帮忙转账，并以代币形式支付 Gas 费用</td>\n</tr>\n<tr>\n<td>ERC-918</td>\n<td>可开采性代币，允许加入挖矿算法</td>\n</tr>\n<tr>\n<td>ERC-874</td>\n<td>加权的不可替代代币，便于了解到独特的资产拥有的价值</td>\n</tr>\n<tr>\n<td>ERC-888</td>\n<td>多维代币标准，使用标识符代表余额和数据</td>\n</tr>\n<tr>\n<td>ERC-998</td>\n<td>可拆解非同质化代币，可包含多个 ERC-721 和 ERC-20 的形式</td>\n</tr>\n<tr>\n<td>ERC-1067</td>\n<td>可升级代币合约的标准，提供代币在合约在内的多种用途的事件锁仓功能</td>\n</tr>\n<tr>\n<td>ERC-1132</td>\n<td>代币锁定能力的标准，提供代币在合约多种用途的事件锁仓功能</td>\n</tr>\n<tr>\n<td>ERC-1155</td>\n<td>多代币标准，可追踪多个代币余额和所有权的合约，及定义多个物品</td>\n</tr>\n<tr>\n<td>ERC-1178</td>\n<td>多级别代币的标准，为多个级别的代币的合约提供标准接口</td>\n</tr>\n<tr>\n<td>ERC-1190</td>\n<td>非同质化版税代币标准，可向创造者以及&#x2F;或者所有者支付版税</td>\n</tr>\n<tr>\n<td>ERC-1203</td>\n<td>多层级代币标准，提供多层级代币合约的标准接口</td>\n</tr>\n<tr>\n<td>ERC-1238</td>\n<td>不可转账代币标准，代表徽章的不可转账代币</td>\n</tr>\n<tr>\n<td>ERC-1400</td>\n<td>证券通证标准，部分可互换代币，该 EIP 标准具有能力进行强制转移</td>\n</tr>\n<tr>\n<td>ERC-1404</td>\n<td>为证券通证、通证化证券以及其他携带复杂要求的其他通证儿准备</td>\n</tr>\n<tr>\n<td>ERC-2612</td>\n<td>该标准可以取消 ERC-20 的 approve + transform，同时海允许无 Gas 通证转账</td>\n</tr>\n<tr>\n<td>Minime Token</td>\n<td>带更多功能的 ERC-20 代币（易克隆），获得余额转账历史及代币控制</td>\n</tr>\n</tbody></table>\n"},{"title":"区块链钱包","_content":"\n<font face=\"微软雅黑\" size=\"3\">\n\n## 什么是区块链钱包   \n&emsp;区块链钱包是加密货币应用中必不可少的一部分，也是加密基础设施中最基础的一部分，区块链钱包的存在使得区块链收发资金成为可能。区块链钱包同时也是web3.0的一个重要入口，事实上，**web3的绝大多数应用，必须要连接区块链钱包才能进一步使用**\n#### 根据钱包的存储方式划分\n&emsp;根据用户是否掌握了私钥，可分为**中心化钱包** 和 **去中心化钱包**\n>>存储方式是指存在哪，只有用户持有私钥且导入钱包后，私钥存在用户设备上后才叫**中心化钱包**，中心化钱包的数据依赖于服务商自己的账本，交易所就是一个典型的中心化钱包，在交易所内完成的交易，就是交易所在自己的账本上增加记录，这个过程，没有发生在链上。 \n&emsp;而无私钥，或者私钥存储在服务商的服务器里，则就是**去中心化钱包**，\n#### 根据是否接触网络\n&emsp;钱包是否联网可分为**冷钱包** 和 **热钱包**\n>> 常见的热钱包指的是桌面钱包: 如 **比特币核心钱包**、**Geth**, 手机钱包，**imToken**、**TpToken**等，以及网页钱包, 如 **metamask** ,而冷钱包指的是硬件钱包，无需联网即可使用，冷钱包外形像U盘。\n#### 根据去中心化程度\n&emsp;可将钱包分为**全节点钱包**、**轻节点钱包**、**中心化钱包**\n>>全节点钱包：完整储存了区块链一切买卖数据的区块链钱包，一般作为官方钱包与节点客户端运用，能够追溯数字财产的来历，验证数字财产的真实性、验证区块链上的买卖是否完成等，由于全节点钱包存储的数据巨大，且数据需要和区块链同步，因此实用性依赖于具体场景。\n轻节点钱包：没有彻底存储区块链买卖节点的数据钱包，由于数据不完整，只保留了区块链钱包的基本功能，即接入功能和买卖验证功能，轻钱包所有的功能都是为了支持交易的成功进行，市面上常见的app钱包都是轻钱包：**AToken**、**myToken**、**Kcash**等.\n#### 根据是否支持多币种\n&emsp;钱包是否支持多币种可分为 **单币种钱包** 和 **多币种钱包**\n>> 单一币种钱包：只为单一区块链资产服务的钱包，也叫主链钱包，一般由项目方或社区开发。\n多币种钱包：支持多个区块链的数字资产，\n全币种钱包：支持所有区块链资产，目前全币种钱包很难存在，这意味该钱包需要支持所有类型区块链协议。\n市场上的多币种钱包已成为主流。\n**imToken** 是依据单ETH主链的多币种钱包，仅支持以ETH协议开发的token。\n**EOSToken** 是以EOS主链的钱包, 仅支持EOS协议开发.\n#### 根据私钥签名方法可分为单签名钱包和多签名钱包\n>> 单签名钱包，由单个私钥签名的钱包\n多签名钱包，需要不同私钥签名进行使用的钱包，一般用于共同管理账户，\n大多数区块链钱包App都是单签名钱包，Gnosis则是多签名钱包。\n\n### 区块链钱包的设计原理\n- 私钥、公钥和地址产生的方法\n>&emsp; 1.比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。\n&emsp; 2.在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。\n&emsp; 3.私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。\n&emsp; 从私钥推导出公钥、再从公钥推导出公钥哈希都是单向的，也就是**采用不可逆算法**\n\n**_椭圆曲线算法_**\n>>&emsp; 4.公钥产生后，将公钥通过SHA256哈希算法处理得到32字节的哈希值；后对得到的哈希值通过RIPEMD-160算法来得到20字节的哈希值 ——Hash160\n&emsp; 5.把版本号[2]+Hash160组成的21字节数组进行双次SHA256哈希运算，得到的哈希值的头4个字节作为校验和，放置21字节数组的末尾。\n&emsp; 6.对组成25位数组进行Base58编码，最后得到地址。\n\n- 使用区块链API进行远程调用\n>>常见的一些钱包开源项目：\n--\n[_bitcoin_]\n**Bitcoin Core**，官方出品\n**bitcoinj**，比特币协议 Java 版\n**bither**，简单安全的比特币钱包\n**Electrum**，全平台轻钱包\n**bread，iOS** 钱包\n**Mycelium，Android** 钱包\n**Copay**，同时支持 Bitcoin 和BitcoinCash\n**bitcoin-wallet**，又一款 Android 钱包\n**DotNetWallet**，.NET 实现的钱包\n**Coinpunk**，基于浏览器的钱包\n**btcwallet**，Go 实现的钱包\n--\n[_Ethereum/ERC20_]\n**go-ethereum**，以太坊协议 Go 版\n**Mist**，官方出品\n**Parity**，支持 Windows、Mac、PC 的钱包\n**MetaMask** chrome浏览器eth wallet插件\n**MyEtherWallet**，基于浏览器的钱包\n**eth-lightwallet**，轻量级 JavasSript 版本钱包\n**ethaddress.org**，纸质版钱包生成器\n**Neureal wallet**，支持 Windows、Mac、PC 的钱包\n\n- 钱包设计：助记词、keystore、密码\n>>私钥一般太难记忆了，使用也不方便，所以从钱包设计的角度，就为简化操作同时不丢失安全性，就出现了助记词的方法。\n一般情况下，助记词由一些单词组成，只要你记住这些单词，按照顺序在钱包中输入，也能打开钱包。\n根据密钥之间是否有关联，将钱包分为 *nondeterministic wallet* 和 *deterministic wallet*\n*nondeterministic wallet*: 密钥对之间没有关联。\n*deterministic wallet*： 密钥由一个原始的种子主密钥推导而来，常见的推导方式就是树状层级推导，(hierarchical deterministic) 简称HD\ndeterministic wallet 基于BIP32标准实现，通过一个共同的种子维护多对私钥，推导私钥的过程采用不可逆哈希算法，\n\n***生成助记词***\n>规定熵的位数必须是 32 的整数倍，所以熵的长度取值位128 到 256 之间取 32 的整数倍的值，分别为 128, 160, 192, 224, 256；\n校验和的长度为熵的长度/32 位, 所以校验和长度可为 4，5，6，7，8 位；\n助记词库有 2048 个词，用 11 位可全部定位词库中所有的词，作为词的索引，故一个词用 11 位表示，助记词的个数可为 (熵+校验和)/11，值为 12，15，18，21，24\n助记词规则:\n1.生成一个长度为 128~256 位(bits)的随机序列(熵)；\n2.取熵哈希后的前n位作为校验和(n= 熵长度/32)；\n3.随机序列+校验和；\n4.把步骤3得到的结果每 11位切割；\n5.步骤4得到的每11位字节匹配词库的一个词；\n6.步骤5得到的结果就是助记词串;\n![生成助记词](../assets/name.png)\n7.助记词句子作为密码；\n8.\"mnemonic\" + passphrase 作为盐；\n9.2048 作为重复计算的次数+HMAC-SHA512 作为随机算法,最终得到BIP32 种子，512 位(64 字节)是期望得到的密钥长度；\n![生成密钥](../assets/secret.png)\n\n除了助记词之外，钱包还会设计一个密码，作为用户常用的登录方式，\nkeystore：Keystore也是私钥经过加密过后的一个文件，需要你自己设置的密码才能打开文件。这样的好处是就算keystore文件被盗，只要你额外设置的密码够长够随机，那么短时间内私钥也不会泄露，有充足的时间转移地址里面的加密货币到其他地址。Keystore会存储在使用的设备里，这样每次登陆只用输入相应密码即可。\n\n***总结***\n>钱包助记词生成了种子（Seed），种子（Seed）生成了私钥，私钥推导出公钥，公钥节选部分成了钱包地址。同时钱包提供了keystore，他也是私钥加密后的文件，可以配合正常的密码使用，便捷了用户的钱包使用\n\n[*私钥重复问题*]\n私钥产生的机制就决定了会有重复的可能。\n>&emsp; 私钥有32个字节，一个字节有8位，所以私钥总数是2^(8*32)=2^256个≈10^77个\n假设宇宙有一亿个星系，\n每个星系有一亿颗恒星，\n每颗恒星有一亿颗人造卫星，\n每颗人造卫星上有一亿台超级计算机，\n每台超级计算机有一亿个CPU，\n每个CPU每秒可以穷举一亿个私钥。\n假设有一亿个私钥的地址上有BTC（每个地址平均0.21BTC），那么，多久可能穷举出一个有币的私钥为：\n10^77（私钥总数）/10^8（有币私钥）/10^8（星系）/10^8（恒星）/10^8（卫星）/10^8（超级计算机）/10^8（CPU）/10^8（每秒穷举）=10^21秒。\n10^21秒/3600秒/24小时/365天=317098亿年\n随着时间的累积，再加上还会有其他的公链出现，如果使用同样的私钥生成地址的规则，概率再小也会有几率出现重复的情况。但是穷举法的代价已经远远超过了所获利，因此可以理解私钥是唯一的。\n\n#### 理解钱包的作用\n>完成一次交易之后，钱包里没有币，也没有NFT，钱包里保存的是自己的区块链地址和对这个地址的操作权限，这些我们交易得到的币、NFT、或者其他什么加密资产是被记录在了各个网络上的对应的区块链中。\n可以说，钱包是区块链的遥控器，创建钱包时，用助记词算出私钥，私钥和公钥配对出现，公钥算出地址，地址就是你在区块链中的账号，助记词可以重新算出私钥，可重置钱包，同时钱包生成的keystore也可以解密后获得私钥，用于重置钱包。\n私钥的作用是获得对地址的操作权限。钱包地址可以看作区块链上的一个节点。\n发起交易，是通过私钥授权，对地址对应的数据区块进行修改。\n</font>","source":"_posts/wallet.md","raw":"---\ntitle: 区块链钱包\n---\n\n<font face=\"微软雅黑\" size=\"3\">\n\n## 什么是区块链钱包   \n&emsp;区块链钱包是加密货币应用中必不可少的一部分，也是加密基础设施中最基础的一部分，区块链钱包的存在使得区块链收发资金成为可能。区块链钱包同时也是web3.0的一个重要入口，事实上，**web3的绝大多数应用，必须要连接区块链钱包才能进一步使用**\n#### 根据钱包的存储方式划分\n&emsp;根据用户是否掌握了私钥，可分为**中心化钱包** 和 **去中心化钱包**\n>>存储方式是指存在哪，只有用户持有私钥且导入钱包后，私钥存在用户设备上后才叫**中心化钱包**，中心化钱包的数据依赖于服务商自己的账本，交易所就是一个典型的中心化钱包，在交易所内完成的交易，就是交易所在自己的账本上增加记录，这个过程，没有发生在链上。 \n&emsp;而无私钥，或者私钥存储在服务商的服务器里，则就是**去中心化钱包**，\n#### 根据是否接触网络\n&emsp;钱包是否联网可分为**冷钱包** 和 **热钱包**\n>> 常见的热钱包指的是桌面钱包: 如 **比特币核心钱包**、**Geth**, 手机钱包，**imToken**、**TpToken**等，以及网页钱包, 如 **metamask** ,而冷钱包指的是硬件钱包，无需联网即可使用，冷钱包外形像U盘。\n#### 根据去中心化程度\n&emsp;可将钱包分为**全节点钱包**、**轻节点钱包**、**中心化钱包**\n>>全节点钱包：完整储存了区块链一切买卖数据的区块链钱包，一般作为官方钱包与节点客户端运用，能够追溯数字财产的来历，验证数字财产的真实性、验证区块链上的买卖是否完成等，由于全节点钱包存储的数据巨大，且数据需要和区块链同步，因此实用性依赖于具体场景。\n轻节点钱包：没有彻底存储区块链买卖节点的数据钱包，由于数据不完整，只保留了区块链钱包的基本功能，即接入功能和买卖验证功能，轻钱包所有的功能都是为了支持交易的成功进行，市面上常见的app钱包都是轻钱包：**AToken**、**myToken**、**Kcash**等.\n#### 根据是否支持多币种\n&emsp;钱包是否支持多币种可分为 **单币种钱包** 和 **多币种钱包**\n>> 单一币种钱包：只为单一区块链资产服务的钱包，也叫主链钱包，一般由项目方或社区开发。\n多币种钱包：支持多个区块链的数字资产，\n全币种钱包：支持所有区块链资产，目前全币种钱包很难存在，这意味该钱包需要支持所有类型区块链协议。\n市场上的多币种钱包已成为主流。\n**imToken** 是依据单ETH主链的多币种钱包，仅支持以ETH协议开发的token。\n**EOSToken** 是以EOS主链的钱包, 仅支持EOS协议开发.\n#### 根据私钥签名方法可分为单签名钱包和多签名钱包\n>> 单签名钱包，由单个私钥签名的钱包\n多签名钱包，需要不同私钥签名进行使用的钱包，一般用于共同管理账户，\n大多数区块链钱包App都是单签名钱包，Gnosis则是多签名钱包。\n\n### 区块链钱包的设计原理\n- 私钥、公钥和地址产生的方法\n>&emsp; 1.比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。\n&emsp; 2.在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。\n&emsp; 3.私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。\n&emsp; 从私钥推导出公钥、再从公钥推导出公钥哈希都是单向的，也就是**采用不可逆算法**\n\n**_椭圆曲线算法_**\n>>&emsp; 4.公钥产生后，将公钥通过SHA256哈希算法处理得到32字节的哈希值；后对得到的哈希值通过RIPEMD-160算法来得到20字节的哈希值 ——Hash160\n&emsp; 5.把版本号[2]+Hash160组成的21字节数组进行双次SHA256哈希运算，得到的哈希值的头4个字节作为校验和，放置21字节数组的末尾。\n&emsp; 6.对组成25位数组进行Base58编码，最后得到地址。\n\n- 使用区块链API进行远程调用\n>>常见的一些钱包开源项目：\n--\n[_bitcoin_]\n**Bitcoin Core**，官方出品\n**bitcoinj**，比特币协议 Java 版\n**bither**，简单安全的比特币钱包\n**Electrum**，全平台轻钱包\n**bread，iOS** 钱包\n**Mycelium，Android** 钱包\n**Copay**，同时支持 Bitcoin 和BitcoinCash\n**bitcoin-wallet**，又一款 Android 钱包\n**DotNetWallet**，.NET 实现的钱包\n**Coinpunk**，基于浏览器的钱包\n**btcwallet**，Go 实现的钱包\n--\n[_Ethereum/ERC20_]\n**go-ethereum**，以太坊协议 Go 版\n**Mist**，官方出品\n**Parity**，支持 Windows、Mac、PC 的钱包\n**MetaMask** chrome浏览器eth wallet插件\n**MyEtherWallet**，基于浏览器的钱包\n**eth-lightwallet**，轻量级 JavasSript 版本钱包\n**ethaddress.org**，纸质版钱包生成器\n**Neureal wallet**，支持 Windows、Mac、PC 的钱包\n\n- 钱包设计：助记词、keystore、密码\n>>私钥一般太难记忆了，使用也不方便，所以从钱包设计的角度，就为简化操作同时不丢失安全性，就出现了助记词的方法。\n一般情况下，助记词由一些单词组成，只要你记住这些单词，按照顺序在钱包中输入，也能打开钱包。\n根据密钥之间是否有关联，将钱包分为 *nondeterministic wallet* 和 *deterministic wallet*\n*nondeterministic wallet*: 密钥对之间没有关联。\n*deterministic wallet*： 密钥由一个原始的种子主密钥推导而来，常见的推导方式就是树状层级推导，(hierarchical deterministic) 简称HD\ndeterministic wallet 基于BIP32标准实现，通过一个共同的种子维护多对私钥，推导私钥的过程采用不可逆哈希算法，\n\n***生成助记词***\n>规定熵的位数必须是 32 的整数倍，所以熵的长度取值位128 到 256 之间取 32 的整数倍的值，分别为 128, 160, 192, 224, 256；\n校验和的长度为熵的长度/32 位, 所以校验和长度可为 4，5，6，7，8 位；\n助记词库有 2048 个词，用 11 位可全部定位词库中所有的词，作为词的索引，故一个词用 11 位表示，助记词的个数可为 (熵+校验和)/11，值为 12，15，18，21，24\n助记词规则:\n1.生成一个长度为 128~256 位(bits)的随机序列(熵)；\n2.取熵哈希后的前n位作为校验和(n= 熵长度/32)；\n3.随机序列+校验和；\n4.把步骤3得到的结果每 11位切割；\n5.步骤4得到的每11位字节匹配词库的一个词；\n6.步骤5得到的结果就是助记词串;\n![生成助记词](../assets/name.png)\n7.助记词句子作为密码；\n8.\"mnemonic\" + passphrase 作为盐；\n9.2048 作为重复计算的次数+HMAC-SHA512 作为随机算法,最终得到BIP32 种子，512 位(64 字节)是期望得到的密钥长度；\n![生成密钥](../assets/secret.png)\n\n除了助记词之外，钱包还会设计一个密码，作为用户常用的登录方式，\nkeystore：Keystore也是私钥经过加密过后的一个文件，需要你自己设置的密码才能打开文件。这样的好处是就算keystore文件被盗，只要你额外设置的密码够长够随机，那么短时间内私钥也不会泄露，有充足的时间转移地址里面的加密货币到其他地址。Keystore会存储在使用的设备里，这样每次登陆只用输入相应密码即可。\n\n***总结***\n>钱包助记词生成了种子（Seed），种子（Seed）生成了私钥，私钥推导出公钥，公钥节选部分成了钱包地址。同时钱包提供了keystore，他也是私钥加密后的文件，可以配合正常的密码使用，便捷了用户的钱包使用\n\n[*私钥重复问题*]\n私钥产生的机制就决定了会有重复的可能。\n>&emsp; 私钥有32个字节，一个字节有8位，所以私钥总数是2^(8*32)=2^256个≈10^77个\n假设宇宙有一亿个星系，\n每个星系有一亿颗恒星，\n每颗恒星有一亿颗人造卫星，\n每颗人造卫星上有一亿台超级计算机，\n每台超级计算机有一亿个CPU，\n每个CPU每秒可以穷举一亿个私钥。\n假设有一亿个私钥的地址上有BTC（每个地址平均0.21BTC），那么，多久可能穷举出一个有币的私钥为：\n10^77（私钥总数）/10^8（有币私钥）/10^8（星系）/10^8（恒星）/10^8（卫星）/10^8（超级计算机）/10^8（CPU）/10^8（每秒穷举）=10^21秒。\n10^21秒/3600秒/24小时/365天=317098亿年\n随着时间的累积，再加上还会有其他的公链出现，如果使用同样的私钥生成地址的规则，概率再小也会有几率出现重复的情况。但是穷举法的代价已经远远超过了所获利，因此可以理解私钥是唯一的。\n\n#### 理解钱包的作用\n>完成一次交易之后，钱包里没有币，也没有NFT，钱包里保存的是自己的区块链地址和对这个地址的操作权限，这些我们交易得到的币、NFT、或者其他什么加密资产是被记录在了各个网络上的对应的区块链中。\n可以说，钱包是区块链的遥控器，创建钱包时，用助记词算出私钥，私钥和公钥配对出现，公钥算出地址，地址就是你在区块链中的账号，助记词可以重新算出私钥，可重置钱包，同时钱包生成的keystore也可以解密后获得私钥，用于重置钱包。\n私钥的作用是获得对地址的操作权限。钱包地址可以看作区块链上的一个节点。\n发起交易，是通过私钥授权，对地址对应的数据区块进行修改。\n</font>","slug":"wallet","published":1,"date":"2024-03-26T07:13:35.915Z","updated":"2024-03-26T07:13:35.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejrt000e3jf07gcf98lp","content":"<font face=\"微软雅黑\" size=\"3\">\n\n<h2 id=\"什么是区块链钱包\"><a href=\"#什么是区块链钱包\" class=\"headerlink\" title=\"什么是区块链钱包\"></a>什么是区块链钱包</h2><p>&emsp;区块链钱包是加密货币应用中必不可少的一部分，也是加密基础设施中最基础的一部分，区块链钱包的存在使得区块链收发资金成为可能。区块链钱包同时也是web3.0的一个重要入口，事实上，<strong>web3的绝大多数应用，必须要连接区块链钱包才能进一步使用</strong></p>\n<h4 id=\"根据钱包的存储方式划分\"><a href=\"#根据钱包的存储方式划分\" class=\"headerlink\" title=\"根据钱包的存储方式划分\"></a>根据钱包的存储方式划分</h4><p>&emsp;根据用户是否掌握了私钥，可分为<strong>中心化钱包</strong> 和 <strong>去中心化钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>存储方式是指存在哪，只有用户持有私钥且导入钱包后，私钥存在用户设备上后才叫<strong>中心化钱包</strong>，中心化钱包的数据依赖于服务商自己的账本，交易所就是一个典型的中心化钱包，在交易所内完成的交易，就是交易所在自己的账本上增加记录，这个过程，没有发生在链上。<br>&emsp;而无私钥，或者私钥存储在服务商的服务器里，则就是<strong>去中心化钱包</strong>，</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据是否接触网络\"><a href=\"#根据是否接触网络\" class=\"headerlink\" title=\"根据是否接触网络\"></a>根据是否接触网络</h4><p>&emsp;钱包是否联网可分为<strong>冷钱包</strong> 和 <strong>热钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>常见的热钱包指的是桌面钱包: 如 <strong>比特币核心钱包</strong>、<strong>Geth</strong>, 手机钱包，<strong>imToken</strong>、<strong>TpToken</strong>等，以及网页钱包, 如 <strong>metamask</strong> ,而冷钱包指的是硬件钱包，无需联网即可使用，冷钱包外形像U盘。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据去中心化程度\"><a href=\"#根据去中心化程度\" class=\"headerlink\" title=\"根据去中心化程度\"></a>根据去中心化程度</h4><p>&emsp;可将钱包分为<strong>全节点钱包</strong>、<strong>轻节点钱包</strong>、<strong>中心化钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>全节点钱包：完整储存了区块链一切买卖数据的区块链钱包，一般作为官方钱包与节点客户端运用，能够追溯数字财产的来历，验证数字财产的真实性、验证区块链上的买卖是否完成等，由于全节点钱包存储的数据巨大，且数据需要和区块链同步，因此实用性依赖于具体场景。<br>轻节点钱包：没有彻底存储区块链买卖节点的数据钱包，由于数据不完整，只保留了区块链钱包的基本功能，即接入功能和买卖验证功能，轻钱包所有的功能都是为了支持交易的成功进行，市面上常见的app钱包都是轻钱包：<strong>AToken</strong>、<strong>myToken</strong>、<strong>Kcash</strong>等.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据是否支持多币种\"><a href=\"#根据是否支持多币种\" class=\"headerlink\" title=\"根据是否支持多币种\"></a>根据是否支持多币种</h4><p>&emsp;钱包是否支持多币种可分为 <strong>单币种钱包</strong> 和 <strong>多币种钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>单一币种钱包：只为单一区块链资产服务的钱包，也叫主链钱包，一般由项目方或社区开发。<br>多币种钱包：支持多个区块链的数字资产，<br>全币种钱包：支持所有区块链资产，目前全币种钱包很难存在，这意味该钱包需要支持所有类型区块链协议。<br>市场上的多币种钱包已成为主流。<br><strong>imToken</strong> 是依据单ETH主链的多币种钱包，仅支持以ETH协议开发的token。<br><strong>EOSToken</strong> 是以EOS主链的钱包, 仅支持EOS协议开发.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据私钥签名方法可分为单签名钱包和多签名钱包\"><a href=\"#根据私钥签名方法可分为单签名钱包和多签名钱包\" class=\"headerlink\" title=\"根据私钥签名方法可分为单签名钱包和多签名钱包\"></a>根据私钥签名方法可分为单签名钱包和多签名钱包</h4><blockquote>\n<blockquote>\n<p>单签名钱包，由单个私钥签名的钱包<br>多签名钱包，需要不同私钥签名进行使用的钱包，一般用于共同管理账户，<br>大多数区块链钱包App都是单签名钱包，Gnosis则是多签名钱包。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"区块链钱包的设计原理\"><a href=\"#区块链钱包的设计原理\" class=\"headerlink\" title=\"区块链钱包的设计原理\"></a>区块链钱包的设计原理</h3><ul>\n<li>私钥、公钥和地址产生的方法<blockquote>\n<p>&emsp; 1.比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。<br>&emsp; 2.在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。<br>&emsp; 3.私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。<br>&emsp; 从私钥推导出公钥、再从公钥推导出公钥哈希都是单向的，也就是<strong>采用不可逆算法</strong></p>\n</blockquote>\n</li>\n</ul>\n<p><strong><em>椭圆曲线算法</em></strong></p>\n<blockquote>\n<blockquote>\n<p>&emsp; 4.公钥产生后，将公钥通过SHA256哈希算法处理得到32字节的哈希值；后对得到的哈希值通过RIPEMD-160算法来得到20字节的哈希值 ——Hash160<br>&emsp; 5.把版本号[2]+Hash160组成的21字节数组进行双次SHA256哈希运算，得到的哈希值的头4个字节作为校验和，放置21字节数组的末尾。<br>&emsp; 6.对组成25位数组进行Base58编码，最后得到地址。</p>\n</blockquote>\n</blockquote>\n<ul>\n<li><h2 id=\"使用区块链API进行远程调用-常见的一些钱包开源项目：\"><a href=\"#使用区块链API进行远程调用-常见的一些钱包开源项目：\" class=\"headerlink\" title=\"使用区块链API进行远程调用&gt;&gt;常见的一些钱包开源项目：\"></a>使用区块链API进行远程调用<br>&gt;&gt;常见的一些钱包开源项目：</h2><h2 id=\"bitcoin-Bitcoin-Core，官方出品bitcoinj，比特币协议-Java-版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS-钱包Mycelium，Android-钱包Copay，同时支持-Bitcoin-和BitcoinCashbitcoin-wallet，又一款-Android-钱包DotNetWallet，-NET-实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go-实现的钱包\"><a href=\"#bitcoin-Bitcoin-Core，官方出品bitcoinj，比特币协议-Java-版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS-钱包Mycelium，Android-钱包Copay，同时支持-Bitcoin-和BitcoinCashbitcoin-wallet，又一款-Android-钱包DotNetWallet，-NET-实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go-实现的钱包\" class=\"headerlink\" title=\"[bitcoin]Bitcoin Core，官方出品bitcoinj，比特币协议 Java 版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS 钱包Mycelium，Android 钱包Copay，同时支持 Bitcoin 和BitcoinCashbitcoin-wallet，又一款 Android 钱包DotNetWallet，.NET 实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go 实现的钱包\"></a>[<em>bitcoin</em>]<br><strong>Bitcoin Core</strong>，官方出品<br><strong>bitcoinj</strong>，比特币协议 Java 版<br><strong>bither</strong>，简单安全的比特币钱包<br><strong>Electrum</strong>，全平台轻钱包<br><strong>bread，iOS</strong> 钱包<br><strong>Mycelium，Android</strong> 钱包<br><strong>Copay</strong>，同时支持 Bitcoin 和BitcoinCash<br><strong>bitcoin-wallet</strong>，又一款 Android 钱包<br><strong>DotNetWallet</strong>，.NET 实现的钱包<br><strong>Coinpunk</strong>，基于浏览器的钱包<br><strong>btcwallet</strong>，Go 实现的钱包</h2><p>[<em>Ethereum&#x2F;ERC20</em>]<br><strong>go-ethereum</strong>，以太坊协议 Go 版<br><strong>Mist</strong>，官方出品<br><strong>Parity</strong>，支持 Windows、Mac、PC 的钱包<br><strong>MetaMask</strong> chrome浏览器eth wallet插件<br><strong>MyEtherWallet</strong>，基于浏览器的钱包<br><strong>eth-lightwallet</strong>，轻量级 JavasSript 版本钱包<br><strong>ethaddress.org</strong>，纸质版钱包生成器<br><strong>Neureal wallet</strong>，支持 Windows、Mac、PC 的钱包</p>\n</li>\n<li><p>钱包设计：助记词、keystore、密码</p>\n<blockquote>\n<blockquote>\n<p>私钥一般太难记忆了，使用也不方便，所以从钱包设计的角度，就为简化操作同时不丢失安全性，就出现了助记词的方法。<br>一般情况下，助记词由一些单词组成，只要你记住这些单词，按照顺序在钱包中输入，也能打开钱包。<br>根据密钥之间是否有关联，将钱包分为 <em>nondeterministic wallet</em> 和 <em>deterministic wallet</em><br><em>nondeterministic wallet</em>: 密钥对之间没有关联。<br><em>deterministic wallet</em>： 密钥由一个原始的种子主密钥推导而来，常见的推导方式就是树状层级推导，(hierarchical deterministic) 简称HD<br>deterministic wallet 基于BIP32标准实现，通过一个共同的种子维护多对私钥，推导私钥的过程采用不可逆哈希算法，</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<p><em><strong>生成助记词</strong></em></p>\n<blockquote>\n<p>规定熵的位数必须是 32 的整数倍，所以熵的长度取值位128 到 256 之间取 32 的整数倍的值，分别为 128, 160, 192, 224, 256；<br>校验和的长度为熵的长度&#x2F;32 位, 所以校验和长度可为 4，5，6，7，8 位；<br>助记词库有 2048 个词，用 11 位可全部定位词库中所有的词，作为词的索引，故一个词用 11 位表示，助记词的个数可为 (熵+校验和)&#x2F;11，值为 12，15，18，21，24<br>助记词规则:<br>1.生成一个长度为 128~256 位(bits)的随机序列(熵)；<br>2.取熵哈希后的前n位作为校验和(n&#x3D; 熵长度&#x2F;32)；<br>3.随机序列+校验和；<br>4.把步骤3得到的结果每 11位切割；<br>5.步骤4得到的每11位字节匹配词库的一个词；<br>6.步骤5得到的结果就是助记词串;<br><img   src=\"/../assets/name.png\"  alt=\"生成助记词\"><br>7.助记词句子作为密码；<br>8.”mnemonic” + passphrase 作为盐；<br>9.2048 作为重复计算的次数+HMAC-SHA512 作为随机算法,最终得到BIP32 种子，512 位(64 字节)是期望得到的密钥长度；<br><img   src=\"/../assets/secret.png\"  alt=\"生成密钥\"></p>\n</blockquote>\n<p>除了助记词之外，钱包还会设计一个密码，作为用户常用的登录方式，<br>keystore：Keystore也是私钥经过加密过后的一个文件，需要你自己设置的密码才能打开文件。这样的好处是就算keystore文件被盗，只要你额外设置的密码够长够随机，那么短时间内私钥也不会泄露，有充足的时间转移地址里面的加密货币到其他地址。Keystore会存储在使用的设备里，这样每次登陆只用输入相应密码即可。</p>\n<p><em><strong>总结</strong></em></p>\n<blockquote>\n<p>钱包助记词生成了种子（Seed），种子（Seed）生成了私钥，私钥推导出公钥，公钥节选部分成了钱包地址。同时钱包提供了keystore，他也是私钥加密后的文件，可以配合正常的密码使用，便捷了用户的钱包使用</p>\n</blockquote>\n<p>[<em>私钥重复问题</em>]<br>私钥产生的机制就决定了会有重复的可能。</p>\n<blockquote>\n<p>&emsp; 私钥有32个字节，一个字节有8位，所以私钥总数是2^(8*32)&#x3D;2^256个≈10^77个<br>假设宇宙有一亿个星系，<br>每个星系有一亿颗恒星，<br>每颗恒星有一亿颗人造卫星，<br>每颗人造卫星上有一亿台超级计算机，<br>每台超级计算机有一亿个CPU，<br>每个CPU每秒可以穷举一亿个私钥。<br>假设有一亿个私钥的地址上有BTC（每个地址平均0.21BTC），那么，多久可能穷举出一个有币的私钥为：<br>10^77（私钥总数）&#x2F;10^8（有币私钥）&#x2F;10^8（星系）&#x2F;10^8（恒星）&#x2F;10^8（卫星）&#x2F;10^8（超级计算机）&#x2F;10^8（CPU）&#x2F;10^8（每秒穷举）&#x3D;10^21秒。<br>10^21秒&#x2F;3600秒&#x2F;24小时&#x2F;365天&#x3D;317098亿年<br>随着时间的累积，再加上还会有其他的公链出现，如果使用同样的私钥生成地址的规则，概率再小也会有几率出现重复的情况。但是穷举法的代价已经远远超过了所获利，因此可以理解私钥是唯一的。</p>\n</blockquote>\n<h4 id=\"理解钱包的作用\"><a href=\"#理解钱包的作用\" class=\"headerlink\" title=\"理解钱包的作用\"></a>理解钱包的作用</h4><blockquote>\n<p>完成一次交易之后，钱包里没有币，也没有NFT，钱包里保存的是自己的区块链地址和对这个地址的操作权限，这些我们交易得到的币、NFT、或者其他什么加密资产是被记录在了各个网络上的对应的区块链中。<br>可以说，钱包是区块链的遥控器，创建钱包时，用助记词算出私钥，私钥和公钥配对出现，公钥算出地址，地址就是你在区块链中的账号，助记词可以重新算出私钥，可重置钱包，同时钱包生成的keystore也可以解密后获得私钥，用于重置钱包。<br>私钥的作用是获得对地址的操作权限。钱包地址可以看作区块链上的一个节点。<br>发起交易，是通过私钥授权，对地址对应的数据区块进行修改。<br></font></p>\n</blockquote>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<font face=\"微软雅黑\" size=\"3\">\n\n<h2 id=\"什么是区块链钱包\"><a href=\"#什么是区块链钱包\" class=\"headerlink\" title=\"什么是区块链钱包\"></a>什么是区块链钱包</h2><p>&emsp;区块链钱包是加密货币应用中必不可少的一部分，也是加密基础设施中最基础的一部分，区块链钱包的存在使得区块链收发资金成为可能。区块链钱包同时也是web3.0的一个重要入口，事实上，<strong>web3的绝大多数应用，必须要连接区块链钱包才能进一步使用</strong></p>\n<h4 id=\"根据钱包的存储方式划分\"><a href=\"#根据钱包的存储方式划分\" class=\"headerlink\" title=\"根据钱包的存储方式划分\"></a>根据钱包的存储方式划分</h4><p>&emsp;根据用户是否掌握了私钥，可分为<strong>中心化钱包</strong> 和 <strong>去中心化钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>存储方式是指存在哪，只有用户持有私钥且导入钱包后，私钥存在用户设备上后才叫<strong>中心化钱包</strong>，中心化钱包的数据依赖于服务商自己的账本，交易所就是一个典型的中心化钱包，在交易所内完成的交易，就是交易所在自己的账本上增加记录，这个过程，没有发生在链上。<br>&emsp;而无私钥，或者私钥存储在服务商的服务器里，则就是<strong>去中心化钱包</strong>，</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据是否接触网络\"><a href=\"#根据是否接触网络\" class=\"headerlink\" title=\"根据是否接触网络\"></a>根据是否接触网络</h4><p>&emsp;钱包是否联网可分为<strong>冷钱包</strong> 和 <strong>热钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>常见的热钱包指的是桌面钱包: 如 <strong>比特币核心钱包</strong>、<strong>Geth</strong>, 手机钱包，<strong>imToken</strong>、<strong>TpToken</strong>等，以及网页钱包, 如 <strong>metamask</strong> ,而冷钱包指的是硬件钱包，无需联网即可使用，冷钱包外形像U盘。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据去中心化程度\"><a href=\"#根据去中心化程度\" class=\"headerlink\" title=\"根据去中心化程度\"></a>根据去中心化程度</h4><p>&emsp;可将钱包分为<strong>全节点钱包</strong>、<strong>轻节点钱包</strong>、<strong>中心化钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>全节点钱包：完整储存了区块链一切买卖数据的区块链钱包，一般作为官方钱包与节点客户端运用，能够追溯数字财产的来历，验证数字财产的真实性、验证区块链上的买卖是否完成等，由于全节点钱包存储的数据巨大，且数据需要和区块链同步，因此实用性依赖于具体场景。<br>轻节点钱包：没有彻底存储区块链买卖节点的数据钱包，由于数据不完整，只保留了区块链钱包的基本功能，即接入功能和买卖验证功能，轻钱包所有的功能都是为了支持交易的成功进行，市面上常见的app钱包都是轻钱包：<strong>AToken</strong>、<strong>myToken</strong>、<strong>Kcash</strong>等.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据是否支持多币种\"><a href=\"#根据是否支持多币种\" class=\"headerlink\" title=\"根据是否支持多币种\"></a>根据是否支持多币种</h4><p>&emsp;钱包是否支持多币种可分为 <strong>单币种钱包</strong> 和 <strong>多币种钱包</strong></p>\n<blockquote>\n<blockquote>\n<p>单一币种钱包：只为单一区块链资产服务的钱包，也叫主链钱包，一般由项目方或社区开发。<br>多币种钱包：支持多个区块链的数字资产，<br>全币种钱包：支持所有区块链资产，目前全币种钱包很难存在，这意味该钱包需要支持所有类型区块链协议。<br>市场上的多币种钱包已成为主流。<br><strong>imToken</strong> 是依据单ETH主链的多币种钱包，仅支持以ETH协议开发的token。<br><strong>EOSToken</strong> 是以EOS主链的钱包, 仅支持EOS协议开发.</p>\n</blockquote>\n</blockquote>\n<h4 id=\"根据私钥签名方法可分为单签名钱包和多签名钱包\"><a href=\"#根据私钥签名方法可分为单签名钱包和多签名钱包\" class=\"headerlink\" title=\"根据私钥签名方法可分为单签名钱包和多签名钱包\"></a>根据私钥签名方法可分为单签名钱包和多签名钱包</h4><blockquote>\n<blockquote>\n<p>单签名钱包，由单个私钥签名的钱包<br>多签名钱包，需要不同私钥签名进行使用的钱包，一般用于共同管理账户，<br>大多数区块链钱包App都是单签名钱包，Gnosis则是多签名钱包。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"区块链钱包的设计原理\"><a href=\"#区块链钱包的设计原理\" class=\"headerlink\" title=\"区块链钱包的设计原理\"></a>区块链钱包的设计原理</h3><ul>\n<li>私钥、公钥和地址产生的方法<blockquote>\n<p>&emsp; 1.比特币私钥其实是使用SHA-256生成的32字节（256位）的随机数，有效私钥的范围则取决于比特币使用的secp256k1 椭圆曲线数字签名标准。<br>&emsp; 2.在私钥的前面加上版本号，后面添加压缩标志和附加校验码，（所谓附加校验码，就是对私钥经过2次SHA-256运算，取两次哈希结果的前四字节），然后再对其进行Base58编码，就可以得到我们常见的WIF（Wallet import Format)格式的私钥。<br>&emsp; 3.私钥经过椭圆曲线乘法运算，可以得到公钥。公钥是椭圆曲线上的点，并具有x和y坐标。公钥有两种形式：压缩的与非压缩的。早期比特币均使用非压缩公钥，现在大部分客户端默认使用压缩公钥。<br>&emsp; 从私钥推导出公钥、再从公钥推导出公钥哈希都是单向的，也就是<strong>采用不可逆算法</strong></p>\n</blockquote>\n</li>\n</ul>\n<p><strong><em>椭圆曲线算法</em></strong></p>\n<blockquote>\n<blockquote>\n<p>&emsp; 4.公钥产生后，将公钥通过SHA256哈希算法处理得到32字节的哈希值；后对得到的哈希值通过RIPEMD-160算法来得到20字节的哈希值 ——Hash160<br>&emsp; 5.把版本号[2]+Hash160组成的21字节数组进行双次SHA256哈希运算，得到的哈希值的头4个字节作为校验和，放置21字节数组的末尾。<br>&emsp; 6.对组成25位数组进行Base58编码，最后得到地址。</p>\n</blockquote>\n</blockquote>\n<ul>\n<li><h2 id=\"使用区块链API进行远程调用-常见的一些钱包开源项目：\"><a href=\"#使用区块链API进行远程调用-常见的一些钱包开源项目：\" class=\"headerlink\" title=\"使用区块链API进行远程调用&gt;&gt;常见的一些钱包开源项目：\"></a>使用区块链API进行远程调用<br>&gt;&gt;常见的一些钱包开源项目：</h2><h2 id=\"bitcoin-Bitcoin-Core，官方出品bitcoinj，比特币协议-Java-版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS-钱包Mycelium，Android-钱包Copay，同时支持-Bitcoin-和BitcoinCashbitcoin-wallet，又一款-Android-钱包DotNetWallet，-NET-实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go-实现的钱包\"><a href=\"#bitcoin-Bitcoin-Core，官方出品bitcoinj，比特币协议-Java-版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS-钱包Mycelium，Android-钱包Copay，同时支持-Bitcoin-和BitcoinCashbitcoin-wallet，又一款-Android-钱包DotNetWallet，-NET-实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go-实现的钱包\" class=\"headerlink\" title=\"[bitcoin]Bitcoin Core，官方出品bitcoinj，比特币协议 Java 版bither，简单安全的比特币钱包Electrum，全平台轻钱包bread，iOS 钱包Mycelium，Android 钱包Copay，同时支持 Bitcoin 和BitcoinCashbitcoin-wallet，又一款 Android 钱包DotNetWallet，.NET 实现的钱包Coinpunk，基于浏览器的钱包btcwallet，Go 实现的钱包\"></a>[<em>bitcoin</em>]<br><strong>Bitcoin Core</strong>，官方出品<br><strong>bitcoinj</strong>，比特币协议 Java 版<br><strong>bither</strong>，简单安全的比特币钱包<br><strong>Electrum</strong>，全平台轻钱包<br><strong>bread，iOS</strong> 钱包<br><strong>Mycelium，Android</strong> 钱包<br><strong>Copay</strong>，同时支持 Bitcoin 和BitcoinCash<br><strong>bitcoin-wallet</strong>，又一款 Android 钱包<br><strong>DotNetWallet</strong>，.NET 实现的钱包<br><strong>Coinpunk</strong>，基于浏览器的钱包<br><strong>btcwallet</strong>，Go 实现的钱包</h2><p>[<em>Ethereum&#x2F;ERC20</em>]<br><strong>go-ethereum</strong>，以太坊协议 Go 版<br><strong>Mist</strong>，官方出品<br><strong>Parity</strong>，支持 Windows、Mac、PC 的钱包<br><strong>MetaMask</strong> chrome浏览器eth wallet插件<br><strong>MyEtherWallet</strong>，基于浏览器的钱包<br><strong>eth-lightwallet</strong>，轻量级 JavasSript 版本钱包<br><strong>ethaddress.org</strong>，纸质版钱包生成器<br><strong>Neureal wallet</strong>，支持 Windows、Mac、PC 的钱包</p>\n</li>\n<li><p>钱包设计：助记词、keystore、密码</p>\n<blockquote>\n<blockquote>\n<p>私钥一般太难记忆了，使用也不方便，所以从钱包设计的角度，就为简化操作同时不丢失安全性，就出现了助记词的方法。<br>一般情况下，助记词由一些单词组成，只要你记住这些单词，按照顺序在钱包中输入，也能打开钱包。<br>根据密钥之间是否有关联，将钱包分为 <em>nondeterministic wallet</em> 和 <em>deterministic wallet</em><br><em>nondeterministic wallet</em>: 密钥对之间没有关联。<br><em>deterministic wallet</em>： 密钥由一个原始的种子主密钥推导而来，常见的推导方式就是树状层级推导，(hierarchical deterministic) 简称HD<br>deterministic wallet 基于BIP32标准实现，通过一个共同的种子维护多对私钥，推导私钥的过程采用不可逆哈希算法，</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<p><em><strong>生成助记词</strong></em></p>\n<blockquote>\n<p>规定熵的位数必须是 32 的整数倍，所以熵的长度取值位128 到 256 之间取 32 的整数倍的值，分别为 128, 160, 192, 224, 256；<br>校验和的长度为熵的长度&#x2F;32 位, 所以校验和长度可为 4，5，6，7，8 位；<br>助记词库有 2048 个词，用 11 位可全部定位词库中所有的词，作为词的索引，故一个词用 11 位表示，助记词的个数可为 (熵+校验和)&#x2F;11，值为 12，15，18，21，24<br>助记词规则:<br>1.生成一个长度为 128~256 位(bits)的随机序列(熵)；<br>2.取熵哈希后的前n位作为校验和(n&#x3D; 熵长度&#x2F;32)；<br>3.随机序列+校验和；<br>4.把步骤3得到的结果每 11位切割；<br>5.步骤4得到的每11位字节匹配词库的一个词；<br>6.步骤5得到的结果就是助记词串;<br><img   src=\"/../assets/name.png\"  alt=\"生成助记词\"><br>7.助记词句子作为密码；<br>8.”mnemonic” + passphrase 作为盐；<br>9.2048 作为重复计算的次数+HMAC-SHA512 作为随机算法,最终得到BIP32 种子，512 位(64 字节)是期望得到的密钥长度；<br><img   src=\"/../assets/secret.png\"  alt=\"生成密钥\"></p>\n</blockquote>\n<p>除了助记词之外，钱包还会设计一个密码，作为用户常用的登录方式，<br>keystore：Keystore也是私钥经过加密过后的一个文件，需要你自己设置的密码才能打开文件。这样的好处是就算keystore文件被盗，只要你额外设置的密码够长够随机，那么短时间内私钥也不会泄露，有充足的时间转移地址里面的加密货币到其他地址。Keystore会存储在使用的设备里，这样每次登陆只用输入相应密码即可。</p>\n<p><em><strong>总结</strong></em></p>\n<blockquote>\n<p>钱包助记词生成了种子（Seed），种子（Seed）生成了私钥，私钥推导出公钥，公钥节选部分成了钱包地址。同时钱包提供了keystore，他也是私钥加密后的文件，可以配合正常的密码使用，便捷了用户的钱包使用</p>\n</blockquote>\n<p>[<em>私钥重复问题</em>]<br>私钥产生的机制就决定了会有重复的可能。</p>\n<blockquote>\n<p>&emsp; 私钥有32个字节，一个字节有8位，所以私钥总数是2^(8*32)&#x3D;2^256个≈10^77个<br>假设宇宙有一亿个星系，<br>每个星系有一亿颗恒星，<br>每颗恒星有一亿颗人造卫星，<br>每颗人造卫星上有一亿台超级计算机，<br>每台超级计算机有一亿个CPU，<br>每个CPU每秒可以穷举一亿个私钥。<br>假设有一亿个私钥的地址上有BTC（每个地址平均0.21BTC），那么，多久可能穷举出一个有币的私钥为：<br>10^77（私钥总数）&#x2F;10^8（有币私钥）&#x2F;10^8（星系）&#x2F;10^8（恒星）&#x2F;10^8（卫星）&#x2F;10^8（超级计算机）&#x2F;10^8（CPU）&#x2F;10^8（每秒穷举）&#x3D;10^21秒。<br>10^21秒&#x2F;3600秒&#x2F;24小时&#x2F;365天&#x3D;317098亿年<br>随着时间的累积，再加上还会有其他的公链出现，如果使用同样的私钥生成地址的规则，概率再小也会有几率出现重复的情况。但是穷举法的代价已经远远超过了所获利，因此可以理解私钥是唯一的。</p>\n</blockquote>\n<h4 id=\"理解钱包的作用\"><a href=\"#理解钱包的作用\" class=\"headerlink\" title=\"理解钱包的作用\"></a>理解钱包的作用</h4><blockquote>\n<p>完成一次交易之后，钱包里没有币，也没有NFT，钱包里保存的是自己的区块链地址和对这个地址的操作权限，这些我们交易得到的币、NFT、或者其他什么加密资产是被记录在了各个网络上的对应的区块链中。<br>可以说，钱包是区块链的遥控器，创建钱包时，用助记词算出私钥，私钥和公钥配对出现，公钥算出地址，地址就是你在区块链中的账号，助记词可以重新算出私钥，可重置钱包，同时钱包生成的keystore也可以解密后获得私钥，用于重置钱包。<br>私钥的作用是获得对地址的操作权限。钱包地址可以看作区块链上的一个节点。<br>发起交易，是通过私钥授权，对地址对应的数据区块进行修改。<br></font></p>\n</blockquote>\n"},{"title":"前端项目部署","_content":"\n# 大公司如何开发部署前端代码\n\n> 多人协作模式下的前端代码开发、超大流量访问下的前端应用的部署\n\n- 多人协作开发\n  这个比较基础、主要是代码管理方面，使用 git 或者 svn，按照一定的 flow，如从 dev 分支下切新分支进行开发、开发完成之后提测，发起合并请求，合并到测试分支，当测试完成之后继续提交合并请求，上线\n- 大型网站主站的前端应用部署\n  分析一下，部署前端代码到底做了什么呢？\n  主要做的事情就是将静态文件如 index.html、index.js、index.css 放到具体的静态资源服务器上，常见的如 nginx，随后重启服务，部署就完成了，用户要访问最新的应用，刷新页面就可以了，这个过程非常简单。\n  但是问题来了，如果一个网站流量非常大，这样做的话就会出现，光是这三个文件(实际上远不止三个文件)的加载消耗的流量就是天量的数字，非常浪费性能。通常这种问题我们会想到利用浏览器的缓存机制来优化，事实上浏览器的缓存就是这么用的\n  1. 304 协商缓存\n\n     协商缓存还是存在一次与服务器通信过程，我们的目的就是彻底取消与服务器的通信，因此放弃\n\n  2. 强缓存\n\n     强缓存倒是不用通信了，但是不和服务器通信的话，如何更新资源呢，毕竟每次更新的目的都是要让用户去使用我们的产品，这时候可以用更新文件资源路径来让浏览器主动放弃缓存，每一次更新，都自动更新链接地址\n  以上第二种方式可以达到我们的目的，但是也存在一个问题，我们每次更新不能修改所有的文件链接地址，需要知道当前的更新是哪个文件，并且只修改对应的文件地址就好了\n  > 更新对应修改文件的链接地址\n\n如何知道修改了哪个静态资源文件呢，也就是什么东西与文件内容有关呢，可以利用 Hash 算法，将文件内容 hash 成一个字符串内容，hash 算法可以根据每次不同的文件内容生成不同字符串，因此就达到了控制单文件粒度的目的。\n\n这个对文件内容 hash 化的过程，通常是由构建工具完成的，如 webpack、vite、rollup 等等在打包 build 的时候就会处理好，继而将对应的文件路径添加到 html 中。\n\n<aside>\n💡 如果要再继续优化网站性能呢\n\n</aside>\n\n使用 CDN，内容分发网络，将静态资源和动态网页分集群部署，具体是将需要部署的网站主站页面 index.html（动态网页）部署到部署服务器中，将网页包含的静态资源（如 a.js，b.css）部署到 CDN 节点上，最后将 CDN 映射的域名链接添加到动态网页中。\n\n<aside>\n💡 解决完了静态资源和网页的性能问题之后，新的问题出现了，如果同时修改了网页和资源，到底是先部署网页还是先部署资源\n\n</aside>\n\n1. **先部署页面，后部署资源**；那么在二者部署的间隔内，有用户访问页面(大型系统的主站每时每刻都有人访问)，会在新的页面加载旧的资源，除非是手动刷新，否则在资源缓存过期之前，页面会一直执行错误\n2. **先部署资源，后部署页面**；那么在二者部署的间隔内，有旧版本资源本地缓存的用户访问页面，请求的页面也是旧版本的，资源引用没有改变，页面展示正常，而没有本地缓存后者缓存过期的网站，就会出现旧版本页面访问新版本资源的情况，导致页面执行错误（一般是样式错位），除非等到页面部署完成，才能恢复正常。\n\n以上问题说明，先部署都不行，都会有两者的部署间隔期，如果访问量不大的话，可以在访问低谷期部署，也就是半夜上线，这样对流量访问影响最小，但是大型网站，门户网站，主站这些流量很大且没有明显低谷期的网站，就不能通过这种方式发布了；因此以上的问题的根源就是发布的时候旧资源会被丢弃，导致访问不到对应的内容\n\n<aside>\n💡 既然问题是由发布之后访问不同版本资源错位造成的，那么能不能让未刷新页面的人用旧版本资源和页面，新访问的用户访问新版本的资源和页面呢？可以，也就是发布的时候不要覆盖旧版本的内容，这种方式叫非覆盖式发布或者滚动发布\n\n</aside>\n\n内容有修改的文件的资源对其 hash 计算得到一个新的 hash 值，上传到 CDN 节点上，生成成一个新的文件链接发布到线上，不会覆盖已有的资源文件，上线过程中，先全量部署静态资源，再灰度部署页面。问题就解决的差不多了。\n\n总结下来就是：\n\n- 配置超长时间的本地缓存，节省带宽，提高性能\n- 采用内容摘要作为内容更新的依据，精确控制更新的文件\n- 静态资源 CDN 部署\n- 更新资源发布路径采用滚动式发布，平滑升级\n\n> 发布完之后，如果遇到发布代码有问题，需要马上回滚，最好是秒级会滚，应该如何做呢\n\n重新打包部署不现实，因为这个时间太久了，很有可能用户已经访问了错误的页面，最好的方案是能够切换路由到上一个版本，从入口处解决，这个时候就需要在资源链接上增加一个版本号的概念：?version=1.x.x，通过指定渲染哪个版本号的资源就可以达到秒级回滚页面内容的效果。\n\n这里的 version 号可以根据业务来确定，如每次部署都会有一个业务号，每次部署的业务号自增，需要回滚的时候，只需要根据版本号自动切换即可，这个切换最好是在网关处处理，这也意味着滚动式发布是生产环境的最适合的方案，具有容灾备份的效果。\n\n> 以上是属于代码 build 之后进行 deploy 的过程，除此之外，部署的过程还有代码完成之后到 build 这个过程，下面就介绍一下这个过程：CiCd\n\nci/cd：持续交付/持续部署，意思是新增代码后的自动校验格式，打包，构建，跑单元测试，提供单元测试覆盖率，出具报告，之后在进行代码自动部署，目的是简化重复的工作，且不会出错。\n\n常见方案：\n\n- Jenkins\n- Gitlab-ci actions\n- Docker + K8s\n- 自己搭建构建服务器\n\n> 线上部署期间，用户长时间没有访问网页等各种情况，有一定概率出现错误`Uncaught ChunkLoadError: Loading chunk <CHUNK_NAME> failed.` 这个错误是说无法加载资源文件，可能是资源文件名错误,这种情况会导致网页白屏\n\n原因在于现在前端构建工具 webpack 打包出来的项目，主入口(index.html)默认不缓存，其他文件长期缓存，缓存的文件通过改变文件名(hash)来更新，所以在部署期间长期没有访问，会出现请求的资源路径已被删除，或者虽然路径没变，但是 chunk 的内容改变了，导致出现的白屏，\n\n有一下方案：\n\n- 缓存所有版本的文件，空间占用太大\n- 打包出来的文件不做缓存，对服务器压力很大\n- 通过 websocket 等轮询的方式主动告知浏览器更新版本，（也就是刷新页面）需要后端支持\n- 对于报错的文件重试，超过一定次数白屏，主动告知用户刷新页面\n\n综上，采用最后一种方案\n\n缓存重试一定次数后弹窗提示用户刷新页面，借助 webpack-retry-chunk-load-plugin 插件和 html-tag-attribute-plugin 插件配合使用\n\n通常重试的文件不需要全部类型，仅仅需要重试 js 文件即可\n\n[Retry-chunk-load 方案](https://blog.towavephone.com/cache-error-retry-process/)\n","source":"_posts/前端部署.md","raw":"---\ntitle: 前端项目部署\n---\n\n# 大公司如何开发部署前端代码\n\n> 多人协作模式下的前端代码开发、超大流量访问下的前端应用的部署\n\n- 多人协作开发\n  这个比较基础、主要是代码管理方面，使用 git 或者 svn，按照一定的 flow，如从 dev 分支下切新分支进行开发、开发完成之后提测，发起合并请求，合并到测试分支，当测试完成之后继续提交合并请求，上线\n- 大型网站主站的前端应用部署\n  分析一下，部署前端代码到底做了什么呢？\n  主要做的事情就是将静态文件如 index.html、index.js、index.css 放到具体的静态资源服务器上，常见的如 nginx，随后重启服务，部署就完成了，用户要访问最新的应用，刷新页面就可以了，这个过程非常简单。\n  但是问题来了，如果一个网站流量非常大，这样做的话就会出现，光是这三个文件(实际上远不止三个文件)的加载消耗的流量就是天量的数字，非常浪费性能。通常这种问题我们会想到利用浏览器的缓存机制来优化，事实上浏览器的缓存就是这么用的\n  1. 304 协商缓存\n\n     协商缓存还是存在一次与服务器通信过程，我们的目的就是彻底取消与服务器的通信，因此放弃\n\n  2. 强缓存\n\n     强缓存倒是不用通信了，但是不和服务器通信的话，如何更新资源呢，毕竟每次更新的目的都是要让用户去使用我们的产品，这时候可以用更新文件资源路径来让浏览器主动放弃缓存，每一次更新，都自动更新链接地址\n  以上第二种方式可以达到我们的目的，但是也存在一个问题，我们每次更新不能修改所有的文件链接地址，需要知道当前的更新是哪个文件，并且只修改对应的文件地址就好了\n  > 更新对应修改文件的链接地址\n\n如何知道修改了哪个静态资源文件呢，也就是什么东西与文件内容有关呢，可以利用 Hash 算法，将文件内容 hash 成一个字符串内容，hash 算法可以根据每次不同的文件内容生成不同字符串，因此就达到了控制单文件粒度的目的。\n\n这个对文件内容 hash 化的过程，通常是由构建工具完成的，如 webpack、vite、rollup 等等在打包 build 的时候就会处理好，继而将对应的文件路径添加到 html 中。\n\n<aside>\n💡 如果要再继续优化网站性能呢\n\n</aside>\n\n使用 CDN，内容分发网络，将静态资源和动态网页分集群部署，具体是将需要部署的网站主站页面 index.html（动态网页）部署到部署服务器中，将网页包含的静态资源（如 a.js，b.css）部署到 CDN 节点上，最后将 CDN 映射的域名链接添加到动态网页中。\n\n<aside>\n💡 解决完了静态资源和网页的性能问题之后，新的问题出现了，如果同时修改了网页和资源，到底是先部署网页还是先部署资源\n\n</aside>\n\n1. **先部署页面，后部署资源**；那么在二者部署的间隔内，有用户访问页面(大型系统的主站每时每刻都有人访问)，会在新的页面加载旧的资源，除非是手动刷新，否则在资源缓存过期之前，页面会一直执行错误\n2. **先部署资源，后部署页面**；那么在二者部署的间隔内，有旧版本资源本地缓存的用户访问页面，请求的页面也是旧版本的，资源引用没有改变，页面展示正常，而没有本地缓存后者缓存过期的网站，就会出现旧版本页面访问新版本资源的情况，导致页面执行错误（一般是样式错位），除非等到页面部署完成，才能恢复正常。\n\n以上问题说明，先部署都不行，都会有两者的部署间隔期，如果访问量不大的话，可以在访问低谷期部署，也就是半夜上线，这样对流量访问影响最小，但是大型网站，门户网站，主站这些流量很大且没有明显低谷期的网站，就不能通过这种方式发布了；因此以上的问题的根源就是发布的时候旧资源会被丢弃，导致访问不到对应的内容\n\n<aside>\n💡 既然问题是由发布之后访问不同版本资源错位造成的，那么能不能让未刷新页面的人用旧版本资源和页面，新访问的用户访问新版本的资源和页面呢？可以，也就是发布的时候不要覆盖旧版本的内容，这种方式叫非覆盖式发布或者滚动发布\n\n</aside>\n\n内容有修改的文件的资源对其 hash 计算得到一个新的 hash 值，上传到 CDN 节点上，生成成一个新的文件链接发布到线上，不会覆盖已有的资源文件，上线过程中，先全量部署静态资源，再灰度部署页面。问题就解决的差不多了。\n\n总结下来就是：\n\n- 配置超长时间的本地缓存，节省带宽，提高性能\n- 采用内容摘要作为内容更新的依据，精确控制更新的文件\n- 静态资源 CDN 部署\n- 更新资源发布路径采用滚动式发布，平滑升级\n\n> 发布完之后，如果遇到发布代码有问题，需要马上回滚，最好是秒级会滚，应该如何做呢\n\n重新打包部署不现实，因为这个时间太久了，很有可能用户已经访问了错误的页面，最好的方案是能够切换路由到上一个版本，从入口处解决，这个时候就需要在资源链接上增加一个版本号的概念：?version=1.x.x，通过指定渲染哪个版本号的资源就可以达到秒级回滚页面内容的效果。\n\n这里的 version 号可以根据业务来确定，如每次部署都会有一个业务号，每次部署的业务号自增，需要回滚的时候，只需要根据版本号自动切换即可，这个切换最好是在网关处处理，这也意味着滚动式发布是生产环境的最适合的方案，具有容灾备份的效果。\n\n> 以上是属于代码 build 之后进行 deploy 的过程，除此之外，部署的过程还有代码完成之后到 build 这个过程，下面就介绍一下这个过程：CiCd\n\nci/cd：持续交付/持续部署，意思是新增代码后的自动校验格式，打包，构建，跑单元测试，提供单元测试覆盖率，出具报告，之后在进行代码自动部署，目的是简化重复的工作，且不会出错。\n\n常见方案：\n\n- Jenkins\n- Gitlab-ci actions\n- Docker + K8s\n- 自己搭建构建服务器\n\n> 线上部署期间，用户长时间没有访问网页等各种情况，有一定概率出现错误`Uncaught ChunkLoadError: Loading chunk <CHUNK_NAME> failed.` 这个错误是说无法加载资源文件，可能是资源文件名错误,这种情况会导致网页白屏\n\n原因在于现在前端构建工具 webpack 打包出来的项目，主入口(index.html)默认不缓存，其他文件长期缓存，缓存的文件通过改变文件名(hash)来更新，所以在部署期间长期没有访问，会出现请求的资源路径已被删除，或者虽然路径没变，但是 chunk 的内容改变了，导致出现的白屏，\n\n有一下方案：\n\n- 缓存所有版本的文件，空间占用太大\n- 打包出来的文件不做缓存，对服务器压力很大\n- 通过 websocket 等轮询的方式主动告知浏览器更新版本，（也就是刷新页面）需要后端支持\n- 对于报错的文件重试，超过一定次数白屏，主动告知用户刷新页面\n\n综上，采用最后一种方案\n\n缓存重试一定次数后弹窗提示用户刷新页面，借助 webpack-retry-chunk-load-plugin 插件和 html-tag-attribute-plugin 插件配合使用\n\n通常重试的文件不需要全部类型，仅仅需要重试 js 文件即可\n\n[Retry-chunk-load 方案](https://blog.towavephone.com/cache-error-retry-process/)\n","slug":"前端部署","published":1,"date":"2024-03-26T07:55:09.777Z","updated":"2024-03-26T07:56:17.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejru000f3jf0ebdv8bz0","content":"<h1 id=\"大公司如何开发部署前端代码\"><a href=\"#大公司如何开发部署前端代码\" class=\"headerlink\" title=\"大公司如何开发部署前端代码\"></a>大公司如何开发部署前端代码</h1><blockquote>\n<p>多人协作模式下的前端代码开发、超大流量访问下的前端应用的部署</p>\n</blockquote>\n<ul>\n<li>多人协作开发<br>这个比较基础、主要是代码管理方面，使用 git 或者 svn，按照一定的 flow，如从 dev 分支下切新分支进行开发、开发完成之后提测，发起合并请求，合并到测试分支，当测试完成之后继续提交合并请求，上线</li>\n<li>大型网站主站的前端应用部署<br>分析一下，部署前端代码到底做了什么呢？<br>主要做的事情就是将静态文件如 index.html、index.js、index.css 放到具体的静态资源服务器上，常见的如 nginx，随后重启服务，部署就完成了，用户要访问最新的应用，刷新页面就可以了，这个过程非常简单。<br>但是问题来了，如果一个网站流量非常大，这样做的话就会出现，光是这三个文件(实际上远不止三个文件)的加载消耗的流量就是天量的数字，非常浪费性能。通常这种问题我们会想到利用浏览器的缓存机制来优化，事实上浏览器的缓存就是这么用的<ol>\n<li><p>304 协商缓存</p>\n<p>协商缓存还是存在一次与服务器通信过程，我们的目的就是彻底取消与服务器的通信，因此放弃</p>\n</li>\n<li><p>强缓存</p>\n<p>强缓存倒是不用通信了，但是不和服务器通信的话，如何更新资源呢，毕竟每次更新的目的都是要让用户去使用我们的产品，这时候可以用更新文件资源路径来让浏览器主动放弃缓存，每一次更新，都自动更新链接地址</p>\n</li>\n</ol>\n<p>以上第二种方式可以达到我们的目的，但是也存在一个问题，我们每次更新不能修改所有的文件链接地址，需要知道当前的更新是哪个文件，并且只修改对应的文件地址就好了</p>\n<blockquote>\n<p>更新对应修改文件的链接地址</p>\n</blockquote>\n</li>\n</ul>\n<p>如何知道修改了哪个静态资源文件呢，也就是什么东西与文件内容有关呢，可以利用 Hash 算法，将文件内容 hash 成一个字符串内容，hash 算法可以根据每次不同的文件内容生成不同字符串，因此就达到了控制单文件粒度的目的。</p>\n<p>这个对文件内容 hash 化的过程，通常是由构建工具完成的，如 webpack、vite、rollup 等等在打包 build 的时候就会处理好，继而将对应的文件路径添加到 html 中。</p>\n<aside>\n💡 如果要再继续优化网站性能呢\n\n</aside>\n\n<p>使用 CDN，内容分发网络，将静态资源和动态网页分集群部署，具体是将需要部署的网站主站页面 index.html（动态网页）部署到部署服务器中，将网页包含的静态资源（如 a.js，b.css）部署到 CDN 节点上，最后将 CDN 映射的域名链接添加到动态网页中。</p>\n<aside>\n💡 解决完了静态资源和网页的性能问题之后，新的问题出现了，如果同时修改了网页和资源，到底是先部署网页还是先部署资源\n\n</aside>\n\n<ol>\n<li><strong>先部署页面，后部署资源</strong>；那么在二者部署的间隔内，有用户访问页面(大型系统的主站每时每刻都有人访问)，会在新的页面加载旧的资源，除非是手动刷新，否则在资源缓存过期之前，页面会一直执行错误</li>\n<li><strong>先部署资源，后部署页面</strong>；那么在二者部署的间隔内，有旧版本资源本地缓存的用户访问页面，请求的页面也是旧版本的，资源引用没有改变，页面展示正常，而没有本地缓存后者缓存过期的网站，就会出现旧版本页面访问新版本资源的情况，导致页面执行错误（一般是样式错位），除非等到页面部署完成，才能恢复正常。</li>\n</ol>\n<p>以上问题说明，先部署都不行，都会有两者的部署间隔期，如果访问量不大的话，可以在访问低谷期部署，也就是半夜上线，这样对流量访问影响最小，但是大型网站，门户网站，主站这些流量很大且没有明显低谷期的网站，就不能通过这种方式发布了；因此以上的问题的根源就是发布的时候旧资源会被丢弃，导致访问不到对应的内容</p>\n<aside>\n💡 既然问题是由发布之后访问不同版本资源错位造成的，那么能不能让未刷新页面的人用旧版本资源和页面，新访问的用户访问新版本的资源和页面呢？可以，也就是发布的时候不要覆盖旧版本的内容，这种方式叫非覆盖式发布或者滚动发布\n\n</aside>\n\n<p>内容有修改的文件的资源对其 hash 计算得到一个新的 hash 值，上传到 CDN 节点上，生成成一个新的文件链接发布到线上，不会覆盖已有的资源文件，上线过程中，先全量部署静态资源，再灰度部署页面。问题就解决的差不多了。</p>\n<p>总结下来就是：</p>\n<ul>\n<li>配置超长时间的本地缓存，节省带宽，提高性能</li>\n<li>采用内容摘要作为内容更新的依据，精确控制更新的文件</li>\n<li>静态资源 CDN 部署</li>\n<li>更新资源发布路径采用滚动式发布，平滑升级</li>\n</ul>\n<blockquote>\n<p>发布完之后，如果遇到发布代码有问题，需要马上回滚，最好是秒级会滚，应该如何做呢</p>\n</blockquote>\n<p>重新打包部署不现实，因为这个时间太久了，很有可能用户已经访问了错误的页面，最好的方案是能够切换路由到上一个版本，从入口处解决，这个时候就需要在资源链接上增加一个版本号的概念：?version&#x3D;1.x.x，通过指定渲染哪个版本号的资源就可以达到秒级回滚页面内容的效果。</p>\n<p>这里的 version 号可以根据业务来确定，如每次部署都会有一个业务号，每次部署的业务号自增，需要回滚的时候，只需要根据版本号自动切换即可，这个切换最好是在网关处处理，这也意味着滚动式发布是生产环境的最适合的方案，具有容灾备份的效果。</p>\n<blockquote>\n<p>以上是属于代码 build 之后进行 deploy 的过程，除此之外，部署的过程还有代码完成之后到 build 这个过程，下面就介绍一下这个过程：CiCd</p>\n</blockquote>\n<p>ci&#x2F;cd：持续交付&#x2F;持续部署，意思是新增代码后的自动校验格式，打包，构建，跑单元测试，提供单元测试覆盖率，出具报告，之后在进行代码自动部署，目的是简化重复的工作，且不会出错。</p>\n<p>常见方案：</p>\n<ul>\n<li>Jenkins</li>\n<li>Gitlab-ci actions</li>\n<li>Docker + K8s</li>\n<li>自己搭建构建服务器</li>\n</ul>\n<blockquote>\n<p>线上部署期间，用户长时间没有访问网页等各种情况，有一定概率出现错误<code>Uncaught ChunkLoadError: Loading chunk &lt;CHUNK_NAME&gt; failed.</code> 这个错误是说无法加载资源文件，可能是资源文件名错误,这种情况会导致网页白屏</p>\n</blockquote>\n<p>原因在于现在前端构建工具 webpack 打包出来的项目，主入口(index.html)默认不缓存，其他文件长期缓存，缓存的文件通过改变文件名(hash)来更新，所以在部署期间长期没有访问，会出现请求的资源路径已被删除，或者虽然路径没变，但是 chunk 的内容改变了，导致出现的白屏，</p>\n<p>有一下方案：</p>\n<ul>\n<li>缓存所有版本的文件，空间占用太大</li>\n<li>打包出来的文件不做缓存，对服务器压力很大</li>\n<li>通过 websocket 等轮询的方式主动告知浏览器更新版本，（也就是刷新页面）需要后端支持</li>\n<li>对于报错的文件重试，超过一定次数白屏，主动告知用户刷新页面</li>\n</ul>\n<p>综上，采用最后一种方案</p>\n<p>缓存重试一定次数后弹窗提示用户刷新页面，借助 webpack-retry-chunk-load-plugin 插件和 html-tag-attribute-plugin 插件配合使用</p>\n<p>通常重试的文件不需要全部类型，仅仅需要重试 js 文件即可</p>\n<p><a class=\"link\"   href=\"https://blog.towavephone.com/cache-error-retry-process/\" >Retry-chunk-load 方案<i class=\"fas fa-external-link-alt\"></i></a></p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"大公司如何开发部署前端代码\"><a href=\"#大公司如何开发部署前端代码\" class=\"headerlink\" title=\"大公司如何开发部署前端代码\"></a>大公司如何开发部署前端代码</h1><blockquote>\n<p>多人协作模式下的前端代码开发、超大流量访问下的前端应用的部署</p>\n</blockquote>\n<ul>\n<li>多人协作开发<br>这个比较基础、主要是代码管理方面，使用 git 或者 svn，按照一定的 flow，如从 dev 分支下切新分支进行开发、开发完成之后提测，发起合并请求，合并到测试分支，当测试完成之后继续提交合并请求，上线</li>\n<li>大型网站主站的前端应用部署<br>分析一下，部署前端代码到底做了什么呢？<br>主要做的事情就是将静态文件如 index.html、index.js、index.css 放到具体的静态资源服务器上，常见的如 nginx，随后重启服务，部署就完成了，用户要访问最新的应用，刷新页面就可以了，这个过程非常简单。<br>但是问题来了，如果一个网站流量非常大，这样做的话就会出现，光是这三个文件(实际上远不止三个文件)的加载消耗的流量就是天量的数字，非常浪费性能。通常这种问题我们会想到利用浏览器的缓存机制来优化，事实上浏览器的缓存就是这么用的<ol>\n<li><p>304 协商缓存</p>\n<p>协商缓存还是存在一次与服务器通信过程，我们的目的就是彻底取消与服务器的通信，因此放弃</p>\n</li>\n<li><p>强缓存</p>\n<p>强缓存倒是不用通信了，但是不和服务器通信的话，如何更新资源呢，毕竟每次更新的目的都是要让用户去使用我们的产品，这时候可以用更新文件资源路径来让浏览器主动放弃缓存，每一次更新，都自动更新链接地址</p>\n</li>\n</ol>\n<p>以上第二种方式可以达到我们的目的，但是也存在一个问题，我们每次更新不能修改所有的文件链接地址，需要知道当前的更新是哪个文件，并且只修改对应的文件地址就好了</p>\n<blockquote>\n<p>更新对应修改文件的链接地址</p>\n</blockquote>\n</li>\n</ul>\n<p>如何知道修改了哪个静态资源文件呢，也就是什么东西与文件内容有关呢，可以利用 Hash 算法，将文件内容 hash 成一个字符串内容，hash 算法可以根据每次不同的文件内容生成不同字符串，因此就达到了控制单文件粒度的目的。</p>\n<p>这个对文件内容 hash 化的过程，通常是由构建工具完成的，如 webpack、vite、rollup 等等在打包 build 的时候就会处理好，继而将对应的文件路径添加到 html 中。</p>\n<aside>\n💡 如果要再继续优化网站性能呢\n\n</aside>\n\n<p>使用 CDN，内容分发网络，将静态资源和动态网页分集群部署，具体是将需要部署的网站主站页面 index.html（动态网页）部署到部署服务器中，将网页包含的静态资源（如 a.js，b.css）部署到 CDN 节点上，最后将 CDN 映射的域名链接添加到动态网页中。</p>\n<aside>\n💡 解决完了静态资源和网页的性能问题之后，新的问题出现了，如果同时修改了网页和资源，到底是先部署网页还是先部署资源\n\n</aside>\n\n<ol>\n<li><strong>先部署页面，后部署资源</strong>；那么在二者部署的间隔内，有用户访问页面(大型系统的主站每时每刻都有人访问)，会在新的页面加载旧的资源，除非是手动刷新，否则在资源缓存过期之前，页面会一直执行错误</li>\n<li><strong>先部署资源，后部署页面</strong>；那么在二者部署的间隔内，有旧版本资源本地缓存的用户访问页面，请求的页面也是旧版本的，资源引用没有改变，页面展示正常，而没有本地缓存后者缓存过期的网站，就会出现旧版本页面访问新版本资源的情况，导致页面执行错误（一般是样式错位），除非等到页面部署完成，才能恢复正常。</li>\n</ol>\n<p>以上问题说明，先部署都不行，都会有两者的部署间隔期，如果访问量不大的话，可以在访问低谷期部署，也就是半夜上线，这样对流量访问影响最小，但是大型网站，门户网站，主站这些流量很大且没有明显低谷期的网站，就不能通过这种方式发布了；因此以上的问题的根源就是发布的时候旧资源会被丢弃，导致访问不到对应的内容</p>\n<aside>\n💡 既然问题是由发布之后访问不同版本资源错位造成的，那么能不能让未刷新页面的人用旧版本资源和页面，新访问的用户访问新版本的资源和页面呢？可以，也就是发布的时候不要覆盖旧版本的内容，这种方式叫非覆盖式发布或者滚动发布\n\n</aside>\n\n<p>内容有修改的文件的资源对其 hash 计算得到一个新的 hash 值，上传到 CDN 节点上，生成成一个新的文件链接发布到线上，不会覆盖已有的资源文件，上线过程中，先全量部署静态资源，再灰度部署页面。问题就解决的差不多了。</p>\n<p>总结下来就是：</p>\n<ul>\n<li>配置超长时间的本地缓存，节省带宽，提高性能</li>\n<li>采用内容摘要作为内容更新的依据，精确控制更新的文件</li>\n<li>静态资源 CDN 部署</li>\n<li>更新资源发布路径采用滚动式发布，平滑升级</li>\n</ul>\n<blockquote>\n<p>发布完之后，如果遇到发布代码有问题，需要马上回滚，最好是秒级会滚，应该如何做呢</p>\n</blockquote>\n<p>重新打包部署不现实，因为这个时间太久了，很有可能用户已经访问了错误的页面，最好的方案是能够切换路由到上一个版本，从入口处解决，这个时候就需要在资源链接上增加一个版本号的概念：?version&#x3D;1.x.x，通过指定渲染哪个版本号的资源就可以达到秒级回滚页面内容的效果。</p>\n<p>这里的 version 号可以根据业务来确定，如每次部署都会有一个业务号，每次部署的业务号自增，需要回滚的时候，只需要根据版本号自动切换即可，这个切换最好是在网关处处理，这也意味着滚动式发布是生产环境的最适合的方案，具有容灾备份的效果。</p>\n<blockquote>\n<p>以上是属于代码 build 之后进行 deploy 的过程，除此之外，部署的过程还有代码完成之后到 build 这个过程，下面就介绍一下这个过程：CiCd</p>\n</blockquote>\n<p>ci&#x2F;cd：持续交付&#x2F;持续部署，意思是新增代码后的自动校验格式，打包，构建，跑单元测试，提供单元测试覆盖率，出具报告，之后在进行代码自动部署，目的是简化重复的工作，且不会出错。</p>\n<p>常见方案：</p>\n<ul>\n<li>Jenkins</li>\n<li>Gitlab-ci actions</li>\n<li>Docker + K8s</li>\n<li>自己搭建构建服务器</li>\n</ul>\n<blockquote>\n<p>线上部署期间，用户长时间没有访问网页等各种情况，有一定概率出现错误<code>Uncaught ChunkLoadError: Loading chunk &lt;CHUNK_NAME&gt; failed.</code> 这个错误是说无法加载资源文件，可能是资源文件名错误,这种情况会导致网页白屏</p>\n</blockquote>\n<p>原因在于现在前端构建工具 webpack 打包出来的项目，主入口(index.html)默认不缓存，其他文件长期缓存，缓存的文件通过改变文件名(hash)来更新，所以在部署期间长期没有访问，会出现请求的资源路径已被删除，或者虽然路径没变，但是 chunk 的内容改变了，导致出现的白屏，</p>\n<p>有一下方案：</p>\n<ul>\n<li>缓存所有版本的文件，空间占用太大</li>\n<li>打包出来的文件不做缓存，对服务器压力很大</li>\n<li>通过 websocket 等轮询的方式主动告知浏览器更新版本，（也就是刷新页面）需要后端支持</li>\n<li>对于报错的文件重试，超过一定次数白屏，主动告知用户刷新页面</li>\n</ul>\n<p>综上，采用最后一种方案</p>\n<p>缓存重试一定次数后弹窗提示用户刷新页面，借助 webpack-retry-chunk-load-plugin 插件和 html-tag-attribute-plugin 插件配合使用</p>\n<p>通常重试的文件不需要全部类型，仅仅需要重试 js 文件即可</p>\n<p><a class=\"link\"   href=\"https://blog.towavephone.com/cache-error-retry-process/\" >Retry-chunk-load 方案<i class=\"fas fa-external-link-alt\"></i></a></p>\n"},{"title":"聚合器(Yearn)","_content":"\n```jsx\nDeFi聚合器Yearn项目出现原因，源自于DeFi项目的泛滥与治理币诞生，海量的交易导致以太坊的Gas飙升\n```\n\n什么是聚合器：\n\n当 N 多个 DeFi 项目同时 Farm 或者 Mint，项目方发行了一些名为治理币的激励，本意是为了在 DeFi 项目中利用治理币做一些投票来共同管理社区（即投票），结果现在这些治理币的出现，导致以太坊的 Gas Fee 居高不下（因为要获得这些代币就需要进行交易）\n\n这个时候就希望有一种项目，能够解决在很多个项目的池子中自动根据算法决定将钱投入到哪里，挖出来的钱是继续放进池子还是卖掉，怎么卖，什么时候卖，最好放进这个项目池子的项目还能根据份额分红等这些问题。这中项目就称之为：**聚合器**\n\n聚合器可以理解为 DeFi 中的基金，只需要一股脑把钱放进去，具体怎么做，由基金经理处理（这里就是算法和合约），并且聚合器也会有治理币，把钱放在聚合器的池子里不仅能分红，还能挖矿（万物皆有挖矿机制）\n\n显然：聚合器 Yearn 项目因其简单的操作，自然而然的成为了 DeFi 领域的明星，用户根本不需要下载那么多 App，关注那些 DApp 的操作方式，只需要准备好钱，放进 Yearn 中，就有源源不断的收益，发行的代币 YFI 也节节攀升，在 Yearn 项目爆火的同时，会在同时抬高了其他 DeFi 项目的币价\n\n仿盘：\n\n仿盘就是 fork 了 Uniswap 代码，修改了其中合约的参数的类 swap 项目，为什么是 Uniswap，因为 Uniswap 是最早和最著名采用 AMM 的 DEX，同时也是开源的。但是 AMM 的问题在于需要有大量的资金来提供流动性才能变得好用，如果交易量上不去，分红就上不去，于是也没有足够的奖励来吸引那么多的资金来提供流动性。\n\n这个时候就出现了 Compound 搞出来的治理币和流动性挖矿\n\nCompound 的出现可以说大大激活了 DeFi 的市场，不一样的玩法，高额的收益，使得流动性越来越高，但是，很快，这种局面就被打破了，**SushiSwap**出现了\n\nSushiSwap，复制了 Uniswap 的代码，但是加入了治理币和流动性挖矿，可以说是 UniSwap 和 Compound 的结合，除此之外，还照搬了 Uniswap 的 logo，很直接的向世界宣布自己就是 Uniswap 的复制品，所有的智能合约都是照抄的，但是宣称自己是更好的 Uniswap，因为加入了流动性挖矿，因为自己发行治理币。\n\n为什么这么说，流动性挖矿是要有人注入流动性，也就是需要充钱到池子里才给用户发币，但是 Sushiswap 的做法是：给池子里注入流动性，就给发币，但是只有两周时间，两周后还想要币，只需要把钱放到池子里（不需要其他用户发生交易即可）。\n\n什么意思呢，本来流动性挖矿是需要用户发生交易之后，swap 抽取利率作为激励发放对应的奖励给用户（也就是币），但是现在 sushiswap 只需要用户将钱放到池子里，就会给用户发代币（sushi），用户什么都不用干就会有收益，唯一需要担心的是 sushi 代币的价值，这是无本万利的事。而且 sushi 火了的话，肯定会有更多人将钱投到 sushiswap 里，流动性也上来了，交易量也会上来，注意，sushiswap 和 Uniswap 一模一样，这时候流动性挖矿的收益也是水涨船高，于是 Sushiswap 凭借这种策略，顺利的让其暴涨，吸收了天量的资金，既然 sushiswap 成功了，自然而然的会带动其他的一些仿盘项目（食物系，，什么 Salmon，Taco，Pasta 等），这类项目就是仿盘的起源。\n\n后发的项目怎么能和先发的项目竞争呢，sushiswap 是第一个吃螃蟹的人，后续的仿盘都是出道即巅峰，马上就消失不见。没有金融创新，是吸收不到资金的。也有一些创新针对的是预挖项目币的情况，因为大部分的项目在发行的时候，会提前给开发团队，或者 VC 一些币，这是给先进入的人的优势回报，这就是预挖，但是，这样就会让后来进入的人没有足够的回报，因此诞生了 YFII，也是 copy 的 YFI 的仿盘项目，但是 YFII 没有预挖，而是直接将钱分给用户。因为没有开发团队，没有投资者，所有的代码都是从公链上拿下来的，完全没有成本。\n\n这些也是仿盘的优势：没有开发团队，没有代码审计，没有投资人，，没有代码审计就是最大的问题，仿盘没有一个正经的开发团队，没有投资人，就意味着会走向失控。换句话说，这不是仿盘带来的风险，而是 DeFi 的结构性问题。\n\n明星项目 YAM 就是 Yearn 的仿盘，调整了代币的分配策略，动态调整机制能够发新币吸引新人加入。但是 YAM 的代码 bug 导致了整个项目上线即崩盘。\n\n这也是 DeFi 项目中的智能合约 bug，一旦智能合约出现 bug，那么不管是不是仿盘都会出问题。这是代码审计的问题。\n\n以上总总，DeFi 就算有再多的问题，但是最大价值就在于，去中心化总是对的，但去中心化交易所不一定是好的。\n","source":"_posts/聚合器Yearn.md","raw":"---\ntitle: 聚合器(Yearn)\n---\n\n```jsx\nDeFi聚合器Yearn项目出现原因，源自于DeFi项目的泛滥与治理币诞生，海量的交易导致以太坊的Gas飙升\n```\n\n什么是聚合器：\n\n当 N 多个 DeFi 项目同时 Farm 或者 Mint，项目方发行了一些名为治理币的激励，本意是为了在 DeFi 项目中利用治理币做一些投票来共同管理社区（即投票），结果现在这些治理币的出现，导致以太坊的 Gas Fee 居高不下（因为要获得这些代币就需要进行交易）\n\n这个时候就希望有一种项目，能够解决在很多个项目的池子中自动根据算法决定将钱投入到哪里，挖出来的钱是继续放进池子还是卖掉，怎么卖，什么时候卖，最好放进这个项目池子的项目还能根据份额分红等这些问题。这中项目就称之为：**聚合器**\n\n聚合器可以理解为 DeFi 中的基金，只需要一股脑把钱放进去，具体怎么做，由基金经理处理（这里就是算法和合约），并且聚合器也会有治理币，把钱放在聚合器的池子里不仅能分红，还能挖矿（万物皆有挖矿机制）\n\n显然：聚合器 Yearn 项目因其简单的操作，自然而然的成为了 DeFi 领域的明星，用户根本不需要下载那么多 App，关注那些 DApp 的操作方式，只需要准备好钱，放进 Yearn 中，就有源源不断的收益，发行的代币 YFI 也节节攀升，在 Yearn 项目爆火的同时，会在同时抬高了其他 DeFi 项目的币价\n\n仿盘：\n\n仿盘就是 fork 了 Uniswap 代码，修改了其中合约的参数的类 swap 项目，为什么是 Uniswap，因为 Uniswap 是最早和最著名采用 AMM 的 DEX，同时也是开源的。但是 AMM 的问题在于需要有大量的资金来提供流动性才能变得好用，如果交易量上不去，分红就上不去，于是也没有足够的奖励来吸引那么多的资金来提供流动性。\n\n这个时候就出现了 Compound 搞出来的治理币和流动性挖矿\n\nCompound 的出现可以说大大激活了 DeFi 的市场，不一样的玩法，高额的收益，使得流动性越来越高，但是，很快，这种局面就被打破了，**SushiSwap**出现了\n\nSushiSwap，复制了 Uniswap 的代码，但是加入了治理币和流动性挖矿，可以说是 UniSwap 和 Compound 的结合，除此之外，还照搬了 Uniswap 的 logo，很直接的向世界宣布自己就是 Uniswap 的复制品，所有的智能合约都是照抄的，但是宣称自己是更好的 Uniswap，因为加入了流动性挖矿，因为自己发行治理币。\n\n为什么这么说，流动性挖矿是要有人注入流动性，也就是需要充钱到池子里才给用户发币，但是 Sushiswap 的做法是：给池子里注入流动性，就给发币，但是只有两周时间，两周后还想要币，只需要把钱放到池子里（不需要其他用户发生交易即可）。\n\n什么意思呢，本来流动性挖矿是需要用户发生交易之后，swap 抽取利率作为激励发放对应的奖励给用户（也就是币），但是现在 sushiswap 只需要用户将钱放到池子里，就会给用户发代币（sushi），用户什么都不用干就会有收益，唯一需要担心的是 sushi 代币的价值，这是无本万利的事。而且 sushi 火了的话，肯定会有更多人将钱投到 sushiswap 里，流动性也上来了，交易量也会上来，注意，sushiswap 和 Uniswap 一模一样，这时候流动性挖矿的收益也是水涨船高，于是 Sushiswap 凭借这种策略，顺利的让其暴涨，吸收了天量的资金，既然 sushiswap 成功了，自然而然的会带动其他的一些仿盘项目（食物系，，什么 Salmon，Taco，Pasta 等），这类项目就是仿盘的起源。\n\n后发的项目怎么能和先发的项目竞争呢，sushiswap 是第一个吃螃蟹的人，后续的仿盘都是出道即巅峰，马上就消失不见。没有金融创新，是吸收不到资金的。也有一些创新针对的是预挖项目币的情况，因为大部分的项目在发行的时候，会提前给开发团队，或者 VC 一些币，这是给先进入的人的优势回报，这就是预挖，但是，这样就会让后来进入的人没有足够的回报，因此诞生了 YFII，也是 copy 的 YFI 的仿盘项目，但是 YFII 没有预挖，而是直接将钱分给用户。因为没有开发团队，没有投资者，所有的代码都是从公链上拿下来的，完全没有成本。\n\n这些也是仿盘的优势：没有开发团队，没有代码审计，没有投资人，，没有代码审计就是最大的问题，仿盘没有一个正经的开发团队，没有投资人，就意味着会走向失控。换句话说，这不是仿盘带来的风险，而是 DeFi 的结构性问题。\n\n明星项目 YAM 就是 Yearn 的仿盘，调整了代币的分配策略，动态调整机制能够发新币吸引新人加入。但是 YAM 的代码 bug 导致了整个项目上线即崩盘。\n\n这也是 DeFi 项目中的智能合约 bug，一旦智能合约出现 bug，那么不管是不是仿盘都会出问题。这是代码审计的问题。\n\n以上总总，DeFi 就算有再多的问题，但是最大价值就在于，去中心化总是对的，但去中心化交易所不一定是好的。\n","slug":"聚合器Yearn","published":1,"date":"2024-03-29T03:52:13.278Z","updated":"2024-03-29T03:52:46.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejru000g3jf0824l3niq","content":"<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">DeFi</span>聚合器<span class=\"title class_\">Yearn</span>项目出现原因，源自于<span class=\"title class_\">DeFi</span>项目的泛滥与治理币诞生，海量的交易导致以太坊的<span class=\"title class_\">Gas</span>飙升</span><br></pre></td></tr></table></figure>\n\n<p>什么是聚合器：</p>\n<p>当 N 多个 DeFi 项目同时 Farm 或者 Mint，项目方发行了一些名为治理币的激励，本意是为了在 DeFi 项目中利用治理币做一些投票来共同管理社区（即投票），结果现在这些治理币的出现，导致以太坊的 Gas Fee 居高不下（因为要获得这些代币就需要进行交易）</p>\n<p>这个时候就希望有一种项目，能够解决在很多个项目的池子中自动根据算法决定将钱投入到哪里，挖出来的钱是继续放进池子还是卖掉，怎么卖，什么时候卖，最好放进这个项目池子的项目还能根据份额分红等这些问题。这中项目就称之为：<strong>聚合器</strong></p>\n<p>聚合器可以理解为 DeFi 中的基金，只需要一股脑把钱放进去，具体怎么做，由基金经理处理（这里就是算法和合约），并且聚合器也会有治理币，把钱放在聚合器的池子里不仅能分红，还能挖矿（万物皆有挖矿机制）</p>\n<p>显然：聚合器 Yearn 项目因其简单的操作，自然而然的成为了 DeFi 领域的明星，用户根本不需要下载那么多 App，关注那些 DApp 的操作方式，只需要准备好钱，放进 Yearn 中，就有源源不断的收益，发行的代币 YFI 也节节攀升，在 Yearn 项目爆火的同时，会在同时抬高了其他 DeFi 项目的币价</p>\n<p>仿盘：</p>\n<p>仿盘就是 fork 了 Uniswap 代码，修改了其中合约的参数的类 swap 项目，为什么是 Uniswap，因为 Uniswap 是最早和最著名采用 AMM 的 DEX，同时也是开源的。但是 AMM 的问题在于需要有大量的资金来提供流动性才能变得好用，如果交易量上不去，分红就上不去，于是也没有足够的奖励来吸引那么多的资金来提供流动性。</p>\n<p>这个时候就出现了 Compound 搞出来的治理币和流动性挖矿</p>\n<p>Compound 的出现可以说大大激活了 DeFi 的市场，不一样的玩法，高额的收益，使得流动性越来越高，但是，很快，这种局面就被打破了，<strong>SushiSwap</strong>出现了</p>\n<p>SushiSwap，复制了 Uniswap 的代码，但是加入了治理币和流动性挖矿，可以说是 UniSwap 和 Compound 的结合，除此之外，还照搬了 Uniswap 的 logo，很直接的向世界宣布自己就是 Uniswap 的复制品，所有的智能合约都是照抄的，但是宣称自己是更好的 Uniswap，因为加入了流动性挖矿，因为自己发行治理币。</p>\n<p>为什么这么说，流动性挖矿是要有人注入流动性，也就是需要充钱到池子里才给用户发币，但是 Sushiswap 的做法是：给池子里注入流动性，就给发币，但是只有两周时间，两周后还想要币，只需要把钱放到池子里（不需要其他用户发生交易即可）。</p>\n<p>什么意思呢，本来流动性挖矿是需要用户发生交易之后，swap 抽取利率作为激励发放对应的奖励给用户（也就是币），但是现在 sushiswap 只需要用户将钱放到池子里，就会给用户发代币（sushi），用户什么都不用干就会有收益，唯一需要担心的是 sushi 代币的价值，这是无本万利的事。而且 sushi 火了的话，肯定会有更多人将钱投到 sushiswap 里，流动性也上来了，交易量也会上来，注意，sushiswap 和 Uniswap 一模一样，这时候流动性挖矿的收益也是水涨船高，于是 Sushiswap 凭借这种策略，顺利的让其暴涨，吸收了天量的资金，既然 sushiswap 成功了，自然而然的会带动其他的一些仿盘项目（食物系，，什么 Salmon，Taco，Pasta 等），这类项目就是仿盘的起源。</p>\n<p>后发的项目怎么能和先发的项目竞争呢，sushiswap 是第一个吃螃蟹的人，后续的仿盘都是出道即巅峰，马上就消失不见。没有金融创新，是吸收不到资金的。也有一些创新针对的是预挖项目币的情况，因为大部分的项目在发行的时候，会提前给开发团队，或者 VC 一些币，这是给先进入的人的优势回报，这就是预挖，但是，这样就会让后来进入的人没有足够的回报，因此诞生了 YFII，也是 copy 的 YFI 的仿盘项目，但是 YFII 没有预挖，而是直接将钱分给用户。因为没有开发团队，没有投资者，所有的代码都是从公链上拿下来的，完全没有成本。</p>\n<p>这些也是仿盘的优势：没有开发团队，没有代码审计，没有投资人，，没有代码审计就是最大的问题，仿盘没有一个正经的开发团队，没有投资人，就意味着会走向失控。换句话说，这不是仿盘带来的风险，而是 DeFi 的结构性问题。</p>\n<p>明星项目 YAM 就是 Yearn 的仿盘，调整了代币的分配策略，动态调整机制能够发新币吸引新人加入。但是 YAM 的代码 bug 导致了整个项目上线即崩盘。</p>\n<p>这也是 DeFi 项目中的智能合约 bug，一旦智能合约出现 bug，那么不管是不是仿盘都会出问题。这是代码审计的问题。</p>\n<p>以上总总，DeFi 就算有再多的问题，但是最大价值就在于，去中心化总是对的，但去中心化交易所不一定是好的。</p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">DeFi</span>聚合器<span class=\"title class_\">Yearn</span>项目出现原因，源自于<span class=\"title class_\">DeFi</span>项目的泛滥与治理币诞生，海量的交易导致以太坊的<span class=\"title class_\">Gas</span>飙升</span><br></pre></td></tr></table></figure>\n\n<p>什么是聚合器：</p>\n<p>当 N 多个 DeFi 项目同时 Farm 或者 Mint，项目方发行了一些名为治理币的激励，本意是为了在 DeFi 项目中利用治理币做一些投票来共同管理社区（即投票），结果现在这些治理币的出现，导致以太坊的 Gas Fee 居高不下（因为要获得这些代币就需要进行交易）</p>\n<p>这个时候就希望有一种项目，能够解决在很多个项目的池子中自动根据算法决定将钱投入到哪里，挖出来的钱是继续放进池子还是卖掉，怎么卖，什么时候卖，最好放进这个项目池子的项目还能根据份额分红等这些问题。这中项目就称之为：<strong>聚合器</strong></p>\n<p>聚合器可以理解为 DeFi 中的基金，只需要一股脑把钱放进去，具体怎么做，由基金经理处理（这里就是算法和合约），并且聚合器也会有治理币，把钱放在聚合器的池子里不仅能分红，还能挖矿（万物皆有挖矿机制）</p>\n<p>显然：聚合器 Yearn 项目因其简单的操作，自然而然的成为了 DeFi 领域的明星，用户根本不需要下载那么多 App，关注那些 DApp 的操作方式，只需要准备好钱，放进 Yearn 中，就有源源不断的收益，发行的代币 YFI 也节节攀升，在 Yearn 项目爆火的同时，会在同时抬高了其他 DeFi 项目的币价</p>\n<p>仿盘：</p>\n<p>仿盘就是 fork 了 Uniswap 代码，修改了其中合约的参数的类 swap 项目，为什么是 Uniswap，因为 Uniswap 是最早和最著名采用 AMM 的 DEX，同时也是开源的。但是 AMM 的问题在于需要有大量的资金来提供流动性才能变得好用，如果交易量上不去，分红就上不去，于是也没有足够的奖励来吸引那么多的资金来提供流动性。</p>\n<p>这个时候就出现了 Compound 搞出来的治理币和流动性挖矿</p>\n<p>Compound 的出现可以说大大激活了 DeFi 的市场，不一样的玩法，高额的收益，使得流动性越来越高，但是，很快，这种局面就被打破了，<strong>SushiSwap</strong>出现了</p>\n<p>SushiSwap，复制了 Uniswap 的代码，但是加入了治理币和流动性挖矿，可以说是 UniSwap 和 Compound 的结合，除此之外，还照搬了 Uniswap 的 logo，很直接的向世界宣布自己就是 Uniswap 的复制品，所有的智能合约都是照抄的，但是宣称自己是更好的 Uniswap，因为加入了流动性挖矿，因为自己发行治理币。</p>\n<p>为什么这么说，流动性挖矿是要有人注入流动性，也就是需要充钱到池子里才给用户发币，但是 Sushiswap 的做法是：给池子里注入流动性，就给发币，但是只有两周时间，两周后还想要币，只需要把钱放到池子里（不需要其他用户发生交易即可）。</p>\n<p>什么意思呢，本来流动性挖矿是需要用户发生交易之后，swap 抽取利率作为激励发放对应的奖励给用户（也就是币），但是现在 sushiswap 只需要用户将钱放到池子里，就会给用户发代币（sushi），用户什么都不用干就会有收益，唯一需要担心的是 sushi 代币的价值，这是无本万利的事。而且 sushi 火了的话，肯定会有更多人将钱投到 sushiswap 里，流动性也上来了，交易量也会上来，注意，sushiswap 和 Uniswap 一模一样，这时候流动性挖矿的收益也是水涨船高，于是 Sushiswap 凭借这种策略，顺利的让其暴涨，吸收了天量的资金，既然 sushiswap 成功了，自然而然的会带动其他的一些仿盘项目（食物系，，什么 Salmon，Taco，Pasta 等），这类项目就是仿盘的起源。</p>\n<p>后发的项目怎么能和先发的项目竞争呢，sushiswap 是第一个吃螃蟹的人，后续的仿盘都是出道即巅峰，马上就消失不见。没有金融创新，是吸收不到资金的。也有一些创新针对的是预挖项目币的情况，因为大部分的项目在发行的时候，会提前给开发团队，或者 VC 一些币，这是给先进入的人的优势回报，这就是预挖，但是，这样就会让后来进入的人没有足够的回报，因此诞生了 YFII，也是 copy 的 YFI 的仿盘项目，但是 YFII 没有预挖，而是直接将钱分给用户。因为没有开发团队，没有投资者，所有的代码都是从公链上拿下来的，完全没有成本。</p>\n<p>这些也是仿盘的优势：没有开发团队，没有代码审计，没有投资人，，没有代码审计就是最大的问题，仿盘没有一个正经的开发团队，没有投资人，就意味着会走向失控。换句话说，这不是仿盘带来的风险，而是 DeFi 的结构性问题。</p>\n<p>明星项目 YAM 就是 Yearn 的仿盘，调整了代币的分配策略，动态调整机制能够发新币吸引新人加入。但是 YAM 的代码 bug 导致了整个项目上线即崩盘。</p>\n<p>这也是 DeFi 项目中的智能合约 bug，一旦智能合约出现 bug，那么不管是不是仿盘都会出问题。这是代码审计的问题。</p>\n<p>以上总总，DeFi 就算有再多的问题，但是最大价值就在于，去中心化总是对的，但去中心化交易所不一定是好的。</p>\n"},{"title":"重新出发——艰难职场之路","_content":"\n# 职场之路\n\n# 未来规划\n\n# 想做的事情\n\n# 坚持\n","source":"_posts/重新出发.md","raw":"---\ntitle: 重新出发——艰难职场之路\n---\n\n# 职场之路\n\n# 未来规划\n\n# 想做的事情\n\n# 坚持\n","slug":"重新出发","published":1,"date":"2024-05-13T09:39:50.333Z","updated":"2024-05-13T10:11:20.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ejru000h3jf04y8a7xw6","content":"<h1 id=\"职场之路\"><a href=\"#职场之路\" class=\"headerlink\" title=\"职场之路\"></a>职场之路</h1><h1 id=\"未来规划\"><a href=\"#未来规划\" class=\"headerlink\" title=\"未来规划\"></a>未来规划</h1><h1 id=\"想做的事情\"><a href=\"#想做的事情\" class=\"headerlink\" title=\"想做的事情\"></a>想做的事情</h1><h1 id=\"坚持\"><a href=\"#坚持\" class=\"headerlink\" title=\"坚持\"></a>坚持</h1>","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<h1 id=\"职场之路\"><a href=\"#职场之路\" class=\"headerlink\" title=\"职场之路\"></a>职场之路</h1><h1 id=\"未来规划\"><a href=\"#未来规划\" class=\"headerlink\" title=\"未来规划\"></a>未来规划</h1><h1 id=\"想做的事情\"><a href=\"#想做的事情\" class=\"headerlink\" title=\"想做的事情\"></a>想做的事情</h1><h1 id=\"坚持\"><a href=\"#坚持\" class=\"headerlink\" title=\"坚持\"></a>坚持</h1>"},{"title":"流动性挖矿","_content":"\n什么是挖矿？\n\n最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。\n\n**区块链挖矿**主要包括以下几个方面：\n\n- 交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。\n- 工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”\n- 区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。\n- 区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接\n- 奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。\n\n以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制\n\n除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押\n\n# 流动性挖矿\n\n这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。\n\n- 流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。\n- 提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易\n- 交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。\n- 额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。\n- 风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）\n\n流动性挖矿有两种模式：Yield Farming 和 Yield Mining\n\n- **Farming**：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益\n- **Mining**：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。\n\n# Stake：质押\n\n质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B\n\n和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，\n\n- 质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。\n- 收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。\n- 质押会有资产的锁定期限制，锁定期内无法赎回\n- 质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。\n\n# DEX 的收益获取\n\nDEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢\n\n在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：\n\n- LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）\n- 平台收益：用于一部分的平台治理、运营、开发团队的成本\n- 流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。\n- 社区基金：DEX 的社区运营治理也需要一些费用\n- 捐赠：公益项目\n\n# 问题：\n\nDEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢\n\nDEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。\n\nDEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。\n","source":"_posts/LiquidityFarm.md","raw":"---\ntitle: 流动性挖矿\n---\n\n什么是挖矿？\n\n最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。\n\n**区块链挖矿**主要包括以下几个方面：\n\n- 交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。\n- 工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”\n- 区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。\n- 区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接\n- 奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。\n\n以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制\n\n除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押\n\n# 流动性挖矿\n\n这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。\n\n- 流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。\n- 提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易\n- 交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。\n- 额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。\n- 风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）\n\n流动性挖矿有两种模式：Yield Farming 和 Yield Mining\n\n- **Farming**：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益\n- **Mining**：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。\n\n# Stake：质押\n\n质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B\n\n和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，\n\n- 质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。\n- 收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。\n- 质押会有资产的锁定期限制，锁定期内无法赎回\n- 质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。\n\n# DEX 的收益获取\n\nDEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢\n\n在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：\n\n- LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）\n- 平台收益：用于一部分的平台治理、运营、开发团队的成本\n- 流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。\n- 社区基金：DEX 的社区运营治理也需要一些费用\n- 捐赠：公益项目\n\n# 问题：\n\nDEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢\n\nDEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。\n\nDEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。\n","slug":"LiquidityFarm","published":1,"date":"2024-05-22T02:58:05.171Z","updated":"2024-05-22T02:58:24.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clwh8ios20000bkf0e5ou5y8n","content":"<p>什么是挖矿？</p>\n<p>最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。</p>\n<p><strong>区块链挖矿</strong>主要包括以下几个方面：</p>\n<ul>\n<li>交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。</li>\n<li>工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”</li>\n<li>区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。</li>\n<li>区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接</li>\n<li>奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。</li>\n</ul>\n<p>以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制</p>\n<p>除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押</p>\n<h1 id=\"流动性挖矿\"><a href=\"#流动性挖矿\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。</p>\n<ul>\n<li>流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。</li>\n<li>提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易</li>\n<li>交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。</li>\n<li>额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。</li>\n<li>风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）</li>\n</ul>\n<p>流动性挖矿有两种模式：Yield Farming 和 Yield Mining</p>\n<ul>\n<li><strong>Farming</strong>：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益</li>\n<li><strong>Mining</strong>：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。</li>\n</ul>\n<h1 id=\"Stake：质押\"><a href=\"#Stake：质押\" class=\"headerlink\" title=\"Stake：质押\"></a>Stake：质押</h1><p>质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B</p>\n<p>和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，</p>\n<ul>\n<li>质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。</li>\n<li>收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。</li>\n<li>质押会有资产的锁定期限制，锁定期内无法赎回</li>\n<li>质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。</li>\n</ul>\n<h1 id=\"DEX-的收益获取\"><a href=\"#DEX-的收益获取\" class=\"headerlink\" title=\"DEX 的收益获取\"></a>DEX 的收益获取</h1><p>DEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢</p>\n<p>在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：</p>\n<ul>\n<li>LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）</li>\n<li>平台收益：用于一部分的平台治理、运营、开发团队的成本</li>\n<li>流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。</li>\n<li>社区基金：DEX 的社区运营治理也需要一些费用</li>\n<li>捐赠：公益项目</li>\n</ul>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>DEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢</p>\n<p>DEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。</p>\n<p>DEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。</p>\n","site":{"data":{"links":[{"name":"XPoet","link":"https://xpoet.cn/","description":"所有命运的馈赠，早已在暗中标好价格。","avatar":"https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/common-use/avatar.jpg"},{"name":"不知名艺术家","link":"https://jinzhanqi.com/","description":"love artist, love code.","avatar":"https://s3.ax1x.com/2020/11/17/DVvkB4.jpg"},{"name":"薇拉航线","link":"https://www.zuozuovera.com/","description":"computer scientist"}]}},"excerpt":"","more":"<p>什么是挖矿？</p>\n<p>最初在区块链中的挖矿是指使用计算机硬件（如 CPU、GPU 或专业的 ASIC 矿机）来执行特定的算法计算，以验证和记录区块链网络中的交易，这个过程对于维护区块链的安全性和去中心化至关重要。</p>\n<p><strong>区块链挖矿</strong>主要包括以下几个方面：</p>\n<ul>\n<li>交易验证：矿工通过解决复杂的数学问题来验证新生成的交易块，确保交易的有效性。</li>\n<li>工作量证明：常见的挖矿机制，要求矿工完成一项计算工作，这项工作的难度确保了网络的安全性。矿工必须投入大量的计算资源来解决难题，这个过程被称为“挖矿”</li>\n<li>区块创建：一旦矿工解决了难题，他们就可以创建一个新的区块，并将待验证的交易打包进这个区块。</li>\n<li>区块链接：新区块被添加到现有的区块上，形成新的链条，这个过程称为区块链接</li>\n<li>奖励机制：成功挖矿的矿工会获得新生成的加密货币作为奖励，这是对矿工所投入计算资源电力的补偿。</li>\n</ul>\n<p>以上是作为 POW（工作量证明的挖矿 Proof of Work）的机制</p>\n<p>除此之外，其他的共识机制如 POS（权益证明 Proof of Stake）和 DPOS（委托权益证明 Delegated Proof of Stake）这些不同的挖矿机制，事实上后两者已经不能算作常规意义的挖矿了，只不过延续之前的叫法仍然叫挖矿，后两者的机制有一个更为适合的名字：质押</p>\n<h1 id=\"流动性挖矿\"><a href=\"#流动性挖矿\" class=\"headerlink\" title=\"流动性挖矿\"></a>流动性挖矿</h1><p>这是一个去中心化金融中的概念（DeFi），流动性挖矿允许用户通过提供资产到特定的流动性池中来赚取奖励。</p>\n<ul>\n<li>流动性池：在 DeFi 中，流动性池是由用户共同出资形成的资产池，用于促进加密货币之间的交易。</li>\n<li>提供流动性：用户向这些流动性池中存入自己的加密货币，从而成为流动性提供者(Liquidity Provider 简称 LP)，用户通过池子维持两者货币的交易流动性，并允许其他用户进行交易</li>\n<li>交易费用：当其他用户在流动性中进行交易时，会生成交易费用，这些费用通常按照流动性提供者存入资产的比例分配给他们，作为提供流动性的奖励。</li>\n<li>额外奖励：除了交易费用之外，一些 DeFi 项目还会通过发放自己的治理代币或者奖励代币来激励流动性提供者。这些代币可能具有价值，并且可以用于项目的治理决策或者在未来获得更多收益。</li>\n<li>风险：尽管流动性挖矿提供了赚取额外收益的机会，但是也伴随着风险，例如：如果流动性池中的资产价格发生大幅波动，可能会导致流动性提供者损失资产（无常损失）</li>\n</ul>\n<p>流动性挖矿有两种模式：Yield Farming 和 Yield Mining</p>\n<ul>\n<li><strong>Farming</strong>：将代币组成交易对存入流动性池中，获得份额，称为 LP，交易者使用资金池产生的交易费用会加入资金池，为每个流动性提供者赚取了手续费，根据份额来分配收益</li>\n<li><strong>Mining</strong>：收益来源来自平台提供而不是手续费，例如平台代币的奖励，提供给 LP，作为收益的补充。</li>\n</ul>\n<h1 id=\"Stake：质押\"><a href=\"#Stake：质押\" class=\"headerlink\" title=\"Stake：质押\"></a>Stake：质押</h1><p>质押指的是存入某种代币 A，随着时间获得新的代币 A 或者另一种代币 B</p>\n<p>和流动性挖矿又一些相同点，都是提供资产来获得收益，这些收益以加密货币的形式发放，两者都是 DeFi 的一部分，</p>\n<ul>\n<li>质押代币需要将代币锁定在钱包或者智能合约中，作为对网络的支持，POS 就是这种方式应用。</li>\n<li>收益来自于网络新新生成的代币和交易费用，质押的收益量按照质押量占总质押量的比例来获得奖励。</li>\n<li>质押会有资产的锁定期限制，锁定期内无法赎回</li>\n<li>质押会影响流动性，除非解锁期结束，否则用户资产一直处于被锁定的状态。</li>\n</ul>\n<h1 id=\"DEX-的收益获取\"><a href=\"#DEX-的收益获取\" class=\"headerlink\" title=\"DEX 的收益获取\"></a>DEX 的收益获取</h1><p>DEX（去中心化交易所）是如何获取收益并将奖励给到 LP（Liquidity Prodiver 流动性提供者）的呢</p>\n<p>在流动性提供者（LP）注入资产到流动性池中后，会获得 DEX 的 LP 代币，这些 LP 代币代表了他们在池中的资产份额，当用户在 DEX 上交易的时候，每一笔交易会产生手续费，无论是用 USDT 买 ETH，还是 ETH 换 USDT，这些手续费就会根据分配方式进行分配：</p>\n<ul>\n<li>LP：根据 LP 的份额，给到流动性提供者收益（流动性挖矿的收益人）</li>\n<li>平台收益：用于一部分的平台治理、运营、开发团队的成本</li>\n<li>流动性挖矿的奖励：除了 LP 的份额之外，还会发放额外的奖励，激励用户提供流动性。</li>\n<li>社区基金：DEX 的社区运营治理也需要一些费用</li>\n<li>捐赠：公益项目</li>\n</ul>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><p>DEX 的费率和 CEX 费率相似甚至偏高，那么用户依然选择 DEX 的原因是什么呢</p>\n<p>DEX 的核心优势就是去中心化，这意味着没有中央机构控制交易过程，降低了单点故障的风险，用户直接在区块链上交易；开放与透明，DEX 的智能合约是开源的；最重要的，DEX 提供了流动性挖矿的机会，用户可以提供流动性来获得额外的代币奖励，这也是 CEX 所没有的。</p>\n<p>DEX 支持更广泛的代币和交易对，对于很多还未上交易所的代币而言，DEX 是早期赚取这些有潜力价值巨大的代币的好机会。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}